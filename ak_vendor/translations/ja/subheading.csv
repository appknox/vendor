id,heading,content,vulnerability_id
1,setPluginState(),"<p>  setPluginState()メソッドは、WebViewを有効化、無効化、あるいはオンデマンドでプラグインを有効化します。</p> <table class=""setplugin"">     <tr>         <td>ON</td>         <td>たとえコンテンツを処理するためのプラグインが存在しなくとも、どのオブジェクトでもロードされます。</td>     </tr>     <tr>         <td>ON_DEMAND</td>         <td>もしコンテンツを処理できるプラグインがあるなら、ユーザがプレースホルダをクリックするまで、プレースホルダは表示されます。クリックすると、プラグインがそのページで有効になります。</td>     </tr>     <tr>         <td>OFF</td>         <td>全てのプラグインがオフになり、フォールバック・コンテンツが使用されます。</td>     </tr> </table> <p>デフォルトは OFF です。</p>",9
2,setAllowFileAccess(),"<p>  setAllowFileAccess()メソッドは、WebView内でのファイルアクセスを有効化または無効化します。</p> <p>デフォルトは true です。</p>",9
3,setAllowContentAccess(),<p>  setAllowContentAccess()メソッドは、WebView内でのコンテンツURLアクセスを有効化または無効化します。コンテンツURLアクセスは、WebViewがシステムにインストールされたコンテンツプロバイダからコンテンツをロードすることを許可します。</p> <p>デフォルトは true です。</p>,9
4,setAllowFileAccessFromFileURLs(),<p>  fileスキームURLのコンテキスト内で稼動しているJavaScriptが、他のfileスキームURLからのコンテンツへのアクセスを許可すべきかを設定しています。最も制限がかかっていて安全なポリシーを有効にするには、この設定は無効にするべきです。この設定の値は、getAllowUniversalAccessFromFileURLs()の値がtrueなら、無視されることに注意してください。</p>  <p>     デフォルト値は、APIレベルがICE_CREAM_SANDWICH_MR1(APIレベル15)以下では true、APIレベルがJELLY_BEAN(APIレベル16)以上では false です。</p>,9
5,setAllowUniversalAccessFromFileURLs(),<p>  fileスキームURLのコンテキスト内で稼動しているJavaScriptが、任意のオリジンからのコンテンツへのアクセスを許可すべきかを設定しています。これは別のfileスキームURLからのコンテンツへのアクセスを含みます。最も制限がかかっていて安全なポリシーを有効にするには、この設定は無効にするべきです。 </p>  <p>     デフォルト値は、APIレベルがICE_CREAM_SANDWICH_MR1(API レベル 15)以下では true 、APIレベルがJELLY_BEAN (API レベル 16)以上では false です。</p>,9
6,WebViewクラスのセキュリティ懸念事項,<p>  アクティビティはWebページ表示のために埋め込まれたWebViewを所持していた場合、任意のアプリケーションは、Webページ表示のリクエストをするために指定のURIを持つインテントオブジェクトを作成して、アクティビティに送ることができます。</p> <p>WebViewはfile:スキームを含む様々なスキームを認識することができます。悪意のあるアプリケーションは細工されたコンテンツをローカルストレージエリアに作成して保管し、MODE_WORLD_READABLEパーミッションでアクセス可能にして、そしてこのコンテンツの URI (file: scheme を使用) をターゲットアクティビティに送る可能性があります。ターゲットアクティビティはこのコンテンツを表示します。</p> <p>ターゲットアクティビティ(WebViewオブジェクト)がJavaScriptを有効に設定すると、ターゲットアプリケーションのリソースにアクセスするために乱用される可能性があります。</p> <p>Android 4.1はfileスキームアクセスをコントロールするための追加メソッドを提供しています：</p> <ul>     <li>WebSettings#setAllowFileAccessFromFileURLs</li>     <li>WebSettings#setAllowUniversalAccessFromFileURLs</li> </ul>,9
7,実証例,"<p>  このコードはどのように脆弱性が利用されるかを示しています：</p> <pre> // Malicious application prepares some crafted HTML file, // places it on a local storage, makes accessible from // other applications. The following code sends an // intent to a target application (jp.vulnerable.android.app) // to make it access and process the malicious HTML file.  String pkg = ""jp.vulnerable.android.app""; String cls = pkg + "".DummyLauncherActivity""; String uri = ""file:///[crafted HTML file]""; Intent intent = new Intent(); intent.setClassName(pkg, cls); intent.putExtra(""url"", uri); this.startActivity(intent); </pre> ",9
8,パブリック,"<p>  AndroidManifest.xmlファイルのandroid:exported属性を指定することによって、コンテンツプロバイダは他のアプリに公開されます。APIレベルが16未満のAndroidアプリでは、明示的に android:exported=""false"" を指定されない限り、コンテンツプロバイダは公開されています。例えば、</p>  <pre> &lt;provider android:exported=&quot;true&quot; android:name=&quot;MyContentProvider&quot; android:authorities=&quot;com.example.mycontentprovider&quot; /&gt; </pre>  <p>     もしコンテンツプロバイダを公開するつもりなら、プロバイダに保存されたデータは他のアプリからアクセスされる可能性があります。そのため、非機密情報のみを扱うような仕様にしなければなりません。</p>",2
9,プライベート,"<p>  AndroidManifest.xmlファイルのandroid:exported属性を指定することによって、プロバイダを非公開にすることができます。 APIレベルが17以降では、この属性を明示的に指定しなければ、コンテンツプロバイダは非公開になっています。例えば、</p>  <pre> &lt;provider android:exported=&quot;false&quot; android:name=&quot;MyContentProvider&quot; android:authorities=&quot;com.example.mycontentprovider&quot; /&gt; </pre>  <p>     もし他のアプリとコンテンツプロバイダを共有する必要が無ければ、マニフェストファイルに android:exported=""false"" を宣言するべきです。しかし、APIレベルが8未満では、たとえ android:exported=""false"" を明示的に宣言しても、コンテンツプロバイダは他のアプリからアクセス可能であることに注意してください。</p> ",2
10,実証例：,"<p>  次のコードはこれがどのように利用されるかを示しています：</p>  <pre> // check whether movatwi is installed. try {     ApplicationInfo info = getPackageManager().getApplicationInfo(""jp.co.vulnerable"", 0);     [cjl5] } catch (NameNotFoundException e) {     Log.w(TAG, ""the app is not installed."");     return; } // extract account data through content provider Uri uri = Uri.parse(""content://jp.co.vulnerable.accountprovider""); Cursor cur = getContentResolver().query(uri, null, null, null, null); [cjl6] StringBuilder sb = new StringBuilder(); if (cur != null) {     int ri = 0;     while (cur.moveToNext()) {         ++ri;         Log.i(TAG, String.format(""row[%d]:"", ri));         sb.setLength(0);         for (int i = 0; i < cur.getColumnCount(); ++i) {             String column = cur.getColumnName(i);             String value = cur.getString(i);             if (value != null) {                 value = value.replaceAll(""[\r\n]"", """");             }             Log.i(TAG, String.format(""\t%s:\t%s"", column, value));         }     } } else {     Log.i(TAG, ""Can't get the app information.""); } </pre>",2
11,ログ出力,"<p>  android.util.Log classは、多くの可能性を許可しています：</p> <table> <tr>     <td class=""small"">Log.d (Debug)</td>     <td class=""small"">Log.e (Error)</td> </tr>  <tr>     <td class=""small"">Log.i (Info)</td>     <td class=""small"">Log.v (Verbose)</td>     <td class=""small"">Log.w (Warn)</td> </tr> </table>",17
12,例：,"<pre> Log.v(&quot;method&quot;, Login.TAG + &quot;, account=&quot; + str1); Log.v(&quot;method&quot;, Login.TAG + &quot;, password=&quot; + str2); </pre>",17
13,ログ出力の取得,"<p>  アプリがログ出力を読み込めるように、READ_LOGSのパーミッションをマニフェストファイル内で宣言してください：</p> <p>AndroidManifest.xml:</p> <pre>&lt;uses-permission android:name=&quot;android.permission.READ_LOGS&quot;/&gt;</pre> <p>アプリからlogcatを呼び出してください:</p> <pre>Process mProc = Runtime.getRuntime().exec(  new String[]{""logcat"", ""-d"", ""method:V *:S$Bc`W^(B)""});  BufferedReader mReader = new BufferedReader(      new InputStreamReader(proc.getInputStream())); </pre> <p>  Android 4.0未満では、READ_LOGSのパーミッションを持ついかなるアプリは全ての他のアプリのログ出力を取得できました。 Android 4.1以降、READ_LOGSパーミッションの仕様は変更されました。READ_LOGSのパーミッションを持つアプリさえ、他のアプリからログ出力を取得することはできません。</p> <p>しかし、AndroidデバイスをPCに繋げることによって、他のアプリからログ出力を取得することが可能になります。</p> <p>そのため、アプリが機密情報をログ出力に送信しないことが重要です。</p>",17
14,実証例,"<p>  脆弱性のあるアプリからログ出力を取得するコード例は、以下のようになります：</p> <pre> try {     Process mLogcatProc;      mLogcatProc = Runtime.getRuntime().exec(new String[]          {""logcat"", ""-d"", ""LoginAsyncTask:I APIClient:I method:V *:S"" });      BufferedReader reader = new BufferedReader(new InputStreamReader(          mLogcatProc.getInputStream()));      String line;      String separator = System.getProperty(""line.separator"");      while ((line = reader.readLine()) != null) {                  slog.append(line);                  slog.append(separator);     }          Toast.makeText(this, ""Obtained log information"",         Toast.LENGTH_SHORT).show();  }   catch (IOException e) {  // handle error  }  TextView tView = (TextView) findViewById(R.id.logView);  tView.setText(slog); </pre>",17
15,適用性,<p>   アプリは機密情報をログ出力に送信しないことを確実にするべきです。もしアプリがサードパーティのライブラリを含めていたら、開発者はライブラリが機密情報をログの出力に送信しないことを確実にするべきです。一つの一般的な解決法としては、ログ出力がデバッグ/リリースに基づき自動的にオン/オフになるように、アプリケーションがカスタムログクラスを宣言して使用する事です。開発者はProGuardを使用して、特定のメソッドの呼び出しを削除する事ができます。これはそのメソッドが副作用を含んでいないことを前提としています。</p>,17
16,一般的なベストプラクティス,"<ul> <li>ネットワーク層は安全ではなく、標的となって傍受される恐れがあることを当然のことと思ってください。</li> <li>機密情報、セッショントークン、または他の重要データをバックエンドAPIやWebサービスへ通信する予定のすべてのトランスポートチャネルにSSL/TLSの使用を義務付けてください。</li> <li>第三者の分析、ソーシャルネットワークなどの外部の存在を明確にして、アプリケーションがbrowser/webkit経由でルーチンを稼動させるときでさえも、これらのSSL バージョンを使用することを忘れないでください。混在SSLセッションは避けられるべきであり、ユーザのセッション ID を漏洩する可能性があります。</li> <li>強力で企業基準の暗号化アルゴリズムと適切なキーの長さを使用してください。</li> <li>信頼できるCAプロバイダによって署名された証明書を使用してください。</li> <li>決して自己署名証明書を許可しないでください。そしてセキュリティを意識したアプリケーションのために証明書のピン留めを検討してください。</li> <li>SSLチェーン検証を無効化や無視しないでください。</li> <li>キーチェーンの信頼された証明書でエンドポイントサーバの識別検証をして初めて、安全な接続を構築してください。</li> <li>もし不適切な証明書が検知されたら、UIを通じてユーザに警告してください。</li> <li>SMS, MMS, または通知のような代替チャネルで機密情報を送らないでください。</li> </ul> ",15
