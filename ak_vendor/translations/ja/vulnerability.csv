id,name,description,question,success_message,business_implication,heading,intro,compliant,non_compliant,related_to,uuid,platform,is_active,types
1,保護されていないサービス,サービスはインテントフィルタ、又は権限要求の無いデバイス上で他のアプリケーションと共有されていたことが判りました。そのため、そのデバイス上の他のどんなアプリケーションにもアクセス可能になっています。,アプリケーション内のサービスは保護されていますか?,サービスは保護されているようです。,<p>     データは他のサービスによって共有され、機密情報が失われる可能性があります。</p> ,強力なパーミッションでエクスポートされたサービスを保護してください。,"<p>     <span>Chin, et al., [<a href=""https://www.securecoding.cert.org/confluence/display/java/AA.+References#AA.References-Chin11"">Chin 2011</a>] says:</span>     <span class=""italics"">         &quot;もしサービスがエクスポートされ、強力なパーミッションで保護されていない場合、どのアプリケーションでもサービスを開始してバインドできます。特定のサービスの役割によっては、情報が漏洩したり、不正なタスクを行う可能性があります。サービスは時々Singletonアプリケーションの状態を維持していて、壊れている可能性があります。&quot;     </span> </p>  <p>     そのような事態を防ぐために、エクスポートされたサービスは常に強いパーミッションで保護されるべきです。</p>","<p>     アクティビティは常に<i>export=false</i>で保護してください。</p>  <pre style='color:#000000;background:#ffffff;'><span style='color:#808030; '>&lt;</span>activity exported<span style='color:#808030; '>=</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>false</span><span style='color:#800000; '>""</span> <span style='color:#808030; '>/</span><span style='color:#808030; '>></span> </pre> ",,,1c4b9d8d-1589-4bdd-b0da-ff99cef9c136,0,TRUE,{1}
2,不適切なコンテンツプロバイダパーミッション,コンテンツプロバイダパーミッションが、デバイス上の他のアプリケーションからのアクセスを許可するよう設定されました。コンテンツプロバイダはアプリケーションに関する機密情報を含む可能性があり、そのため共有されるべきではありません。,アプリケーション内のコンテンツプロバイダは保護されていますか?,アプリケーションはSSLを適切に実装しているか、あるいはHTTPSが実装されていないようです。,セキュリティコントロールが適切に実装されていないと、コンテンツプロバイダはSQLインジェクションのようなクライアントサイドアタックに繋がる可能性があります。これは従来のSQLインジェクション攻撃と同様に機能します。,"アプリケーションのセンシティブなコンテンツプロバイダのアクセシビリティを制限してください。<p>     ContentProviderクラスは、他のアプリケーションとのデータの管理および共有するためのメカニズムを提供します。プロバイダのデータを他のアプリと共有する場合、機密データへの不正アクセスを防ぐために、アクセス制御は入念に実施すべきです。</p>  <p>     コンテンツプロバイダへのアクセスを制限するには、次の3つの方法があります。: </p>  <ul>     <li>公開</li>     <li>非公開</li>     <li>制限付きアクセス</li> </ul> """,<p>     AndroidManifest.xmlファイルの次のエントリは、他のアプリケーションがデータにアクセスできないようにコンテンツプロバイダを非公開にします。: </p>  <pre> &lt;provider android:name=&quot;.content.AccountProvider&quot; android:exported=&quot; false&quot; android:authorities=&quot;jp.co.vulnerable.accountprovider&quot; /&gt; </pre>,<p>     TwitterクライアントアプリケーションであるMovatwiTouchは、コンテンツプロバイダーを使用して、Twitterのコンシューマー・キー、コンシューマー・シークレット、およびアクセストークンを管理していました。しかし、コンテンツプロバイダーが公開されると、ユーザのデバイスにインストールされたアプリケーションはこの機密情報にアクセスできるようになりました。</p>  <p>     AndroidManifest.xmlの次のエントリにはandroid：exported属性がありません。つまり、APIレベル16以前はコンテンツプロバイダが公開されていることを意味します。: </p>  <h4>     AndroidManifest.xml </h4>  <pre> &lt;provider android:name=&quot;.content.AccountProvider&quot; android:authorities=&quot;jp.co.vulnerable.accountprovider&quot; /&gt; </pre> ,"<ul>     <li>         <a href=""https://jvn.jp/en/jp/JVN90289505/"">JVN#90289505</a> Content provider in MovatwiTouch fails to restrict access permissions     </li> </ul> ",,a7648a1f-f584-4d1f-b16b-5d1a2fc7161c,0,TRUE,{1}
3,アプリケーションデバッグの有効化,リバースエンジニアがデバッガーをフックすることを容易にするアプリでデバッギングが有効化されました。これによってスタックトレースのダンプと、デバッギングヘルパークラスへのアクセスが可能になります。,アプリケーションでデバッグが有効になっていますか？,デバッギングは無効になりました。,アプリケーションは、機密データをデバッギングログに書き込むことができます。ログレベルをFINEに設定すると、ユーザーのデバイスとサーバー間で送信されるすべてのデータに対してログメッセージが書き込まれます。,デバッグ可能なアプリをリリースしないでください。,"<p>     Androidでは、アプリケーションをデバッグできるように、android:debuggable属性をtrueに設定することが許可されています。デフォルトでは、この属性は無効です。つまり、falseに設定されていますが、アプリケーションの開発中のデバッギングを支援するためにtrueに設定される可能性があります。ただし、安全に保つべきアプリの詳細情報にユーザがアクセスできるようにこの属性をtrueにした状態のアプリケーションは決してリリースしないでください。属性をtrueに設定すると、ユーザはソースコードにアクセスしなくてもアプリケーションをデバッグできます。</p>""","<p>     アプリケーションをリリースする前に、android:debuggable属性がfalseに設定されていることを確認してください。: </p>  <pre> android:debuggable=""false"" </pre>  <p>     いくつかの開発環境（Eclipse/ADTおよびAntを含む）は、インクリメンタルビルドまたはデバッギングビルドのために、android:debuggableを自動的にtrueにしますが、リリースビルドではfalseに設定されることに注意してください。</p>","<p>     この規格に準拠していないコード例は、android:debuggable属性がtrueに設定されていて機密データを漏らすためにアクセスされるアプリケーションを示しています。</p>  <pre> $ adb shell shell@android:/ $ run-as com.example.someapp sh shell@android:/data/data/com.example.someapp $ id uid=10060(app_60) gid=10060(app_60) shell@android:/data/data/com.example.someapp $ ls files/ secret_data.txt shell@android:/data/data/com.example.some $ cat files/secret_data.txt password=GoogolPlex account_number=31974286 </pre>  <p>     android:debuggable属性がtrueに設定されていると、アプリに関連する機密データはどのユーザにも明らかにされます。</p>,,34f28696-29bf-40a4-bc19-7c6bc08ff5c3,0,TRUE,{1}
4,不適切なカスタムパーミッション,カスタムパーミッションは影響を受けるアプリの機能に他のアプリケーションがアクセスできるかどうかをコントロールします。危険なラベルの使用は、アクセス許可を宣言しているアプリケーションへのアプリのアクセスを制限しませんが、ユーザはインストール中に危険なアクセス許可が要求されているという警告を受けます。,カスタムパーミッションに設定された保護レベルは安全ですか?,カスタムパーミッションは見つからないか、あるいは保護レベルが十分であるようです。,,応答する前に呼び出し元のアプリケーションに適切なパーミッションがあることを確認してください。,<p>     アプリケーションが呼び出し元のアプリケーションに応答するために付与されたパーミッションを使用している場合は、呼び出し元のアプリケーションもそのパーミッションとして同様にチェックしなければなりません。さもなければ、応答しているアプリケーションが、所持すべきではない呼び出し元のアプリケーションに特権を与えている可能性があります。(これは時々Confused Deputy Problem（混乱した使節の問題）と呼ばれています。) </p>  <p>     Context.checkCallingPermission()とContext.enforceCallingPermission()のメソッドは呼び出し元のアプリケーションに正しいパーミッションがあることを確認するのに使用することできます。</p>",<p><i>AndroidManifest.xml</i>に定義されているカスタムパーミッションセットから不要なカスタムパーミッションを削除してください。</p> ,5d825129-3302-44e5-bdd1-7fa575d4a64f,0,TRUE,{1}
5,Trust Manager for SSLの破損,欠如した証明書検査を実装しています。このTrust Managerは証明書検証を中断します。,Trust Manager for SSLは正しく実装されていませんか?,Trust Manager for SSLは完璧のように思えるか、もしくはアプリケーションにSSLが実装、および使用されていません。,ユーザ（匿名または検証済み）が特権を必要とする機能を実行できるという場合には、ビジネスには次のような問題が発生する可能性があります。:  <ul>     <li>風評被害</li>     <li>詐欺</li>     <li>情報盗難</li> </ul>,Trust Manager for SSL/TLSは正しく設定されていません。,"<p>安全な通信のためにSSL/TLSプロトコルを使用するAndroidアプリケーションは、サーバ証明書を正しく検証すべきです。基本的な検証には次のものが含まれます。: </p>  <ul>     <li>X.509証明書のsubject(CN)とURLが一致することを検証。</li>     <li>証明書が信頼できるCAによって署名されていることを検証。</li>     <li>署名が正しいことを検証。</li>     <li>証明書が期限切れでないことを検証。</li> </ul>  <p>     開発者は自由にSSL実装をカスタマイズすることができます。開発者は、アプリケーションのインテントとアプリケーションが使用されている環境に対して適切にSSLを使用する必要があります。SSLを正しく使用しないと、ユーザの機密データが脆弱なSSL通信チャネルを介して漏洩する可能性があります。</p>  <p>Fahl et al [<a href=""""https://www.securecoding.cert.org/confluence/display/java/AA.+References#AA.References-Fahl2012"""">Fahl 2012</a>] はSSLの安全ではない使用の次のパターンを説明しています。:</p>  <ul>     <li><b>すべての証明書を信頼する。</b>: 開発者はTrustManagerインターフェイスを実装して、すべてのサーバー証明書を信頼するようにします。(誰が署名したのかやCNが何かなどにかかわらず。)     </li>     <li><b>Mixed-Mode/No SSL</b>: 開発者は同じアプリケーション内の安全な接続と安全ではない接続を混ぜる、もしくは全くSSLを使用しません。</li> </ul>  <p>Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨されています。</p> ""","<p>     準拠していないコードを使用して問題を解決する方法を示した準拠ソリューションを以下に示します。: </p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkCertTrusted(X509Certificate[] chain, String authType, <span style=' color: Blue;'>boolean</span> isServer)     <span style=' color: Blue;'>throws</span> CertificateException {     <span style=' color: Blue;'>try</span> {         <span style=' color: Blue;'>if</span> (isServer)             appTrustManager.checkServerTrusted(chain, authType);         <span style=' color: Blue;'>else</span>             appTrustManager.checkClientTrusted(chain, authType);     } <span style=' color: Blue;'>catch</span> (CertificateException ae) {         <span style=' color: Green;'>// if the cert is stored in our appTrustManager, we ignore expiredness</span>         <span style=' color: Blue;'>if</span> (isExpiredException(ae)) {             Log.i(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""accepting expired certificate from keystore""</span>);             <span style=' color: Blue;'>return</span>;         }         <span style=' color: Blue;'>if</span> (isCertKnown(chain[<span style=' color: Maroon;'>0</span>])) {             Log.i(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""accepting cert already stored in keystore""</span>);             <span style=' color: Blue;'>return</span>;         }         <span style=' color: Blue;'>try</span> {             <span style=' color: Blue;'>if</span> (defaultTrustManager == <span style=' color: Blue;'>null</span>)                 <span style=' color: Blue;'>throw</span> ae;             Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""trying defaultTrustManager""</span>);             <span style=' color: Blue;'>if</span> (isServer)                 defaultTrustManager.checkServerTrusted(chain, authType);             <span style=' color: Blue;'>else</span>                 defaultTrustManager.checkClientTrusted(chain, authType);         } <span style=' color: Blue;'>catch</span> (CertificateException e) {             Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""defaultTrustManager failed: ""</span> + e);             interactCert(chain, authType, e);         }     } }  <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkTrustManager() <span style=' color: Blue;'>throws</span> IOException, KeyManagementException, NoSuchAlgorithmException {     TrustManager tm = <span style=' color: Blue;'>new</span> X509TrustManager() {          @Override         <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkClientTrusted(X509Certificate[] chain,                 String authType) <span style=' color: Blue;'>throws</span> CertificateException {             checkCertTrusted(chain, authType, <span style=' color: Maroon;'>false</span>);         }          @Override         <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkServerTrusted(X509Certificate[] chain,                 String authType) <span style=' color: Blue;'>throws</span> CertificateException {             checkCertTrusted(chain, authType, <span style=' color: Maroon;'>false</span>);         }          @Override         <span style=' color: Blue;'>public</span> X509Certificate[] getAcceptedIssuers() {             <span style=' color: Blue;'>return</span> defaultTrustManager.getAcceptedIssuers();         }     }; }</pre> <p>     checkCertTrusted()メソッドは、この問題の解決方法を示します。カスタムキーストアを使用して証明書をロードする場合、それらの証明書のフェールセーフロードを定義して実行する必要があります。 </p> ","<p>次のコードは、javax.net.ssl.SSLContextを継承するカスタムのMySSLSocketFactoryクラスを実装しています。:</p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> emptyTrustManager() <span style=' color: Blue;'>throws</span> IOException, KeyManagementException, NoSuchAlgorithmException {     TrustManager tm = <span style=' color: Blue;'>new</span> X509TrustManager() {          @Override         <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkClientTrusted(X509Certificate[] chain,                 String authType) <span style=' color: Blue;'>throws</span> CertificateException {             <span style=' color: Green;'>// Do nothing -&gt; accept any certificates</span>         }          @Override         <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> checkServerTrusted(X509Certificate[] chain,                 String authType) <span style=' color: Blue;'>throws</span> CertificateException {             <span style=' color: Green;'>// Do nothing -&gt; accept any certificates</span>         }          @Override         <span style=' color: Blue;'>public</span> X509Certificate[] getAcceptedIssuers() {             <span style=' color: Blue;'>return</span> <span style=' color: Blue;'>null</span>;         }     }; } </pre> <p> 上記の例では、SSLSocketFactoryがSSL証明書を検証しないように、checkClientTrusted()とcheckServerTrusted()は空の実装を作成するためにオーバーライドをしています。MySSLSocketFactoryクラスは、アプリケーションの別の部分にHttpClientのインスタンスを作成するために使用されます。</p> ","<ul>     <li><a href=""http://jvn.jp/en/jp/JVN39218538/"">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>     <li><a href=""http://jvn.jp/en/jp/JVN75084836/"">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>     <li><a href=""http://jvn.jp/en/jp/JVN68156832/"">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li> </ul>",7a19b880-6568-4468-86e5-74cb57d859da,0,TRUE,{1}
6,HostnameVerifier for SSLの破損,欠如したホスト名検査を実装しています。このHostnameVerifierは証明書検証を中断します！,HostnameVerifier for SSLは正しく実装されていませんか?,HostnameVerifier for SSLはホスト名を正しく検証しているように思えるか、もしくはSSLがアプリケーションに実装されていないようです。,ユーザ（匿名または検証済み）が特権を必要とする機能を実行できるという場合には、ビジネスには次のような問題が発生する可能性があります。:  <ul>      <li>風評被害</li>      <li>詐欺</li>      <li>情報盗難</li>  </ul>,HostnameVerifier for SSL/TLSは正しく設定されていません。,<p>すべてのホスト名を許可: アプリケーションは、クライアントが接続しているURLに対して証明書が発行されているかどうかは検証しません。例えば、クライアントがexample.comに接続すると、some-other-domain.comに対して発行されたサーバ証明書を受け入れます。</p> <p>Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨されています。</p>,"<p> このコード例では、カスタムで読み込まれた証明書もチェックするwrapHostnameVerifierを使用してホスト名を検証する方法を示しています。</p> <pre><span style=' color: Blue;'>public</span> HostnameVerifier wrapHostnameVerifier(<span style=' color: Blue;'>final</span> HostnameVerifier defaultVerifier) {     <span style=' color: Blue;'>if</span> (defaultVerifier == <span style=' color: Blue;'>null</span>)         <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> IllegalArgumentException(<span style=' color: Maroon;'>""The default verifier may not be null""</span>);      <span style=' color: Blue;'>return</span> <span style=' color: Blue;'>new</span> SecuringHostnameVerifier(defaultVerifier); }    <span style=' color: Blue;'>class</span> SecuringHostnameVerifier <span style=' color: Blue;'>implements</span> HostnameVerifier {     <span style=' color: Blue;'>private</span> HostnameVerifier defaultVerifier;      <span style=' color: Blue;'>public</span> MemorizingHostnameVerifier(HostnameVerifier wrapped) {         defaultVerifier = wrapped;     }      @Override     <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>boolean</span> verify(String hostname, SSLSession session) {         Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""hostname verifier for ""</span> + hostname + <span style=' color: Maroon;'>"", trying default verifier first""</span>);         <span style=' color: Green;'>// if the default verifier accepts the hostname, we are done</span>         <span style=' color: Blue;'>if</span> (defaultVerifier.verify(hostname, session)) {             Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""default verifier accepted ""</span> + hostname);             <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;         }         <span style=' color: Green;'>// otherwise, we check if the hostname is an alias for this cert in our keystore</span>         <span style=' color: Blue;'>try</span> {             X509Certificate cert = (X509Certificate)session.getPeerCertificates()[<span style=' color: Maroon;'>0</span>];             <span style=' color: Blue;'>if</span> (cert.equals(appKeyStore.getCertificate(hostname.toLowerCase(Locale.US)))) {                 Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""certificate for ""</span> + hostname + <span style=' color: Maroon;'>"" is in keystore. accepting.""</span>);                 <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;             } <span style=' color: Blue;'>else</span> {                 Log.d(<span style=' color: Maroon;'>""log""</span>, <span style=' color: Maroon;'>""server ""</span> + hostname + <span style=' color: Maroon;'>"" provided wrong certificate.""</span>);                 <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>false</span>;             }         } <span style=' color: Blue;'>catch</span> (Exception e) {             e.printStackTrace();             <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>false</span>;         }     } }</pre> ","<p>The following code inherits javax.net.ssl.SSLContext:</p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> HostnameVerifier() {     HostnameVerifier hv = <span style=' color: Blue;'>new</span> HostnameVerifier() {         @Override         <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>boolean</span> verify(String hostname, SSLSession session) {             <span style=' color: Green;'>// Always return true -&gt; Accespt any host names</span>             <span style=' color: Blue;'>return</span> <span style=' color: Maroon;'>true</span>;         }     }; }</pre> <p>HostnameVerifierは、内容を確認したり、ホスト名を検証することなく、常にtrueを返します。</p> ","<ul>     <li><a href=""http://jvn.jp/en/jp/JVN39218538/"">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>     <li><a href=""http://jvn.jp/en/jp/JVN75084836/"">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>     <li><a href=""http://jvn.jp/en/jp/JVN68156832/"">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li> </ul>",69a6c622-2d16-411c-b4ab-1fa45e031e57,0,TRUE,{1}
7,安全でないSSLSocketFactoryの実装,SSL実装はこのアプリケーションにおいて適切ではありません。,このアプリケーションは実装中にSSLエラーが発生する可能性がありますか？,SSLエラーは見つかりませんでした。,<p> SSLの適切な実装を使用しない場合、脆弱なSSL通信チャネルから機密データが漏洩する可能性があります。</p>  ,SSLSocketFactoryは適切に実装されていません。,"<p>    Android SDK 4.0以降には、ネットワーク接続を確立するための機能を実装するためのパッケージが用意されています。例えば、java.net, javax.net, android.net org.apache.httpを使用することで、開発者はサーバーソケットまたはHTTP接続を作成できます。org.webkitは、Webブラウジング機能を実装するために必要な機能を提供します。</p>  <p>     開発者は自由にSSL実装をカスタマイズすることができます。開発者は、アプリケーションのインテントとアプリケーションが使用されている環境に対して適切にSSLを使用する必要があります。</p>  <p>Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨されています。</p> ","<p>     準拠したソリューションは、実際の実装に応じて変わる場合があります。自己署名サーバ証明書を使用するなどの安全な実装の例については、""""<a href=""""http://www.jssec.org/dl/android_securecoding.pdf"""">Android Application Secure Design/Secure Coding Guidebook</a>""""のセクション5.4 HTTPSで通信するを参照してください。</p>","<p>次のコードは、javax.net.ssl.SSLContextを継承するカスタムのMySSLSocketFactoryクラスを実装しています。:</p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>class</span> InsecureSocketFactory <span style=' color: Blue;'>extends</span> SSLSocketFactory {     <span style=' color: Blue;'>protected</span> SSLSocketFactory _factory;     <span style=' color: Blue;'>public</span> InsecureSocketFactory() {         <span style=' color: Blue;'>try</span> {             SSLContext ctx = SSLContext.getInstance(<span style=' color: Maroon;'>""SSL""</span>);             ctx.init(<span style=' color: Blue;'>null</span>, <span style=' color: Blue;'>new</span> TrustManager[] { <span style=' color: Blue;'>new</span> InsecureTrustManager() }, <span style=' color: Blue;'>null</span>);             _factory = ctx.getSocketFactory();         } <span style=' color: Blue;'>catch</span> (Exception e) {             <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> RuntimeException(e);         }     } } </pre> <p>     上記の例では、InsecureSocketFactoryはすべての証明書を黙って受け取ります。これは、trustmanagersのチェックをバイパスします。</p> ","<ul>     <li><a href=""http://jvn.jp/en/jp/JVN39218538/"">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>     <li><a href=""http://jvn.jp/en/jp/JVN75084836/"">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>     <li><a href=""http://jvn.jp/en/jp/JVN68156832/"">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li> </ul>",ecc3fb11-b984-4deb-9f1e-df794f14fc25,0,TRUE,{1}
8,Hostname Verifierがすべてのホスト名を許可,ハッカーに接続の盗聴を許す恐れがあるAllowAllHostname Verifierを実装しています。,このアプリケーションはAllowAllHostname Verificationがありますか?,AllowAllHostname verifierが無効になっているようです。,ユーザ（匿名または検証済み）が特権を必要とする機能を実行できるという場合には、ビジネスには次のような問題が発生する可能性があります。: <ul>     <li>風評被害</li>     <li>詐欺</li>     <li>情報盗難</li> </ul>,SSL/TLS上のサーバ証明書を正しく検証してください。,<p>安全な通信のためにSSL/TLSプロトコルを使用するAndroidアプリは、X.509証明書のsubject(CN)とURLが一致することを確認するサーバ証明書を正しく検証する必要があります。</p>  <p><b>すべてのホスト名を許可</b>: アプリケーションは、発行された証明書がクライアントが接続しているURL用であるかどうかを検証しません。例えば、クライアントがexample.comに接続すると、some-other-domain.comに対して発行されたサーバ証明書を受け入れます。</p>  <p>Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨されています。</p>,"<p>     プロダクションコードでは、<b>SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER</b>を絶対に使用しないでください。 <p>     """"<a href=""""http://www.jssec.org/dl/android_securecoding.pdf"""">Android Application Secure Design/Secure Coding Guidebook</a>""""のセクション5.4 HTTPSで通信するを参照してください。</p>",<p>次のコードは、javax.net.ssl.SSLContextを継承するHttpClientクラスを拡張しています。:</p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> allowAllHostnameVerifier() {     SSLSocketFactory sf = <span style=' color: Blue;'>null</span>;      sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER); }</pre> <p>     これは<b>SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER</b>を使用可能にし、その結果としてSSL接続の確立時に行われるホスト名の検証が無効になり、すべての証明書が信頼されるのと同じ状況になります。</p> ,"<ul>     <li><a href=""http://jvn.jp/en/jp/JVN39218538/"">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>     <li><a href=""http://jvn.jp/en/jp/JVN75084836/"">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>     <li><a href=""http://jvn.jp/en/jp/JVN68156832/"">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li> </ul>",5e2d2321-30af-448b-8276-d52ec4aba58e,0,TRUE,{1}
9,アプリケーションがWebViewClientを拡張,WebViewClientのデフォルトの処理は、証明書検証を中断する可能性があるonreceivedsslerrorを適切に処理するべきです。,このアプリケーションは、onreceivedsslerrorメソッドを正しく処理するWebViewClientを使用していますか?,アプリケーションはWebViewClientを正しく処理しているように思えるか、もしくはアプリケーションにWebViewClientの実装がないようです。,<p> SSLの適切な実装を使用しない場合、脆弱なSSL通信チャネルから機密データが漏洩する可能性があります。</p>  ,Webview Clientは保護された接続を正しく処理しません。,<p>WebViewsはセキュリティ上の懸念事項を多数もたらすことができ、慎重に実装する必要があります。特に、多くの脆弱性がaddJavscriptInterface APIの使用とonReceivedSslErrorチェックのバイパスを利用しているのが発見されています。</p> <p> WebViewはSSL/TLSをサポートしていますが、空白の画面はWebViewが証明書が有効であるとは信じていないことを示しています。これは自己署名証明書やアンドロイドに設定されていないルート認証からの証明書で発生する可能性があります。ただし、そのチェックをバイパスすると、SSLからすべてのセキュリティーが削除されます。</p> ,"<p>     これは、onReceivedSslErrorを使用してユーザとアプリケーションを停止または通知することで修正できます。</p> <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> onReceivedSslError(WebView view, SslErrorHandler handler, SslError error)  {     <span style=' color: Green;'>//STOP OR ALERT THE USER</span> }</pre> ","<p>次のコードは、WebViewClientのチェックをバイパスするために、どのようにonReceivedSslErrorが使用されたかを示しています。:</p>  <pre><span style=' color: Blue;'>public</span> <span style=' color: Blue;'>class</span> SSLAcceptingWebViewClient <span style=' color: Blue;'>extends</span> CordovaWebViewClient {     <span style=' color: Blue;'>public</span> SSLAcceptingWebViewClient(DroidGap ctx) {         <span style=' color: Blue;'>super</span>(ctx);     }     @Override     <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) {         <span style=' color: Green;'>//proceed or pass</span>         handler.proceed(); <span style=' color: Green;'>// Ignore SSL certificate errors</span>     }  } </pre> ","<ul>     <li><a href=""http://jvn.jp/en/jp/JVN39218538/"">JVN#39218538</a> Pizza Hut Japan Official Order App for Android has a problem whereby it fails to verify SSL server certificates.</li>     <li><a href=""http://jvn.jp/en/jp/JVN75084836/"">JVN#75084836</a> Yome Collection for Android has a problem with management of IMEI.</li>     <li><a href=""http://jvn.jp/en/jp/JVN68156832/"">JVN#68156832</a> Yafuoku! contains an issue where it fails to verify SSL server certificates</li> </ul>",b31fd9b9-c2a3-49cc-a4f9-189ac8e2936d,0,TRUE,{1}
10,未使用のパーミッション,アプリケーションは実際には必要ない余分なパーミッションを使用しているようです。,あなたのアプリケーションは特権を持つパーミッションを持っていますか？,アプリケーションは要求されたパーミッションの正確なセットを持っているようです。,<p>     ユーザは、パーミッションの長いリストが表示されている場合は、あなたのアプリケーションをダウンロードしないことがあります。SDカード、カメラ、連絡先、SMSなどへのアクセスを要求する懐中電灯アプリを想像してみてください。これは、App Storeの乏しい評価やレビューへの招待状です。これはコンプライアンス基準も破ります。</p>,使用しないかもしれないパーミッションは要求しないでください。,<p>     スキャンが実行されている間に実際に呼び出されていないSDカード、連絡先、ソーシャルプロファイルなどへのアクセスのような特定のパーミッションをアプリケーションはユーザに要求することがあります。あなたがアプリを最適化し、適切なコンプライアンスチェックを行うことができるために、全てのパーミッションをリストアウトします。</p>,<p>     あなたのアプリが実際に必要とするもの以外のパーミッションを要求しないでください。 </p> ,,,77139968-ade0-40ef-9702-0ac91dc1e48d,0,TRUE,{1}
11,JavascriptInterfaceを通じたリモートコード実行,アプリケーションはJavascriptInterfaceを使用しているようです。これを使用して攻撃者はあなたのアプリケーションに対してリモートでコードの実行を行い、機密情報を盗むことができます。,あなたのアプリケーションはJavascriptInterfaceを使用していますか?このアプリケーションはnon-SSL経由かSSL実装が壊れていませんか?,アプリケーションはJavascriptInterfaceを介したリモートコード実行からは安全です。,<p> このアプリケーションはユーザ提供のコンテンツやHTTPのコンテンツからのJavaScriptスクリプト攻撃の影響を受けやすく、機密情報の損失を招く可能性があります。,信頼できないコンテンツを含むWebViewでaddJavascriptInterfaceメソッドのアクセスを提供しないでください。(APIレベルJELLY_BEAN以下),"<p>     APIレベルJELLY_BEAN以下にとっては、アプリケーションにWebView内の信頼できないコンテンツでaddJavascriptInterfaceを使用することを許可することは、Javaからパブリックメソッドにアクセスするためのリフレクションを使用したスクリプト攻撃に対する脆弱性をアプリケーションに残します。信頼されていないコンテンツの例には、HTTP URL(HTTPSと対するもの)とユーザ提供のコンテンツが含まれます。メソッドaddJavascriptInterface(Object, String)は、android.webkit.WebViewクラスから呼び出されます。機密データとアプリケーションコントロールは、スクリプト攻撃にさらされてはいけません。</p>",<ol> <li>      <p>         準拠しているコードでは、addJavascriptInterface()メソッドの呼び出しを控えることができます。     </p>      <pre> WebView webView = new WebView(this); setContentView(webView);     </pre> </li> <li>      <p>         もう1つの準拠した解決策は、アプリケーションがAPIレベルJELLY_BEAN_MR1以上のみ用であることをアプリケーションのマニフェストに指定することです。これらのAPIレベルに対しては、JavascriptInterfaceでアノテーションされたパブリックメソッドのみがJavaScriptからアクセスできます。APIレベル17はJELLY_BEAN_MR1です。     </p>      <pre> &lt;manifest&gt; &lt;uses-sdk android:minSdkVersion=&quot;17&quot; /&gt; ...   &lt;/manifest&gt;     </pre> </li> </ol>,"<p>     この非準拠のコード例は、addJavascriptInterface()メソッドを呼び出すアプリケーションを示していて、APIレベルJELLY_BEAN以下では安全ではありません。 </p>  <pre>WebView webView = <span style=' color: Blue;'>new</span> WebView(<span style=' color: Blue;'>this</span>); setContentView(webView);... <span style=' color: Blue;'>class</span> JsObject { <span style=' color: Blue;'>private</span> String sensitiveInformation;  ... <span style=' color: Blue;'>public</span> String toString() {     <span style=' color: Blue;'>return</span> sensitiveInformation; }  } webView.addJavascriptInterface(<span style=' color: Blue;'>new</span> JsObject(), <span style=' color: Maroon;'>""injectedObject""</span>); webView.loadData(<span style=' color: Maroon;'>""""</span>, <span style=' color: Maroon;'>""text/html""</span>, <span style=' color: Blue;'>null</span>); webView.loadUrl(<span style=' color: Maroon;'>""http://www.example.com""</span>); </pre>  <p>     JavaScriptは今はホストを制御できます。Javaリフレクションは、アプリケーションのパーミッションを使用して、注入されたオブジェクトのパブリックメソッドにアクセスするために使用できます。</p> ",,db0ed525-7cf5-4b01-8cf4-9d7278de27a2,0,TRUE,{1}
12,保護されていないアクティビティ,アクティビティはインテントフィルタまたパーミッション要求なしでデバイス上の他のアプリケーションと共有されているため、デバイス上の他のアプリケーションからアクセス可能な状態になっています。,アプリケーションのアクティビティは保護されていますか？,アクティビティは保護されているようです。,<p> 許可されていないアプリケーションは、悪意のあるアクションを実行するために脆弱なアクティビティを使用することがあります。</p> ,機密性の高いアクティビティへのアクセスを制限してください。,<p>     Androidでは、AndroidManifest.xmlファイル内のアクティビティのインテントフィルタを宣言することは、アクティビティが他のアプリケーションにエクスポートされる可能性があることを意味します。もしアクティビティが単にアプリケーションの内部使用のみを意図していて、インテントフィルタが宣言されていたら、マルウェアを含む他のアプリケーションは、意図しない使用のためにアクティビティをアクティベートすることができます。</p>  <p>     Twiccaアプリ（バージョン0.7.0から0.9.30まで）の脆弱性の場合、Twiccaのアクティビティを起動すると、SDカードやネットワークにアクセスするパーミッションを持たない別のアプリは、TwiccaユーザのTwitterアカウントを使用して、SDカードに保存されている画像や動画をソーシャルネットワーキングサービスにアップロードできました。</p> ,"<ol> <li>      <p>         この準拠ソリューションでは、アクティビティはエクスポートされません。:     </p>      <pre> &lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/ VulnerableTheme.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot; android:exported=&quot;false&quot;&gt;  &lt;/activity&gt;     </pre>      <p>         AndroidManifest.xmlファイル内のactivityタグに対してandroid:exported=""false""を宣言することにより、アクティビティは同じアプリケーション内、または同じユーザIDのアプリケーションからのインテントのみを受け入れるように制限されます。     </p> </li> <li>      <p>         この脆弱性はTwicca v0.9.31で修正されました。Twiccaは、AndroidManifest.xmlのアクティビティにexported=""false""を宣言する代わりに、このアクティビティの呼び出し元を検証することによってこの脆弱性を修正しました。ActivityクラスのonCreate()メソッドには、呼び出し元のパッケージ名がそれ自身のパッケージ名と同じであるかどうかをチェックするコードが追加されました。パッケージ名が異なる場合、アクティビティは終了します。:     </p>      <pre> public void onCreate(Bundle arg5) {     super.onCreate(arg5);...     ComponentName v0 = this.getCallingActivity();     if (v0 == null) {         this.finish();     } else if (!jp.r246.twicca.equals(v0.getPackageName())) {         this.finish();     } else {         this.a = this.getIntent().getData();         if (this.a == null) {             this.finish();         }...     } }     </pre>      <p>         Android開発者は、任意にパッケージ名を選択できるため、異なるアプリケーション開発者は同じパッケージ名を選択できました。したがって、通常はアクティビティの呼び出し元を検証するためにパッケージ名を使用することは推奨されません。推奨されている代案は、パッケージ名の代わりに開発者の証明書を確認することです。     </p>      <p>         しかし、以下の事実を考慮すると、Twiccaのソリューションは、論理的でエクスプロイトに対して安全である可能性があります。:     </p>      <ul>         <li>特定のパッケージ名を持つ1つのアプリのみがGoogle Playに存在することができます。   </li>         <li>もしユーザがパッケージ名が既にデバイス上に存在するアプリケーションをインストールしようとすると、インストールが失敗するか、以前にインストールされたアプリケーションを上書きします。</li>     </ul> </li> </ol> ","<p>     この非準拠のコード例は、アクティビティを他のアプリケーションにエクスポートするアプリケーションのAndroidManifest.xmlファイルを示していますが、機密性の高いアクティビティへのアクセスを制限しません。: </p>  <pre> &lt;activity android:configChanges=&quot;keyboard|keyboardHidden|orientation&quot; android:name=&quot;.media.yfrog.YfrogUploadDialog&quot; android:theme=&quot;@style/Vulnerable.Dialog&quot; android:windowSoftInputMode=&quot;stateAlwaysHidden&quot;&gt;            &lt;intent-filter android:icon=&quot;@drawable/yfrog_icon&quot; android:label=&quot;@string/YFROG&quot;&gt;     &lt;action android:name=&quot;jp.co.vulnerable.ACTION_UPLOAD&quot; /&gt;                     &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;                     &lt;data android:mimeType=&quot;image/*&quot; /&gt;                     &lt;data android:mimeType=&quot;video/*&quot; /&gt;             &lt;/intent-filter&gt;         &lt;/activity&gt; </pre>  <p>     android:nameは、このアクティビティを実装するクラスの名前を参照します。パッケージの名前は""jp.co.vulnerable""なので、このアクティビティを実装するクラスの完全修飾名はjp.co.vulnerable.media.yfrog.YfrogUploadDialogです。インテントフィルタが定義されているため、このアクティビティは他のアプリにエクスポートされます。</p>","<ul>     <li><a href=""https://jvn.jp/en/jp/JVN31860555/"">JVN#31860555</a>  Twicca fails to restrict access permissions  </li> </ul>",f3a3056f-54e9-43ac-be6c-3942f7982232,0,TRUE,{1}
13,SQLインジェクション,"モバイルアプリケーションのサーバーから取得したデータに不正なデータが含まれていると、モバイルデバイスのローカルデータベース内でSQLインジェクションが発生する可能性があります。ローカルのSQLインジェクションは、ローカルのマルウェア注入、情報盗難などを招く可能性があります。,WEB APIを介したSQLインジェクションに脆弱ですか？,アプリケーションはWeb APIを介したSQLインジェクションに対して脆弱ではありません。,<p>     SQLインジェクションにより、侵入者はデータベースに含まれるデータの表示、および変更ができます。攻撃者はデータベース上で時間の経過とともにより高い特権を得ることができるので、格納されたデータの機密性と完全性を損なう可能性があります。</p> ,SQLインジェクションを防止してください。,<p>     SQLインジェクションの脆弱性は、全く異なるクエリを生成するためにオリジナルのSQLクエリを変更できる場合に発生します。この変更されたクエリを実行すると、情報漏えいやデータ変更につながる可能性があります。SQLインジェクションを防止する主な手段は、ユーザー入力の検証とサニタイジング、およびクエリのパラメータ化です。</p>,""<p>     入力検証は、正しいクエリ構築の前提条件です。この準拠ソリューションは、ユーザ名とパスワードの引数の長さを検証します。また、java.sql.Statementの代わりにjava.sql.PreparedStatementも使用します。</p>  <pre> class Login {     public void doPrivilegedAction(String username, String password) throws SQLException {          // Ensure that the length of username and password is legitimate          if ((username.length() >= 8) || (password.length() >= 20)) {             // Handle error         }          DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver.SQLServerDriver());         Connection connection = DriverManager.getConnection(             ""jdbc:microsoft:sqlserver://<HOST>:1433"", ""<UID>"", ""<PWD>"");         if (connection != null) {             String sql = ""select * from db_user where username=? and password=?"";              // Use PreparedStatement for type enforcement             PreparedStatement stmt = connection.prepareStatement(sql);             stmt.setString(1, username);             stmt.setString(2, password);             ResultSet rs = stmt.executeQuery();              if (!rs.next()) {                 throw new SecurityException(""User name or Password incorrect"");             }             // Authenticated; proceed         }     } } </pre> ", ,,"<p>     この非準拠コードの例は、SQLインジェクションに対して脆弱なJDBCコードを示しています。SQLステートメントのSQLは、サニタイズしてない入力引数を受け入れます。 </p>  <pre><span style=' color: Blue;'>class</span> Login {  <span style=' color: Blue;'>public</span> <span style=' color: Blue;'>void</span> doPrivilegedAction(String username, String password) <span style=' color: Blue;'>throws</span> SQLException {      DriverManager.registerDriver(<span style=' color: Blue;'>new</span> com.microsoft.jdbc.sqlserver.SQLServerDriver());     Connection connection = DriverManager.getConnection(         <span style=' color: Maroon;'>""jdbc:microsoft:sqlserver://&lt;HOST&gt;:1433""</span>, <span style=' color: Maroon;'>""&lt;UID&gt;""</span>, <span style=' color: Maroon;'>""&lt;PWD&gt;""</span>);      <span style=' color: Blue;'>if</span> (connection != <span style=' color: Blue;'>null</span>) {         String sql = <span style=' color: Maroon;'>""select * from db_user where username = '""</span> + username +             <span style=' color: Maroon;'>""' and password = '""</span> + password + <span style=' color: Maroon;'>""'""</span>;          Statement stmt = connection.createStatement();         ResultSet rs = stmt.executeQuery(sql);         <span style=' color: Blue;'>if</span> (!rs.next()) {             <span style=' color: Blue;'>throw</span> <span style=' color: Blue;'>new</span> SecurityException(<span style=' color: Maroon;'>""User name or Password incorrect""</span>);         }         <span style=' color: Green;'>// Authenticated; proceed</span>     } }  </pre>  <p>     もし攻撃者がセキュアコーディングしている有効なユーザ名を入力し、パスワード引数にセキュアコーディングしている'OR username = 'を入力すると、SQLステートメントは、select * from db_user where username = '' OR username = 'securecoding' and password=''を評価し、その結果、ログインパスワードチェックをバイパスします。 同様に、あるユーザ OR '1' = '1'の入力は、ユーザ名とパスワードの両方のチェックをバイパスし、攻撃者に無制限アクセスを許可します。</p>",,,,,,b45ed0a6-c902-46b0-90b8-f131e8588ae8,0,TRUE,"{1,2}"
14,SharedPreference内の情報,SharedPreference内に安全でない情報が見つかりました。SharedPreferenceでは暗号化されていない情報を使用するべきではありません。,機密情報がSharedPreferenceを通じて漏洩していますか？,SharedPreference内にデータの漏洩は見つかりませんでした。,通常、悪意のあるコードは機密情報(パスワード、セッションCookie、個人を特定できる情報など)を盗みます。したがって、関連するビジネスへの影響は次を含みます。: <ul>     <li>詐欺</li>     <li>プライバシー侵害</li> </ul>,機密データが安全に保たれていることを確認してください。,"<p>     Androidアプリでは、データはインテントを経由して通信することができたり、データをファイルに書き込むことができたり、SharedPreferenceを使用して配信したり、データベースに保存したりすることができます。これらのすべてのケースで、データが機密性が高い場合、データを安全に保つことが重要です。つまり、データ所有者が意図していない場合は、他のアプリケーション(もしくは、より厳密には、異なるユーザーIDを持つアプリケーション)がこのデータにアクセスできたり、他のプログラムやユーザがデータにアクセスできるようにすべきではありません。</p>  <p>     データセキュリティ(非インテント通信チャネル用)は、ファイルやSharedPreference、内部ストレージ上のMODE_PRIVATEのデータベース、外部ストレージ上のMODE_PRIVATEで暗号化(安全な暗号化手法を使用し、セキュアパーティー/アプリのみが持つ暗号化キーを使用)されたデータベースを作成することで、サポートすることができます。MODE_PRIVATEは、android.content.Contextクラスによって定義される定数です。それはopenFileOutput(), getSharedPreferences(), andopenOrCreateDatabase()のメソッドのモードパラメータとして使用される可能性があります。(これらはすべてandroid.content.Contextクラスでも定義されています。) </p>  <p>     静的テイントフロー解析は、一連のアプリケーションに対して、各ソース(静的解析によって完全には予測できないデータの入力、例えばユーザによるテキスト入力)から到達可能なシンク(他のアプリケーションやメソッドがアクセスできる場所へのデータ出力、例えばBluetooth接続を介したデータ送信)までのデータをトレースするために行うことができます。テイントフロー分析は、インテントや静的フィールドを含んだフローを含め、多くの可能性のあるシンクソースフローをユーザが理解するのに役立ちます。</p>","<p>     この準拠ソリューションでは、ファイルはMODE_PRIVATEを使用して作成されるため、ファイルを作成したアプリによってのみアクセスできます。</p>  <pre> openFileOutput(""someFile"", MODE_PRIVATE); </pre> ","<p>この非準拠コードの例は、world-readableで安全ではないファイルを作成するアプリケーションを示しています。</p>  <pre>openFileOutput(<span style=' color: Maroon;'>""someFile""</span>, MODE_WORLD_READABLE);</pre>  <p>どのアプリケーションもファイルを読み込め、そこに格納されているデータにアクセスできます。</p> ",,37f2d354-b5d3-4d09-8718-4c09fdbf4d27,0,TRUE,{2}
15,トランスポート層の不十分な保護,不十分なトランスポート層の保護に関する問題は、モバイルアプリケーションからサーバに安全ではないチャネルを介してデータが送信されたときに発生します。データが送信されるのがキャリアネットワークを介してであろうと、WiFiを介してであろうと、どちらにしてもリモートサーバに到達する前は結局インターネット経由になるでしょう。ネットワークを介して送信される保護されていないデータをスニッフィングできる方法はいくつかあります。ルータ、プロキシ、携帯電話の基地局のようなものは、データが送信中に盗聴される可能性あるいくつかの方法の一部です。,アプリケーションは適切なトランスポート層の保護を使用していますか？アプリケーションでHTTPSは有効になっていますか？,アプリケーションでSSLが有効になっているようで、情報漏洩を防止するために十分な保護が使用されています。,ユーザの機密性を侵害すると、次のような結果になることがあります。: <ul>     <li>個人情報の盗難</li>     <li>詐欺</li>     <li>風評被害</li> </ul> ,不十分なトランスポート層の保護,<p>     不十分なトランスポート層の保護の問題は、モバイルアプリケーションからサーバに保護されてないチャネルを介してデータが送信されたときに発生します。データが送信されるのがキャリアネットワークを介してであろうと、WiFiを介してであろうと、どちらにしてもリモートサーバに到達する前は結局インターネット経由になるでしょう。ネットワークを介して送信される保護されていないデータをスニッフィングできる方法はいくつかあります。ルータ、プロキシ、携帯電話の基地局のようなものは、データが送信中に盗聴される可能性あるいくつかの方法の一部です。</p>,<p>     絶対にHTTP URLを使用してデータをダウンロードしないでください。代わりに、機密データのみをダウンロードできる有効なHTTPSリクエストを作成してください。</p>,"<p> インターネットに接続するためにSSLまたはTLS付きのHTTPを使用してください。さもなければ、適切な証明書なしだと、ユーザの認識なしに攻撃者が簡単に接続を盗聴できます。</p>  <pre>String link = <span style=' color: Maroon;'>""http://www.google.com""</span>; URL url = <span style=' color: Blue;'>new</span> URL(link);  HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.connect();  InputStream is = conn.getInputStream(); BufferedReader reader =<span style=' color: Blue;'>new</span> BufferedReader(<span style=' color: Blue;'>new</span> InputStreamReader(is, <span style=' color: Maroon;'>""UTF-8""</span>)); String webPage = <span style=' color: Maroon;'>""""</span>,data=<span style=' color: Maroon;'>""""</span>; while ((data = reader.readLine()) != <span style=' color: Blue;'>null</span>){    webPage += data + <span style=' color: Maroon;'>""\n""</span>; }</pre>  <p>攻撃者はMITM攻撃を行うことができ、ユーザは誰が接続を盗聴していることさえ知らないでしょう。</p> ",,8869f2fe-3944-49a7-aa06-c8010a009a53,0,TRUE,"{1,2}"
16,派生した暗号鍵,異なるライブラリをロードする際に使用される中間鍵である可能性のある暗号鍵の形跡。,あなたのアプリケーションは安全でないAES暗号化方式を使用していますか?,アプリケーションは正しい暗号化方式を使用しているように思えるか、もしくはまったく使用していないようですが、壊れた暗号方式の結果は次のようになります。: <ul>     <li>プライバシー侵害</li>     <li>情報盗難</li>     <li>コード盗難</li>     <li>知的財産の盗難</li>     <li>風評被害</li> </ul> ,デフォルトのAndroid暗号化セキュリティプロバイダの暗号化を使用せず、推奨される方法に従ってください。,<p>     主なAndroid暗号化セキュリティプロバイダAPIは、デフォルトでは安全でないAES暗号化方式のAES暗号化用のECBブロック暗号モードを使用しています。Androidのデフォルトの暗号化セキュリティプロバイダ（バージョン2.1以降）はBouncyCastleです。  </p>  <p>     注記: Javaでは、AES暗号化方式のみが選択された場合は、ECBをデフォルトとして選択しました。したがって、このルールはJavaにも適用されますが、Javaの異なるデフォルトの暗号化セキュリティー・プロバイダーにも適用されます。Oracle Javaのデフォルトの暗号化セキュリティプロバイダはSunJCEです。 </p>  <p>     Androidシステムで使用される暗号ライブラリのデフォルトの動作は、しばしば推奨される方法を使用しません。例えば、主なAndroid JavaセキュリティプロバイダAPIは、デフォルトでは安全でないAES暗号化方式のAES暗号化用のECBブロック暗号モードを使用しています。[Egele 2013]による幅広いアプリケーションのテストは、以下の6つのルールに従わないことが多く、Google Play上の暗号APIを使用しているアプリのうち88％が少なくとも1つの間違いを犯す結果になっていることを示しました。  </p>  <p>     彼らがテストした6つの一般的な暗号化ルール: </p>  <ol>     <li>暗号化にECBモードを使用しないでください。</li>     <li>CBC暗号化に非ランダムIVを使用しないでください。</li>     <li>一定の暗号化キーを使用しないでください。</li>     <li>PBEには一定のソルトを使用しないでください。</li>     <li>PBEには1,000回未満のイテレーションを使用しないでください。</li>     <li>SecureRandom(ﾂｷ)をシードするのに、静的なシードを使用しないでください。</li> </ol>,"<p>     暗号化を使用する際に従うべきルールは次のとおりです。 </p> <ul>     <li>         AES暗号化を使用する場合は、必ずECB(Electronic Codebook)とペアリングしてください。     </li>     <li>         AES/CBCにデフォルト設定されているため、単に""AES""を暗号化として使用しないでください。    </li>     <li>         必ず暗号化に加えてパディングを使用してください。例えば、""RSA/ECB""は安全ではないですが、""RSA/ECB/PKCS7""はより良いです。     </li>     <li>         DES(Data Encryption Standard)のような古いアルゴリズムを絶対に使用しないでください。     </li> </ul> ",,,d8091a54-6aa0-4a23-bc40-e97e515d73dd,0,TRUE,"{1,2}"
17,アプリケーションログ,現在のアプリケーションがシステムログにログを書き込んでいることが判明しました。,このアプリケーションは、アプリケーションログを通じてデータを提供していますか？,アプリケーションログは見つかりませんでした。,<p>機密データがうっかりログにリークされ、更なる攻撃を助長する可能性があります。</p> ,機密情報をログに記録しないでください。,<p>     Androidは、ロギング情報の出力とログ出力の取得のアプリケーションの機能を提供します。アプリケーションは、android.util.Logクラスを使用してログ出力に情報を送信できます。ログ出力を取得するには、アプリケーションでlogcatコマンドを実行します。</p>,<p>本番環境ではログを絶対に使用しないでください。</p> <p>すべてを見つけます。</p> <pre style='color:#000000;background:#ffffff;'>Log.d() </pre>  and comment/remove them  <pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>//Log.d()</span></pre> </p> <p>デバッグをできるようにするために、例外パーサを使用し、クラッシュベースの分析ツールで本番環境でのクラッシュをキャプチャします。</p> ,"<ol> <li>  <p>Android用のFacebook SDKには、Facebookのアクセストークンをプレーンテキスト形式でログ出力に送信する次のコードが含まれていました。</p>  <pre>Log.d(<span style=' color: Maroon;'>""Facebook-authorize""</span>, <span style=' color: Maroon;'>""Login Success! access_token=""</span> +          getAccessToken() + <span style=' color: Maroon;'>"" expires=""</span> + getAccessExpires());</pre> </li>  <li> <p>別の例があります。Android用の天気予報では、ユーザーの位置情報をログ出力に次のように送信しました。:</p>  <pre> I/MyWeatherReport( 6483): Re-use MyWeatherReport data I/ ( 6483): GET JSON: http://example.com/smart/repo_piece.cgi?arc=0&lat=26.209026&lon=127.650803&rad=50&dir=-999&lim=52&category=1000 </pre>  <p> ユーザがAndroid OS 4.0以前を使用している場合、READ_LOGSのパーミッションを持つ他のアプリケーションは、マニフェストファイルにACCESS_FINE_LOCATIONのパーミッションを宣言することなく、ユーザーの位置情報を取得できます。</p> </li> </ol> ","<ul>     <li>         Facebook SDK for Android: <a href=""http://readwrite.com/2012/04/10/what-developers-and-users-can#awesm=~o9iqZAMlUPshPu"">http://readwrite.com/2012/04/10/what-developers-and-users-can#awesm=~o9iqZAMlUPshPu</a>     </li>     <li><a href=""https://jvn.jp/en/jp/JVN23328321/"">JVN#23328321</a> Puella Magi Madoka Magica iP for Android vulnerable to information disclosure</li>     <li><a href=""https://jvn.jp/en/jp/JVN86040029/"">JVN#86040029</a> Weathernews Touch for Android stores location information in the system log file</li>     <li><a href=""https://jvn.jp/en/jp/JVN33159152/"">JVN#33159152</a> Loctouch for Android information management vulnerability</li>     <li><a href=""https://jvn.jp/en/jp/JVN56923652/"">JVN#56923652</a> Monaca Debugger for Android information management vulnerability</li> </ul>",f60ba40d-b112-4f78-a7ef-920579a10151,0,TRUE,"{1,2}"
18,ビジネスロジック,認証をバイパスして他のユーザ情報とリセットパスワードを取得することができるAPIによる論理的欠陥。認証と認証されたセッションがクライアントかサーバサイドのどちらかまたは両方で適切に検証されませんでした。,APIに論理的欠陥が見つかりましたか?,論理的欠陥は見つかりませんでした。,,ビジネスロジック脆弱性,<p>ほとんどのセキュリティの問題はセキュリティ管理（認証、アクセス制御、入力検証など）の破損あるいは欠如から生じるアプリケーション内の脆弱性です。一方、ビジネスロジック脆弱性は、組織にとってマイナスな結果をもたらすようにアプリの正規のプロセスフローを利用する方法です。</p> <p>しばしば、ビジネスロジックのカテゴリーは自動的にスキャン出来ない脆弱性に使用されます。この事はカテゴリー化スキームの適用を非常に難しくしています。ビジネスロジックの問題は認証問題や他のすべてのカテゴリーと異なります。多くの重大なビジネスロジック脆弱性がありますが、それらはアイテムのタイプよりはるかに一般的ではありません。</p> ,<p> 次のようなものはチェックと適切な修正がされるべきです </p> <ul> <li>クライアントサイドではなくサーバーサイドのOTPへのチェック</li> <li>次のような同じ承認トークンではなく、適切な認証を使用してください。<b>Authorization: Basic aW50ZXJhY3Rpb25vbmU6bW9iaTEyMw==</b> which translates to: <b>interactionone:mobi123</b></li> <li>mobi123 のようなパスワードを絶対に使用しないでください。</li> </ul> ,,"<p>自動化ツールはコンテキストを理解することが困難なため、これらのようなテストの実施は人に依存します。次の２つの例はアプリの機能、開発者の意図、そしていくつかの創造的な ""out-of-the-box"" 思考の理解が、いかにしてアプリのロジックを破ることが出来るかを示します。第一の例は単純化されたパラメータ操作で始まる一方、第二の例はアプリを完全に打ち破る結果になる多段階プロセスの現実世界の例です。 </p> <p><br> <b>例 1</b>： </p> <p>あるEコマースサイトがユーザーに購入する商品の選択、サマリページの閲覧、そして入札を許可していると仮定してください。もし攻撃者が、彼らの同じ有効セッションを維持しながらサマリページに戻り、商品により低い価格を入れて取引を完了し、チェックアウトすることが出来たらどうなるでしょうか？ </p> <p><br> <b>例 2</b>： </p> <p>リソースをホールド/ロックして他の者がオンラインでこれらの商品を購入出来なくすることによって、攻撃者がより低い価格で商品を購入することになる可能性があります。この問題への対応は、タイムアウトと、正しい価格のみチャージすることが出来ることを確実にするメカニズムを実装することです。 </p> <p><br> <b>例 3</b>： </p> <p>もしユーザーが彼らの銀行口座/ロイヤリティアカウントに関連した取引を始めて、ポイントが彼らのアカウントに加算された後で取引を無効にすることが出来たらどうでしょうか？ポイント/預金はそのまま彼らのアカウントに適用されるでしょうか？   </p> ",b1891c55-7391-4c01-89ac-a3914fc13681,0,TRUE,{3}
19,ビジネスロジック,認証をバイパスして他のユーザ情報とリセットパスワードを取得することができるAPIによる論理的欠陥。認証と認証されたセッションがクライアントかサーバサイドのどちらかまたは両方で適切に検証されませんでした。,APIに論理的欠陥が見つかりましたか?,論理的欠陥は見つかりませんでした。,,ビジネスロジック脆弱性,<p>ほとんどのセキュリティの問題はセキュリティ管理（認証、アクセス制御、入力検証など）の破損あるいは欠如から生じるアプリケーション内の脆弱性です。一方、ビジネスロジック脆弱性は、組織にとってマイナスな結果をもたらすようにアプリの正規のプロセスフローを利用する方法です。</p> <p>しばしば、ビジネスロジックのカテゴリーは自動的にスキャン出来ない脆弱性に使用されます。この事はカテゴリー化スキームの適用を非常に難しくしています。ビジネスロジックの問題は認証問題や他のすべてのカテゴリーと異なります。多くの重大なビジネスロジック脆弱性がありますが、それらはアイテムのタイプよりはるかに一般的ではありません。</p> ,,,,4046bfa0-1749-4f23-97b8-eb6dee6e9c7f,1,TRUE,{3}
20,NSLogのデバッグログを注意して管理してください,デバッグログは通常、アプリ開発中は有効化されたままになっています。これらのアプリケーションログは、Xcodeあるいはデバイスへのルートアクセスによって容易にアクセスできます。,このアプリケーションはシステムログにログの出力をしていますか？,アプリケーション内でNSLogによるログの出力はされていません。,<p>機密データがうっかりログにリークされ、更なる攻撃を助長する可能性があります。</p>,NSLog内のデバッグログを注意深く管理してください。,<p>     アプリケーションはデバッグの目的でログにいくつかのデータを追加する傾向があります。もし重要なデータがアプリケーションログに見られたら、それはデータ漏洩につながる可能性があります。</p> ,<p>    一定の間隔、あるいはユーザがアプリケーションからサインアウトした時にアプリケーションログを削除してください。機密情報はログに記録しないようにしてください。</p> ,,,e8c0e638-223f-468e-ae03-f8f67f35d8e4,1,TRUE,{2}
21,機密情報のPlistファイルへの保存,Plistファイルは平文フォーマットのデータを含んでいます。,このアプリケーションはPlistファイルに機密情報を保存していますか？,このアプリケーションはPlistファイルに機密情報を保存していません。,<p>もし攻撃者がデバイスあるいはデバイスバックアップにアクセス可能なら、機密情報が盗まれる可能性があります。</p> ,Plistファイルに機密情報を保存しないでください。,<p>     情報プロパティリストファイルはアプリケーション実行可能ファイルに関する構成情報を含むファイルです。これらのファイルはデバイス上に暗号化されていない形式で保存されます。そのため、サードパーティのツール経由でのアプリケーションサンドボックスへのアクセス(iOS v8.2以前)、デバイスへのルートアクセスの取得(v8.2以降)、あるいはiOSバックアップの取得によって誰にでも読まれる可能性があります。</p> ,<p>    アプリケーションのPlistファイルにはユーザ名、認証トークン、パスワード、個人情報などの機密情報を保存しないことが推奨されています。</p> ,,,4f9a4912-1dfe-4937-8d7b-b7f139dbf91e,1,TRUE,{2}
22,機密情報のNSUserDefaultsへの保存,NSUserDefaultsはデータをplistファイルに保存することができる代替方法です。,このアプリケーションはNSUserDefaultsに機密情報を保存していますか？,このアプリケーションはNSUserDefaultsに機密情報を保存していません。,<p>    plistファイルはデータを暗号化保存しないため、機密情報が侵害される可能性があります。</p> ,NSUserDefaultsに機密情報を保存しないでください。,<p>     NSUserDefaultsは暗号化されずにバイナリフォーマットでplistに保存され、あなたのアプリのディレクトリに保存されます。どんなユーザでも編集、閲覧、共有、移動などやりたいことを何でもできます。そのため、もし何らかの機密情報がNSUserDefaultsに保存されるなら、それは誤った手に届き、個人利用される可能性があります。</p> ,<p>     暗号化されていない形式の情報を含んだplistファイルにデータを保存する際は、NSUserDefaultsを機密情報を保存するために使用しないでください。</p> ,,,6c8385ac-590f-4458-97c6-43a9d5e07c76,1,TRUE,{2}
23,機密情報保存のためのSQLite3データベースの利用,SQLite3データベースはデバイス上に暗号化されずに保存されます。そのようなデータベースへの機密情報の保存はデータ漏洩につながる可能性があります。,このアプリケーションはSQLite3データベース内に機密情報を保存していますか？,このアプリケーションはSQLite3データベースに機密情報を保存していません。,<p> 暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連データの侵害につながる可能性があります。 </p> ,SQLite3データベースを機密情報の保存に使用しないでください。,<p>     SQLiteデータベースはアプリケーションで使用可能な永続的または一時的なデータを保存するために使用されます。例えば、ユーザにシームレスな体験を与えるために、アプリケーションはユーザが再度入力する必要がないように、ユーザ資格情報をSQLiteデータベースに保存することができます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。</p> ,<p>     SQLiteデータベースにデータ保存する際、カスタム暗号化の使用が推奨されます。</p>  <p>     SQLiteエンジンはデータを実際のデータベースファイルに保存する前にWrite Ahead Log (WAL)に書き込みます。WALの利用によって、データベースファイルから削除されたデータを復元する可能性があります。それゆえ、誰かが復元しようとしても読めないように、SQLiteのレコードを削除する前は常に何らかのジャンクデータで上書きしてください。</p> ,,,7f7b2b31-1e8b-41ac-aad0-e9bb0fe58378,1,TRUE,{2}
24,機密情報のCoreDataへの保存,CoreDataはアプリケーションのパフォーマンスを改善するために、しばしばアプリケーションによってデータ保存のため使用されます。,このアプリケーションはCoreDataに機密情報を保存していますか？,このアプリケーションはCoreDataに機密情報を保存していません。,<p> 暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連データの侵害につながる可能性があります。 </p> ,NSLog内のデバッグログを注意深く管理してください。,<p>     CoreDataはアプリケーションで使用可能なデータを保存するために使用されます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベースに保存するなら、第三者にアクセスされる可能性があります。</p> ,"<p>    CoreDataにデータ保存する際、カスタム暗号化の使用が推奨されます。</p> <p>     EncryptedStoreはCoreDataを暗号化形式で保存するためにiOSバージョン6.0～9.3.4で正常に動作することが知られています。</p>  <p>もしカスタムキャッシュサイズ、あるいはカスタムデータベースURLをセットしたいなら、カスタムパスコード、カスタムキャッシュサイズ、および/またはカスタムデータベースURLの代わりに、あなたのEncryptedStoreのオプションをセットするNSDictionaryを作成してください。</p>  <pre style='color:#000000;background:#ffffff;'>NSDictionary <span style='color:#808030; '>*</span>options <span style='color:#808030; '>=</span> <span style='color:#808030; '>@</span><span style='color:#800080; '>{</span> EncryptedStorePassphraseKey<span style='color:#800080; '>:</span> <span style='color:#808030; '>(</span>NSString <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span> customPasscode<span style='color:#808030; '>,</span> <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;EncryptedStoreCacheSize:</span> <span style='color:#808030; '>(</span>NSNumber <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span> customCacheSize<span style='color:#808030; '>,</span> <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;EncryptedStoreDatabaseLocation:</span> <span style='color:#808030; '>(</span>NSURL <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span> customDatabaseURL                            <span style='color:#800080; '>}</span><span style='color:#800080; '>;</span> </pre> In your application delegate source file (i.e. AppDelegate.m) you should see  <pre style='color:#000000;background:#ffffff;'>NSPersistentStoreCoordinator <span style='color:#44aadd; '>*</span>coordinator <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>self persistentStoreCoordinator<span style='color:#808030; '>]</span><span style='color:#808030; '>;</span> </pre> mosiIf you created an NSDictionary with custom options, replace that line with  <pre style='color:#000000;background:#ffffff;'>NSPersistentStoreCoordinator <span style='color:#44aadd; '>*</span>coordinator <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>EncryptedStore makeStoreWithOptions<span style='color:#808030; '>:</span>options managedObjectModel<span style='color:#808030; '>:</span><span style='color:#808030; '>[</span>self managedObjectModel<span style='color:#808030; '>]</span><span style='color:#808030; '>]</span><span style='color:#808030; '>;</span> </pre>  The Project is available at <a href=""https://github.com/project-imas/encrypted-core-data"">https://github.com/project-imas/encrypted-core-data</a> ",,,29b51a7f-ff6e-4e93-a9da-66a83bffa44a,1,TRUE,{2}
25,CouchDBに保存されたセキュリティで保護されていないデータ,CouchDBはデータ保存のためにアプリケーションに使用されるSQLite3データベースの代替です。,このアプリケーションはCouchDBにデータを保存していますか？,このアプリケーションはCouchDBに機密情報を保存していません。,<p> 暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連データの侵害につながる可能性があります。 </p> ,CouchDBに保存されたセキュリティで保護されていないデータ,<p>     CouchDBはアプリケーションで使用可能なデータを保存するために使用されます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベースに保存するなら、第三者にアクセスされる可能性があります。</p> ,"<p>     CouchDBにデータ保存する際、カスタム暗号化の使用が推奨されます。</p> <p> データベース暗号化はForestDBとSQLiteストレージタイプの両方で利用できます。それは自動的にForestDBのファイルシステムの抽象化レイヤーにフックされ、SQLiteストレージにはCouchbase LiteがSQLCipherを使用します。それはデータベースファイルの透過的な暗号化を付与するSQLiteのオープンソース拡張機能です。両方の場合において、暗号化仕様は256-bit AESです。</p> <p> SQLCipherは任意の依存関係です。次のセクションはそれをプラットフォームに追加する方法を記述しています。</p> <ul>     <li>次のURLからiOS SDKをダウンロード: <a href=""http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile"">http://www.couchbase.com/nosql-databases/downloads#couchbase-mobile</a>.</li>     <li>Xcodeプロジェクトにlibsqlcipher.aライブラリを追加してください。</li>     <li>あなたのapp targetのLink Binary With Librariesビルドフェーズに進んでください。</li>     <li>libsqlite.dylibを除去してください。</li> </ul> ",,,cfc232d3-a55b-4cca-818a-c19b0f235d27,1,TRUE,{2}
26,RealmDBに保存されたセキュリティで保護されていないデータ,Realmデータベースはアプリケーションで使用可能なデータを保存するために使用されます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベースに保存するなら、第三者にアクセスされる可能性があります。,このアプリケーションはRealmDBにデータを保存していますか？,このアプリケーションはRealmDBに機密情報を保存していません。,<p> 暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連データの侵害につながる可能性があります。 </p> ,RealmDBに保存されたセキュリティで保護されていないデータ,<p>     RealmDBはアプリケーションで使用可能なデータを保存するために使用されます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベースに保存するなら、第三者にアクセスされる可能性があります。 </p> ,<p>  RealmDBにデータ保存する際、カスタム暗号化の使用が推奨されます。</p> <p>     暗号化されていないRealmファイルの暗号化コピー </p> <pre style='color:#000000;background:#ffffff;'>Realm<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800000; font-weight:bold; '>.write</span>CopyToPath<span style='color:#808030; '>(</span>_:encryptionKey:<span style='color:#808030; '>)</span> </pre>      <p>そして、暗号化されたファイルを新しい場所で使用します。</p> ,,,ab8576c9-e6e5-40f5-8998-3245f020303a,1,TRUE,{2}
27,YapDBに保存されたセキュリティで保護されていないデータ,YapDBはデータ保存のためにアプリケーションに使用されるSQLite3データベースの代替です。,このアプリケーションはYapDBにデータを保存していますか？,このアプリケーションはYapDBに機密情報を保存していません。,<p> 暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連データの侵害につながる可能性があります。 </p> ,YapDBに保存されたセキュリティで保護されていないデータ,<p>     YapDBはアプリケーションで使用可能なデータを保存するために使用されます。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベースに保存するなら、第三者にアクセスされる可能性があります。</p> ,"<p>     YapDBにデータ保存する際、カスタム暗号化の使用が推奨されます。</p> <p>     SQLCipherはデータベース全体を透過的に暗号化するSQLiteの拡張機能であり、BSDスタイルのライセンス下で利用可能です。SQLCipherサポートはCocoaPodsのsubspecとして追加されました。単純にPodfileを変更してください。</p> <pre style='color:#000000;background:#ffffff;'>pod <span style='color:#696969; '>'YapDatabase/SQLCipher'</span> </pre> <p>     もしSQLCipherのsubspecを使用していないなら、そのプロジェクトはサポートが利用可能ではないときは偶発的に暗号化を使用されることを防ぐために暗号化構成オプションをコンパイルしないでしょう。</p> <p>   いったんプロジェクトがSQLCipherの使用のために構成されると、YapDBにパスフレーズを伝える必要があります。これはYapDatabaseOptionsのcipherKeyBlockをセットすることで実行されます。</p> <pre style='color:#000000;background:#ffffff;'>YapDatabaseOptions <span style='color:#808030; '>*</span>options <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>YapDatabaseOptions alloc<span style='color:#808030; '>]</span> init<span style='color:#808030; '>]</span>;     options<span style='color:#008c00; '>.</span>corruptAction <span style='color:#808030; '>=</span> YapDatabaseCorruptAction_Fail;     options<span style='color:#008c00; '>.</span>cipherKeyBlock <span style='color:#808030; '>=</span> <span style='color:#808030; '>^</span> NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>(</span>void<span style='color:#808030; '>)</span>{         <span style='color:#808030; '>/</span><span style='color:#808030; '>/</span> You can also <span style='color:#800000; font-weight:bold; '>do</span> things <span style='color:#808030; '>like</span> fetch from the keychain <span style='color:#800000; font-weight:bold; '>in</span> here.         return <span style='color:#808030; '>[</span>@<span style='color:#808030; '>""</span><span style='color:#0000e6; '>super secure passphrase</span><span style='color:#808030; '>""</span> dataUsingEncoding:NSUTF8StringEncoding<span style='color:#808030; '>]</span>;          <span style='color:#808030; '>/</span><span style='color:#808030; '>/</span> Note: The return type <span style='color:#808030; '>is</span> NSData, <span style='color:#808030; '>and</span> does <span style='color:#808030; '>NOT</span> have <span style='color:#800000; font-weight:bold; '>to</span> be a <span style='color:#800000; font-weight:bold; '>string</span> <span style='color:#800000; font-weight:bold; '>in</span> UTF<span style='color:#808030; '>-</span><span style='color:#008c00; '>8</span>.         <span style='color:#808030; '>/</span><span style='color:#808030; '>/</span> It can be any kind of blob of data, including randomly generated bytes.     };      self<span style='color:#008c00; '>.</span>database <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>YapDatabase alloc<span style='color:#808030; '>]</span> initWithPath:databasePath options:options<span style='color:#808030; '>]</span>; </pre>  <p>     cipherKeyBlockは必要以上に長くメモリに資格情報を保存するのを防ぐのに役立ちます。このブロックはデータベースセットアップ時、そしてデータベースへの新たな接続が作成された時に実行されます。</p> ",,,b8f13460-7166-49fe-895d-fd4bfdf92d1a,1,TRUE,{2}
28,非推奨のAPI NSURLConnectionのインターネット接続のための使用,NSURLConnectionはサーバとのネットワーク接続を確立するのために使用される最も一般的なAPIです。しかし、それはNSURLSessionに置き換えられ、iOS 9.0の開始からAppleによって非推奨になりました。,このアプリケーションは NSURLConnection を使用していますか？,このアプリケーションはインターネットへの接続に NSURLConnection を使用していません。,<p>   推奨されないルーティンの使用は次の結果につながる可能性があります:    <ol>         <li>推奨されないメソッド内の致命的な欠陥によるプログラミングエラー</li>         <li>安全でない推奨されないメソッドによるデータ破損</li>     </ol> </p> ,推奨されない NSURLConnection がインターネット接続のために使用されています。,<p>     NSURLConnection はサーバとのネットワーク接続の構築に使われる最も一般的な API です。しかし、 NSURLSession によって取って代わられてきました。iOS 9.0を始めた Apple に推奨されておりません。NSURLSession はセッション単位のキャッシュ、プロトコル、クッキー、そして資格情報ポリシーの、より適切な方法で認証チャレンジをするアプリ同士の共有ではなく、構成のサポートをします。 </p> ,"<p>   Apple が近い将来  NSURLConnection のサポートを停止する可能性があるので、 NSURLConnection の代わりにすべてのタイプのネットワーク接続のために NSURLSession の使用が望ましいです </p>  <p>NSURLSession は HTTP リクエストを送受するためのキーオブジェクトです。 It can be created via <i>NSURLSessionConfiguration</i>, which comes in three flavors:</p> <ul> <li><i>defaultSessionConfiguration</i>: Creates a default configuration object that uses the disk-persisted global cache, credential and cookie storage objects.</li> <li><i>ephemeralSessionConfiguration</i>: Similar to the default configuration, except that all session-related data is stored in memory. Think of this as a ""private"" session.</li> <li><i>backgroundSessionConfiguration</i>: Lets the session perform upload or download tasks in the background. Transfers continue even when the app itself is suspended or terminated.</li> <p>NSURLSessionConfiguration also lets you configure session properties such as timeout values, caching policies and additional HTTP headers. Refer to the documentation for a full list of configuration options.</p>  <h2> Example Implementation</h2> <pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>/* Sent when a download task that has completed a download.  The delegate should </span> <span style='color:#696969; '>&#xa0;* copy or move the file at the given location to a new location as it will be </span> <span style='color:#696969; '>&#xa0;* removed when the delegate message returns. URLSession:task:didCompleteWithError: will</span> <span style='color:#696969; '>&#xa0;* still be called.</span> <span style='color:#696969; '>&#xa0;*/</span> <span style='color:#808030; '>-</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span>URLSession<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSession <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>session downloadTask<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSessionDownloadTask <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>downloadTask <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;didFinishDownloadingToURL:</span><span style='color:#808030; '>(</span>NSURL <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>location<span style='color:#800080; '>;</span>  <span style='color:#696969; '>/* Sent periodically to notify the delegate of download progress. */</span> <span style='color:#808030; '>-</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span>URLSession<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSession <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>session downloadTask<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSessionDownloadTask <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>downloadTask <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;didWriteData:</span><span style='color:#808030; '>(</span>int64_t<span style='color:#808030; '>)</span>bytesWritten <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;totalBytesWritten:</span><span style='color:#808030; '>(</span>int64_t<span style='color:#808030; '>)</span>totalBytesWritten <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;totalBytesExpectedToWrite:</span><span style='color:#808030; '>(</span>int64_t<span style='color:#808030; '>)</span>totalBytesExpectedToWrite<span style='color:#800080; '>;</span>  <span style='color:#696969; '>/* Sent when a download has been resumed. If a download failed with an</span> <span style='color:#696969; '>&#xa0;* error, the -userInfo dictionary of the error will contain an</span> <span style='color:#696969; '>&#xa0;* NSURLSessionDownloadTaskResumeData key, whose value is the resume</span> <span style='color:#696969; '>&#xa0;* data. </span> <span style='color:#696969; '>&#xa0;*/</span> <span style='color:#808030; '>-</span> <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span>URLSession<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSession <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>session downloadTask<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSURLSessionDownloadTask <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>downloadTask <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;didResumeAtOffset:</span><span style='color:#808030; '>(</span>int64_t<span style='color:#808030; '>)</span>fileOffset <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;expectedTotalBytes:</span><span style='color:#808030; '>(</span>int64_t<span style='color:#808030; '>)</span>expectedTotalBytes<span style='color:#800080; '>;</span> </pre> ",,,1a58222b-1f0b-49c3-82ef-14f8578c39b1,1,TRUE,{2}
29,PhoneGapのJavaScriptインジェクション,古いバージョンのPhoneGapを使用ているアプリケーションはJavascriptインジェクションの脆弱性を持っています。,このアプリケーションに PhoneGap 経由のJavascript インジェクション脆弱性がありますか？,このアプリケーションは Phonegap 経由の JS インジェクションによって影響を受けないようです。,<p>     Cordova 3.5.0 未満の場合、攻撃者は:     <ul>         <li>データを開いたり任意のアプリへ送ったりします。</li>         <li>HTTP ホワイトリストを回避し、任意のサーバへ接続します。</li>         <li>細工されたインテント URL を介してスタートページを変更します。</li>     </ul> </p>  ,PhoneGap JavaScript インジェクション,"<p> PhoneGap はWeb テクノロジーをモバイルとWeb 間のギャップの橋渡しをするために使用します。</p><p>PhoneGap のために作られたアプリケーションはハイブリッドアプリであり、完全に自然のものやウェブベースでもなく、その間のどこかに位置します。モバイル OS は HTML5 と JavaScript、 PhoneGap アプリをサポートしないので、モバイルデバイスに JavaScript と HTML5 の実行を許可するウェブコンテナである、WebViewを使用してください。 WebView (異なるプラットフォームの様々なタームと呼ばれる) はモバイルとWeb 間のギャップの橋渡しをし、様々な plugins はアプリをより強固で直感的にするのを助けます。</p><p>それぞれの OS との通信のため、 PhoneGap は異なる API (PhoneGap によって作られた) を使用し、 plugins (ネイティブ と カスタム 両方で)それぞれのプラットフォームのネイティブ言語とPhoneGap スクリプト間の橋渡しのように振舞います。 box から、 PhoneGap は Camera, Contacts, Compass, Media, FileSystem などのためにAPI と一緒に来ます。Plugins はこれらの利用可能なAPIにアクセスできない機能を拡張します。 </p> ",<p>     Phonegap あるいは Apache Cordova を最新バージョンにアップグレードしてください。</p> ,,,3d6c212c-5789-4569-bb94-eb7334139f56,0,TRUE,{1}
30,Android リモートURLリダイレクトの脆弱性,古いバージョンのPhoneGapを使用しているAndroidアプリケーションは、CVE-3500で定義されている恣意的なWebサイトへのURLリダイレクトに対して脆弱です。,リモートの攻撃者に URL リダイレクトを許す可能性がある古いバージョンの Phonegap をアプリケーションは使用していますか？,このアプリケーションは URL リダイレクト脆弱性が無いようです。あるいは phonegap を全く使用していません。,<p>     Cordova 3.5.0 未満では、攻撃者は:     <ul>         <li>データを開き、任意のアプリケーションに送ります</li>         <li> HTTP ホワイトリストを回避し、任意のサーバに接続します</li>         <li>細工されたインテント URL でスタートページを変更します</li>     </ul> </p>  ,Android リモート URL リダイレクト脆弱性,<p>   Cordova framework でビルドされた Android アプリは特殊なインテント URL を通して起動される可能性があります。特殊に細工された URL は Cordova ベースのアプリを他の Android デバイスに保存された HTML コンテントを含む、開発者が意図したものと異なるスタートページでスタートアップさせる可能性があります。これは 3.5.0 までの Cordova のすべてのリリースされたバージョンの場合で、最新リリース (3.5.1) では修正されました。影響を受けたプロジェクトはそれらのアプリを最新リリースへアップデートすることを推奨します。 </p> ,<p>   Phonegap 、または Apache Cordova アプリケーションを最新バージョンにアップグレードしてください。</p> ,,,d1376a24-4147-416c-a57d-d19ff06d2987,0,TRUE,{1}
31,Android エラーURLリダイレクトの脆弱性,古いバージョンの PhoneGapを使用しているAndroidアプリケーションは、CVE-3500で定義されている恣意的なWebサイトへのエラーURLリダイレクトに対して脆弱性です。,リモートの攻撃者にエラー URL リダイレクトを許す可能性がある古いバージョンの Phonegap をアプリケーションは使用していますか？,このアプリケーションはエラー URL リダイレクト脆弱性が無いようです。あるいは phonegap を全く使用していません。,<p>      Cordova 3.5.0 未満の場合、攻撃者は:     <ul>         <li>データを開き、任意のアプリケーションに送ります</li>         <li>HTTP ホワイトリストを回避し、任意のサーバに接続します</li>         <li>細工されたインテント URL でスタートページを変更します</li>     </ul> </p>  ,Android エラー URL リダイレクト脆弱性,<p>     Cordova ベースのアプリはユーザーとの対話のために WebView を利用します。この脆弱性は悪意のある発信者によってインテント extras (CordovaActivity 内) を介してパスされる可能性があるエラー URL パラメーターを利用しますが、それはアプリロードで自動的に WebView へロードされません。エラー URL はネットワークリクエスト失敗時に WebView によって表示のみされます。これは脆弱性を利用されることによって、悪意のある発信者がアクティビティを起動する可能性があることを示しています。 </p> ,<p>     Phonegap 、または Apache Cordova アプリケーションを最新バージョンにアップグレードしてください。</p> ,,,84cccfe9-a4de-4ac2-a994-478553188b2f,0,TRUE,{1}
32,Android 非推奨のAPIによるHTTPSのバイパス,推奨されないAndroidのPhoneGapアプリケーションは、攻撃者がHTTPS接続をHTTPにダウングレードできるCVE-3501の影響を受けます。,アプリケーションは推奨されないバージョンの Phongap を使用していますか？,アプリケーションは古いバージョンの Phonegap を使用していない、あるいは phonegap を全く使用していないようです。,<p>     攻撃者はHTTPホワイトリストを回避する任意のリモートサーバへ接続する JavaScript アプリからの WebSocket 接続を開く可能性があります。 </p> ,Android の推奨されない API による HTTPS 回避,<p>      Cordova framework でビルドされた Android アプリは、コンテンツを表示するために WebView コンポーネントを使用します。Cordova アプリは表示、あるいは XMLHttpRequest 経由での通信を許可される URL ホワイトリストを特殊化する可能性があります。しかし、このホワイトリストは非 http チャネルで通信するために JavaScript 経由で指示された時、 WebView コンポーネントによって使用されません。  </p> <p>   具体的に、インターネット上の届きうるサーバーに接続するアプリケーション JavaScript  からWebSocket 接続を開くことが可能です。もし攻撃者がアプリ内の任意の JavaScript を実行することが可能なら、攻撃者は HTTP ホワイトリストを回避して接続をどんなサーバーにも開くことが可能になります。</p> <p>    これは一般的な Android 上のハイブリッドアプリ構造の制限事項であり、 Apache Cordova に限ったことではありません。</p> ,<p>     Phonegap 、または Apache Cordova アプリケーションを最新バージョンにアップグレードしてください。</p> ,,,c3acd99f-3da5-40d9-b5fd-b4f2068234ac,0,TRUE,{1}
33,Android PhoneGapアプリでのHTTPSホワイトリストのバイパス,PhoneGapでは、正規表現がホワイトリストに使用されている場合、その正規表現からHTTPSをバイパスできるかチェックします。,アプリケーションは phonegap でのホワイトリスト化に誤った regex を使用していますか？,phonegap アプリケーションは適切な regex チェックを使用、あるいは適切に phonegapを使用していないようです。 ,<p>    攻撃者は Cordova の ホワイトリスト化メカニズムを回避し、権利化されていないリモートサーバへの接続を初期化する可能性があります。 これは更なる攻撃を助長する可能性があります。</p>  ,Android Phonegap アプリ内のHTTPS ホワイトリスト回避,<p>    Cordova WebView が構成済みホワイトリスト内の URL へのリクエストのみ許可することを保証するために、 framework は Android's shouldInterceptRequest() を上書きします。</p> <p>      ホワイトリストするメカニズムを付与する shouldInterceptRequest() の利用は、あるリクエスト( HTTP/S あるいはファイル URI を通したそれらのサービスなど)のみインターセプトするために利用される点で問題があります。この機能が Android framework によって呼び出されないプロトコルがある可能性があります。Android 4.4 KitKat の時点では、 WebView は Chromium によって表示され、一つのそのようなプロトコルである Web Sockets をサポートしています。それゆえ、攻撃者はCordova のホワイトリストメカニズムを回避するために WebSocket 接続を利用する可能性があります。</p> ,"<p>     ドメインのホワイトリストは、あなたのアプリが制御できない外部のドメインへのアクセスを制御するセキュリティモデルです。  Cordova のデフォルトのセキュリティポリシーはどんなサイトへのアクセスも許可しています。あなたのアプリを実稼動に移す前に、ホワイトリストを生成し、特定のネットワークドメインとサブドメインへのアクセスを許可するべきです。 </p>  <p>    Cordova が付随しているのは W3C Widget Access 仕様であり、それは特定のドメインへのネットワークアクセスを有効にする、アプリの config.xml file 内の <access>要素に依存しています。 Command-Line インターフェースに記述された CLI workflow に依存しているプロジェクトのため、このファイルはプロジェクトのトップレベルディレクトリに配置されています。他方でプラットフォーム固有の開発パスでは、場所は次のセクションにリストされています：  </p>  </p>次の例はホワイトリストの構文を例示しています：</p>  <p><b>Access to google.com:</b></p>  <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre>  <p><b>Access to the secure google.com (https://):</b></p> <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""https://google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre>  <p><b>Access to the subdomain maps.google.com:</b></p> <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://maps.google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre>  <p><b>Access to all the subdomains on google.com, for example mail.google.com and docs.google.com:</b></p> <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://*.google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre>  <p><b>Access to all domains, for example, google.com and developer.mozilla.org:</b></p> <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""*""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre>  <b>This is the default value for newly created CLI projects which not secured.</b> <p>     また、あなたの Phonegap あるいは Apache Cordova アプリを最新バージョンにアップグレードしてください </p> ",,,422f31db-8060-446a-997d-adc534d15129,0,TRUE,{1}
34,Android 3.5.1未満のApache Cordova Androidでのリモートの攻撃者へのスタートページの変更の許可,CVE-3500 によると、Apache Cordovaはスタートページを変更する脆弱性を持っていました。,アプリケーションは、リモートの攻撃者によるスタートページ変更の CVE-3500 に影響されますか？,アプリケーションは CVE-3500 に影響を受けないか、あるいは Apache Cordova を使用していない可能性があります。,<p>     Cordova 3.5.0 未満では、攻撃者は:     <ul>         <li>データを開き、任意のアプリケーションに送ります</li>         <li> HTTP ホワイトリストを回避し、任意のサーバに接続します</li>         <li>細工されたインテント URL でスタートページを変更します</li>     </ul> </p>  ,Android 3.5.1 未満の Apache Cordova はリモートの攻撃者にスタートページの変更を許します,<p> 	 Android 3.5.0 とそれ未満のバージョンの Apache Cordova には脆弱性が存在します。攻撃者はこれらの問題を利用し、無許可のアクションを実行するためにセキュリティ制限を回避する可能性があります。これが更なる攻撃を助長する可能性があります。 </p> ,<p>     Phonegap 、または Apache Cordova アプリケーションを最新バージョンにアップグレードしてください。</p> ,,,a7f25b7a-40af-4058-b360-4ec1d97beb02,0,TRUE,{1}
35,Android PhoneGapのデバッグログの出力,アプリケーション開発のためにPhoneGapを使用している間は、常にPhoneGap経由でデバッグログを停止してください。, phone gap ログのためのアプリケーションデバッグログは有効ですか？,アプリケーションはログ関連の phonegap を使用していないか、あるいは phonegap を使用していません。,<p>    攻撃者はデバッガーをアタッチし、アプリの論理フローを変える可能性があります。さらに、アプリの URL エンドポイントを決定するために利用される重要なログは漏洩する可能性があります。</p> ,Android Phonegap デバッグロギング,<p>   PhoneGap アプリがデバッグモードのスイッチがONの状態で出荷されると、誰でもデバッガーをアタッチしてアプリの論理フローを変更することが可能です。 また、重要なログが流出し、アプリの URL エンドポイントを決定するために使用される可能性があります。　</p> ,"<p>     Cordova を使用しているなら、使用している plugin を公開してください</p>  <pre style='color:#000000;background:#ffffff;'>cordova build android <span style='color:#808030; '>-</span><span style='color:#808030; '>-</span>release </pre>  <p> PhoneGap を使用しているなら、公開前にすべての,  console.logs() と他の logging codes を無効にしてください。 </p> ",,,124ea0fe-2df4-4574-89f0-eaca99f62569,0,TRUE,{1}
36,Android PhoneGapのホワイトリストURLの欠如,アプリケーション開発のためにPhoneGapを使用している間は、常に接続するURLをホワイトリストに登録してください。,アプリケーションは、 Phonegap 使用の場合に URL をホワイトリストしていますか？,アプリケーションは適切に URL をホワイトリストにしなかったか、Phonegap を使用していません。,<p>     ドメインホワイトリスト無しでは、攻撃者が iframe のドメインをロードする可能性があり、iframe 内のそのページのスクリプトは直接 Cordova JavaScript オブジェクトと corresponding native Java objects にアクセスする可能性があります。</p> ,Android Phonegap ホワイトリストの無い URL Present,<p>   ドメインのホワイトリストは、あなたのアプリが制御できない外部のドメインへのアクセスを制御するセキュリティモデルです。 Cordova はどの外部サイトがアクセス可能か定義するために、構成可能なセキュリティポリシーを付与します。デフォルトでは、新しいアプリはどんなサイトへのアクセスも許可するよう構成されています。　アプリを実稼動に移行する前に、ホワイトリストを生成し、特定のネットワークドメインとサブドメインへのアクセスを許可するべきです。</p> ,"<p> 　Cordova が付随しているのは W3C Widget Access 仕様であり、それは特定のドメインへのネットワークアクセスを有効にする、アプリの config.xml file 内の <access>要素に依存しています。 Command-Line インターフェースに記述されたCLI workflow に依存しているプロジェクトのため、このファイルはプロジェクトのトップレベルディレクトリに配置されています。他方でプラットフォーム固有の開発パスでは、場所は次のセクションにリストされています：  </p>  </p>次の例はホワイトリストの構文を例示しています：</p>   <p><b>Access to google.com:</b></p>  <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre> <br /> ------------- Access to the secure google.com (https://): <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""https://google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre> -------------- <br /> Access to the subdomain maps.google.com: <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://maps.google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre> -------------- <br /> Access to all the subdomains on google.com, for example mail.google.com and docs.google.com: <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""http://*.google.com""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre> -------------------------- <br />  Access to all domains, for example, google.com and developer.mozilla.org: <pre style='color:#000000;background:#ffffff;'><span style='color:#a65700; '>&lt;</span><span style='color:#5f5035; '>access</span><span style='color:#274796; '> origin</span><span style='color:#808030; '>=</span><span style='color:#0000e6; '>""*""</span><span style='color:#274796; '> </span><span style='color:#a65700; '>/></span> </pre> <br /> <b>This is the default value for newly created CLI projects which not secured.</b> ",,,ce4a2000-7530-4d45-8998-44c939a6a9a6,0,TRUE,{1}
37,Android Redis経由の安全でないトランスポート層,Redisを使用して通信するAndroidアプリケーションには脆弱性があります。,アプリケーションは、通信のために Redis を使用していますか？,Tアプリケーションは Redis を使用していないようです。,<p>    ユーザ資格情報を含むデータベースと関連するデータは侵害される可能性があります。 </p> ,Android セキュリティで保護されていない Redis を介したトランスポートレイヤー,<p>     Redis framework はサーバー間の通信において厳密に使用されるべきです。クライアントサイドでの Redis の使用は、資格情報が平文で読まれる可能性があるため、セキュリティを侵害します。</p> ,<p>    Redis client を完全に削除してください。 もし何らかの SDK がこのコンポーネントを使用していたら、SDK 自体を削除してください。 </p> ,,,7e5d80a8-4a03-4643-b18f-5192160031fa,0,TRUE,{1}
38,Android 保護されていないエクスポートされたアクティビティ,"Androidアプリケーションは、他のアプリケーションによる使用のためにアクティビティをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、コンポーネントが含むデータにアクセスできるかを適切に制限しません。,アプリケーションアクティビティはエクスポートされていますか？,このアプリ内のアクティビティは公開されていないようです。,<p>     攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。</p> ,Androidアプリは他者の使用のためにアクティビティをエクスポートします,<p> 　アクティビティはユーザーインターフェースを付与します。アクティビティはインテントと起動し、それらはデータを、完了時に呼び出しコンポーネントに戻す可能性があります。すべてのアプリの可視部分はアクティビティです。</p> <p> エクスポートされたアクティビティは電話内にインストールされた他の任意のアプリによって呼び出され、 XAS (Cross Application Scripting) につながる可能性があります。 </p> ,""<p> 	もし自分のアプリ間のみで共有のためにアクティビティを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、アクティビティにアクセスするアプリが同じキーでサインされた時にさらに制御されたアプリへのアクセスを提供します。</p> <p>    もしアクティビティがそれ自体の中で呼び出された時は、それをエクスポート、あるいはカスタム権限のインテントフィルタを使用しないでください </p> ",,,,,,,,,521bedcb-0643-4410-81a6-c25a05f852b5,0,TRUE,{1}
39,Android 保護されていないエクスポートされたレシーバ,Androidアプリケーションは、他のアプリケーションによる使用のためにレシーバをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、コンポーネントが含むデータにアクセスできるかを適切に制限しません。,アプリケーションブロードキャストレシーバはエクスポートされていますか？,このアプリ内の Broadcast Receiver は公開されていないか、実装されていないようです。,<p>   攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。  </p> ,Android 保護されていないエクスポートされたレシーバー,<p> ブロードキャストレシーバは複数のアプリへ送られたインテントを受け取ります。レシーバは適切なインテントの受取によってトリガーされ、バックグラウンドで実行され、イベントをハンドルします。レシーバは通常 short-lived で、それらはしばしばメッセージをアクティビティあるいはサービスに中継します。 ブロードキャストインテントは三種類あります：normal 、sticky 、そして ordered です。 Normal ブロードキャストは即時にすべての登録済み レシーバに送られ、それらは消滅します。Ordered ブロードキャストは一度に一つのレシーバへ運ばれ、また、 ordered ブロードキャストのデリバリーチェーン内のレシーバ はその伝達を停止する可能性があります。ブロードキャストレシーバは ordered ブロードキャストを受け取るための優先レベルの設定が可能です。 Sticky ブロードキャストはそれらが将来のレシーバ に運ばれ、 再ブロードキャストされた後もアクセス可能なままです。</p> <p>エクスポートされたブロードキャストレシーバは電話内にインストールされた他の複数のアプリによってブロードキャストレシーバを呼び出すために呼び出され、 XAS (Cross Application Scripting) につながる可能性があります。  </p> ,"<p> もし自分のアプリ間のみで共有のためにブロードキャストレシーバを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたブロードキャストレシーバへのアクセスを提供します。</p> <p>   もしブロードキャストレシーバがそれ自体の中で呼び出された時は、それをエクスポート、あるいはカスタム権限のインテントフィルタを使用しないでください </p> ",,,654ec6c0-3a70-4ffe-a98e-af0ca737d6de,0,TRUE,{1}
40,Android 保護されていないエクスポートされたサービス,Androidアプリケーションは、他のアプリケーションによる使用のためにサービスをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、コンポーネントが含むデータにアクセスできるかを適切に制限しません。,アプリケーションサービスはエクスポートされていますか？,このアプリ内のサービスコンポーネントは公開されていないか、実装されていないようです。,<p>    攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。</p> ,Android 保護されていないエクスポートされたサービス,<p> サービスはバックグラウンドで実行され、ユーザーとの対話をしません。ファイルのダウンロードあるいはアーカイブの展開は、サービス内で起きる可能性のある操作の例です。別のコンポーネントはサービスにバインドする可能性があり、それによって、ターゲットサービスインターフェース内で宣言されたメソッドをバインダーに呼び出させます。 インテントはサービスをスタートとバインドするために使用されます。</p> <p> エクスポートされたサービスは、サービスにバインドするために電話内にインストールされた他のアプリによって呼び出される可能性があり、それは XAS (Cross Application Scripting) につながります。 </p> ,"<p> 	もし自分のアプリ間のみで共有のためにサービスを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたサービスへのアクセスを提供します。</p> <p>   もしサービスがそれ自体の中で呼び出された時は、それをエクスポート、あるいはカスタム権限のインテントフィルタを使用しないでください  </p>",,,15dc5a52-a20b-4dd6-b120-47f4b7574f2a,0,TRUE,{1}
41,Android 保護されていないエクスポートされたプロバイダ,Androidアプリケーションは、他のアプリケーションによる使用のためにコンテンツプロバイダをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、コンポーネントが含むデータにアクセスできるかを適切に制限しません。,アプリケーションコンテントプロバイダはエクスポートされていますか？,このアプリ内のコンテントプロバイダは公開されていないか、実装されていないようです。,<p>     攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。</p> ,Android 保護されていないエクスポートされたプロバイダ,<p>    コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータベースです。 それらは持続的内部データストレージと、アプリ間情報の共有のメカニズムとしての両方のために使用されます。 </p> <p> エクスポートされたコンテントプロバイダは、コンテントプロバイダ経由でデータを取得するために、電話にインストールされた他の悪意のあるアプリによって呼び出される可能性があります。それは XAS (Cross Application Scripting) につながる可能性があります。</p> ,"<p>  もし自分のアプリ間のみで共有のためにコンテントプロバイダを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたコンテントプロバイダデータへのアクセスを提供します。</p> <p>   もしコンテントプロバイダがそれ自体の中で呼び出された時は、それをエクスポート、あるいはカスタム権限のインテントフィルタを使用しないでください  </p>	 ",,,09b54a43-80b9-4ca7-868b-0656d9b23f6c,0,TRUE,{1}
42,Android 署名が無いエクスポートされたアクティビティ,Androidアプリケーションは、他のアプリケーションによる使用のためにアクティビティをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、含まれているデータにandroid:protectionLevelで定義されたカスタムシグネチャを介してアクセスできるかを適切に制限しません。,アプリケーションアクティビティは保護レベル無しでエクスポートされていますか？,このアプリ内のアクティビティは保護レベルで公開されていないか、あるいは実装されていないようです。,<p>     攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。</p> ,Android 署名無しでエクスポートされたアクティビティ,<p> アクティビティーはユーザーインターフェースを提供します。アクティビティーはインテントと開始され、それらはデータを完了時に呼び出しているコンポーネントへ戻す可能性があります。すべてのアプリの可視部分はアクティビティーです。</p> <p> エクスポートされた保護されていないアクティビティーは、電話にインストールされた他のアプリによって呼び出される可能性があります。それは XAS (Cross Application Scripting) につながる可能性があります。</p> ,"<p>  もし自分のアプリ間のみで共有のためにアクティビティを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、アクティビティにアクセスするアプリが同じキーでサインされた時にさらに制御されたアプリへのアクセスを提供します。</p> ",,,985b09e3-c677-41a2-aa64-4fe5cb1be3d2,0,TRUE,{1}
43,Android 署名が無いエクスポートされたレシーバ,Androidアプリケーションは、他のアプリケーションによる使用のためにブロードキャストレシーバをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、android:protectionLevelで定義されたカスタムシグネチャを含むデータにアクセスできるかを適切に制限しません。,アプリケーションブロードキャストレシーバは保護レベル無しでエクスポートされていますか？,このアプリ内の Broadcast Receiver は保護レベルで公開されていないか、あるいは実装されていないようです。,<p>   攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。 </p> ,Android 署名無しでエクスポートされたレシーバー,<p> ブロードキャストレシーバは複数のアプリに送られたインテントを受け取ります。 レシーバは適切なインテントの受取がトリガーとなり、イベントのハンドルのためにバックグラウンドで実行されます。レシーバは一般的に short-lived であり、それらは頻繁にメッセージをアクティビティあるいはサービスに伝えます。 ブロードキャストインテントには normal、 sticky、 ordered の３種類があります。 Normal ブロードキャストはすべての登録済みレシーバへ一度に送られ、それから消滅します。Ordered ブロードキャストは一度に一つのレシーバへ運ばれ、また、 ordered ブロードキャストのデリバリーチェーン内のレシーバ はその伝達を停止する可能性があります。ブロードキャストレシーバは ordered ブロードキャストを受け取るための優先レベルの設定が可能です。 Sticky ブロードキャストはそれらが将来のレシーバ に運ばれ、 再ブロードキャストされた後もアクセス可能なままです。</p> <p>エクスポートされたブロードキャストレシーバは電話内にインストールされた他の複数の悪意のあるアプリによってブロードキャストレシーバを呼び出すために呼び出され、 XAS (Cross Application Scripting) につながる可能性があります。 </p>  ,"<p>  もし自分のアプリ間のみで共有のためにブロードキャストレシーバを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたブロードキャストレシーバへのアクセスを提供します。</p>",,,b40aba09-f235-43f3-8773-57bf0ab8c614,0,TRUE,{1}
44,Android 署名が無いエクスポートされたサービス,Androidアプリケーションは、他のアプリケーションによる使用のためにサービスをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、android:protectionLevelで定義されたカスタムシグネチャを含むデータにアクセスできるかを適切に制限しません。,アプリケーションサービスは保護レベル無しでエクスポートされていますか？I,このアプリ内のサービスコンポーネントは保護レベルで公開されていないか、あるいは実装されていないようです。,<p>    攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。</p> ,Android 署名無しでエクスポートされたサービス,<p> サービスはバックグラウンドで実行され、ユーザーとの対話をしません。ファイルのダウンロードあるいはアーカイブの展開は、サービス内で起きる可能性のある操作の例です。 別のコンポーネントはサービスにバインドする可能性があり、それによって、ターゲットサービスインターフェース内で宣言されたメソッドをバインダーに呼び出させます。 インテントはサービスをスタートとバインドするために使用されます。 </p> <p> エクスポートされた保護されていないサービスは、サービスにバインドするために電話内にインストールされた他のアプリによって呼び出される可能性があり、それは XAS (Cross Application Scripting) につながります。  </p> ,"<p>  もし自分のアプリ間のみで共有のためにサービスを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたサービスへのアクセスを提供します。</p> ",,,bc8be8cf-824a-42c0-9f9f-85a2108b808b,0,TRUE,{1}
45,Android 署名が無いエクスポートされたプロバイダ,Androidアプリケーションは、他のアプリケーションによる使用のためにコンテンツプロバイダをエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、android:protectionLevelで定義されたカスタムシグネチャを含むデータにアクセスできるかを適切に制限しません。,アプリケーションコンテントプロバイダは保護レベル無しでエクスポートされていますか？,このアプリ内のコンテントプロバイダは保護レベルで公開されていないか、あるいは実装されていないようです。,<p>     攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用する可能性があります。さらに、アプリのふるまいを変更する可能性があるデータの挿入の可能性があります。 </p> ,Android 署名無しでエクスポートされたプロバイダ,<p>     コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータベースです。それらは持続的内部データストレージと、アプリ間情報の共有のメカニズムとしての両方のために使用されます。</p> <p>  エクスポートされた保護されていないコンテントプロバイダは、コンテントプロバイダ経由でデータを取得するために、電話にインストールされた他の悪意のあるアプリによって呼び出される可能性があります。それは XAS (Cross Application Scripting) につながる可能性があります。 </p> ,"<p>  もし自分のアプリ間のみで共有のためにコンテントプロバイダを使用しているなら、""signature"" 保護にセットされた android: 保護レベル属性の使用が好ましいです。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良いユーザー体験と、データにアクセスするアプリが同じキーでサインされた時にさらに制御されたコンテントプロバイダデータへのアクセスを提供します。</p> <p>   もしコンテントプロバイダがそれ自体の中で呼び出された時は、それをエクスポート、あるいはカスタム権限のインテントフィルタを使用しないでください  </p> ",,,c620b666-bec4-41ab-931b-705f733e74b4,0,TRUE,{1}
46,Android コンテンツプロバイダを介したファイルトラバーサルの脆弱性,コンテンツプロバイダの実装に応じて、このメソッドの使用がディレクトリトラバーサルの脆弱性につながる可能性があります。,あなたのアプリケーションはディレクトリトラバーサル攻撃から守られていますか？,アプリケーションはコンテントプロバイダ経由のディレクトリトラバーサル攻撃に影響されません。,<p>     ディレクトリトラバーサル脆弱性は攻撃者にサンドボックスアプリのコンテキストのエスケープを許し、アプリ・デバイスを構成するローカルファイルの読み書きを許す可能性があります。</p> ,Android コンテントプロバイダを介してのファイルトラバーサルの脆弱性,<p>    コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータベースです。それらは持続的内部データストレージと、アプリ間情報の共有のメカニズムとしての両方のために使用されます。</p> <p> 	 ContentProvider.openFile() メソッドを使用することによって、あなたのアプリのデータ(ファイル)にアクセスする、ある別のアプリのためのファシリティを提供します。コンテントプロバイダの実装によって、メソッドの利用がディレクトリトラバーサルの脆弱性につながる可能性があります。従って、　コンテントプロバイダを通してのファイルを交換する時、パスは使用前に正規化されるべきです。 </p> ,"正規化されたパスの使用によって、二重エンコードされたパスが与えられたときでさえ、ディレクトリトラバーサルは軽減されるでしょう。<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>private</span> <span style='color:#800000; font-weight:bold; '>static</span> String IMAGE_DIRECTORY = localFile.getAbsolutePath()<span style='color:#808030; '>;</span>   <span style='color:#800000; font-weight:bold; '>public</span> ParcelFileDescriptor openFile(Uri paramUri, String paramString) 	  <span style='color:#800000; font-weight:bold; '>throws</span> FileNotFoundException <span style='color:#800080; '>{</span> 	<span style='color:#bb7977; font-weight:bold; '>String</span> decodedUriString <span style='color:#808030; '>=</span> Uri<span style='color:#808030; '>.</span>decode<span style='color:#808030; '>(</span>paramUri<span style='color:#808030; '>.</span>toString<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> 	<span style='color:#bb7977; font-weight:bold; '>File</span> file <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>new</span> <span style='color:#bb7977; font-weight:bold; '>File</span><span style='color:#808030; '>(</span>IMAGE_DIRECTORY<span style='color:#808030; '>,</span> Uri<span style='color:#808030; '>.</span>parse<span style='color:#808030; '>(</span>decodedUriString<span style='color:#808030; '>)</span><span style='color:#808030; '>.</span>getLastPathSegment<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> 	<span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>file<span style='color:#808030; '>.</span>getCanonicalPath<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>.</span>indexOf<span style='color:#808030; '>(</span>localFile<span style='color:#808030; '>.</span>getCanonicalPath<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span> <span style='color:#808030; '>!</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span> 	  <span style='color:#800000; font-weight:bold; '>throw</span> <span style='color:#800000; font-weight:bold; '>new</span> <span style='color:#bb7977; font-weight:bold; '>IllegalArgumentException</span><span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> 	<span style='color:#800080; '>}</span> 	<span style='color:#800000; font-weight:bold; '>return</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>open<span style='color:#808030; '>(</span>file<span style='color:#808030; '>,</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>MODE_READ_ONLY<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>   <span style='color:#800080; '>}</span> </pre>  <br>For example, the following double encoded string will circumvent the fix. <br> <br><code>&nbsp;&nbsp;&nbsp; %252E%252E%252F%252E%252E%252F%252E%252E%252Fdata%252Fdata%252Fcom.example.android.app%252Fshared_prefs%252FExample.xml</code> <br> <br>The first call of <code>Uri.getLastPathSegment()</code> will decode ""%25"" to ""%"" and return the string: <br> <br>&nbsp;<code>&nbsp;&nbsp; %2E%2E%2F%2E%2E%2F%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app%2Fshared_prefs%2FExample.xml</code> <br> <br>When this string is passed to the second Uri.getLastPathSegment(), ""%2E"" and ""%2F"" will be decoded and the result will be: <br> <br>&nbsp;<code>&nbsp;&nbsp; ../../../data/data/com.example.android.app/shared_prefs/Example.xml</code> </p> ","<h4>順守しないコード例 1<h4>  この非順守コード例は最後のセグメントを、 android.net.Uri.getLastPathSegment() を呼び出すことによって、ファイル名を示すことになっている paramUri パスから取り戻そうとしています。そのファイルは事前構成済みの親ディレクトリ IMAGE_DIRECTORY 内でアクセスされます。<pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>private</span> <span style='color:#800000; font-weight:bold; '>static</span> String IMAGE_DIRECTORY = localFile.getAbsolutePath()<span style='color:#808030; '>;</span> <span style='color:#800000; font-weight:bold; '>public</span> ParcelFileDescriptor openFile(Uri paramUri, String paramString) 	<span style='color:#800000; font-weight:bold; '>throws</span> FileNotFoundException <span style='color:#800080; '>{</span>   <span style='color:#bb7977; font-weight:bold; '>File</span> file <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>new</span> <span style='color:#bb7977; font-weight:bold; '>File</span><span style='color:#808030; '>(</span>IMAGE_DIRECTORY<span style='color:#808030; '>,</span> paramUri<span style='color:#808030; '>.</span>getLastPathSegment<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>   <span style='color:#800000; font-weight:bold; '>return</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>open<span style='color:#808030; '>(</span>file<span style='color:#808030; '>,</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>MODE_READ_ONLY<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span> </pre>   <h4>順守しないコード例 2</h4>  この非順守コード例は最初の非順守コード例を Uri.getLastPathSegment() を二回呼び出すことによって修正しようとしています。最初の呼び出しは URL デコーディングのため、二回目の呼び出しは開発者が求めたストリング取得のためです。 <pre style='color:#000000;background:#ffffff;'><span style='color:#800000; font-weight:bold; '>private</span> <span style='color:#800000; font-weight:bold; '>static</span> String IMAGE_DIRECTORY = localFile.getAbsolutePath()<span style='color:#808030; '>;</span> <span style='color:#800000; font-weight:bold; '>public</span> ParcelFileDescriptor openFile(Uri paramUri, String paramString) <span style='color:#800000; font-weight:bold; '>throws</span> FileNotFoundException <span style='color:#800080; '>{</span> 	<span style='color:#bb7977; font-weight:bold; '>File</span> file <span style='color:#808030; '>=</span> <span style='color:#800000; font-weight:bold; '>new</span> <span style='color:#bb7977; font-weight:bold; '>File</span><span style='color:#808030; '>(</span>IMAGE_DIRECTORY<span style='color:#808030; '>,</span> Uri<span style='color:#808030; '>.</span>parse<span style='color:#808030; '>(</span>paramUri<span style='color:#808030; '>.</span>getLastPathSegment<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#808030; '>.</span>getLastPathSegment<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> 	<span style='color:#800000; font-weight:bold; '>return</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>open<span style='color:#808030; '>(</span>file<span style='color:#808030; '>,</span> ParcelFileDescriptor<span style='color:#808030; '>.</span>MODE_READ_ONLY<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span> </pre> ","<ul> 	<li> 		JVN#78601526  GREE for Android vulnerable to directory traversal: <a href=""https://www.securecoding.cert.org/confluence/display/android/DRD08-J.+Always+canonicalize+a+URL+received+by+a+content+provider"">https://www.securecoding.cert.org/confluence/display/android/DRD08-J.+Always+canonicalize+a+URL+received+by+a+content+provider</a> 	</li> </ul>  ",fbe2f4ab-3495-4eec-bb0b-4ba62565342a,0,TRUE,{1}
47,安全でない暗号鍵,アプリケーションは正しい暗号化メソッドを使用しているか、あるいはまったく使用していないようです。,アプリケーションはセキュリティで保護されていない暗号アルゴリズムあるいは暗号構成を使用していますか？,アプリケーションは適切な暗号化メカニズムを使用していないか、あるいは暗号化を実装していないようです。,<p>    セキュリティで保護されていない初期化ベクターの利用は、攻撃者に ciphertext 上で周波数分析の実行を許す可能性があります。 all-zero IV は ciphertext の initial portion が効果的な代用であることを意味しています。 </p> ,セキュリティで保護されていない暗号化キー,"<p>   CCCryptor の使用で、 AES, 3DES のような異なるアルゴリズムと RC4, DES などのようなハードコアセキュリティサイファーを使用して対称的な暗号化を実行するための CCCryptorCreate, CCCryptorUpdate, CCCryptorFinal (あるいは単に CCCrypt() one-shot 機能) のような共通範囲の機能を使用することが出来ます。    </p><p> Apple はそれらのサイファーのための ECB と CBC モードをサポートしており、 API のデフォルトが CBC 、 Cipher Block Chaining モードなので、幸いにも開発者は ECB の使用によって明示的に愚かさを証明する必要があります。どんな間違いが起こる可能性があるのでしょうか？ ""IV"" と呼ばれるいくつかの少数のものがあります。 Apple がその Common Crypto API man-pages を書く際に、たぶん IV という略語を ""Ignorance Vector"" と翻訳しましたが、しかし私たちはサイファーテキストの一番最初のブロックを初期化するために使用される ""Initialization Vector"" を読むべきです。 </p> ","<!-- First and foremost: the key. This is almost always done wrong in the examples you see floating around the Internet. A human-typed password is not an AES key. It has far too little entropy. Using it directly as an AES key opens you up to all kinds of attacks. In particular, lines like this are wrong:  // DO NOT DO THIS NSString *password = @""P4ssW0rd!""; char keyPtr[kCCKeySizeAES128]; [password getCString:keyPtr maxLength:sizeof( keyPtr ) encoding:NSUTF8StringEncoding]; // DO NOT DO THIS This key is susceptible to a variety of attacks. It is neither salted nor stretched. If password is longer than the key size, then the password will be truncated. This is not how you build a key. -->   <p>The mystical initialization vector (IV) is confusing. In CBC-mode, each 16-byte encryption influences the next 16-byte encryption. It's also the default. The problem is  about block 0. It is a random block -1 which is the IV. </p>  <p>This is listed as ""optional"" in CCCrypt() which is confusing because it isn't really optional in CBC mode. If it is not provided, then it'll automatically generate an all-0 IV. That throws away significant protection on the first block. IV is just 16 random bytes.</p>  <p>The method returns the encrypted data (nil for error), and returns the IV, salt and error by reference.</p>  <pre style='color:#000000;background:#ffffff;'>NSData <span style='color:#808030; '>*</span>iv<span style='color:#808030; '>;</span> NSData <span style='color:#808030; '>*</span>salt<span style='color:#808030; '>;</span> NSError <span style='color:#808030; '>*</span><span style='color:#800000; font-weight:bold; '>error</span><span style='color:#808030; '>;</span> NSData <span style='color:#808030; '>*</span>encryptedData <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>RNCryptManager encryptedDataForData<span style='color:#808030; '>:</span>plaintextData                                                     password<span style='color:#808030; '>:</span>password                                                           iv<span style='color:#808030; '>:</span><span style='color:#808030; '>&amp;</span>iv                                                         salt<span style='color:#808030; '>:</span><span style='color:#808030; '>&amp;</span>salt                                                        <span style='color:#800000; font-weight:bold; '>error</span><span style='color:#808030; '>:</span><span style='color:#808030; '>&amp;</span><span style='color:#800000; font-weight:bold; '>error</span><span style='color:#808030; '>]</span><span style='color:#808030; '>;</span> </pre>   <h3> Example Implementation</p>  <pre style='color:#000000;background:#ffffff;'><span style='color:#004a43; '>#</span><span style='color:#004a43; '>import </span><span style='color:#808030; '>&lt;</span><span style='color:#004a43; '>CommonCrypto</span><span style='color:#808030; '>/</span><span style='color:#004a43; '>CommonCryptor</span><span style='color:#808030; '>.</span><span style='color:#004a43; '>h</span><span style='color:#808030; '>></span> <span style='color:#004a43; '>#</span><span style='color:#004a43; '>import </span><span style='color:#808030; '>&lt;</span><span style='color:#004a43; '>CommonCrypto</span><span style='color:#808030; '>/</span><span style='color:#004a43; '>CommonKeyDerivation</span><span style='color:#808030; '>.</span><span style='color:#004a43; '>h</span><span style='color:#808030; '>></span>  NSString <span style='color:#808030; '>*</span> <span style='color:#800000; font-weight:bold; '>const</span> kRNCryptManagerErrorDomain <span style='color:#808030; '>=</span> <span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>net.robnapier.RNCryptManager</span><span style='color:#800000; '>""</span><span style='color:#800080; '>;</span>  <span style='color:#800000; font-weight:bold; '>const</span> CCAlgorithm kAlgorithm <span style='color:#808030; '>=</span> kCCAlgorithmAES128<span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>const</span> NSUInteger kAlgorithmKeySize <span style='color:#808030; '>=</span> kCCKeySizeAES128<span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>const</span> NSUInteger kAlgorithmBlockSize <span style='color:#808030; '>=</span> kCCBlockSizeAES128<span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>const</span> NSUInteger kAlgorithmIVSize <span style='color:#808030; '>=</span> kCCBlockSizeAES128<span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>const</span> NSUInteger kPBKDFSaltSize <span style='color:#808030; '>=</span> <span style='color:#008c00; '>8</span><span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>const</span> NSUInteger kPBKDFRounds <span style='color:#808030; '>=</span> <span style='color:#008c00; '>10000</span><span style='color:#800080; '>;</span>  <span style='color:#696969; '>// ~80ms on an iPhone 4</span>  <span style='color:#696969; '>// ===================</span>  <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>encryptedDataForData<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>data <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;password:</span><span style='color:#808030; '>(</span>NSString <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>password <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;iv:</span><span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>iv <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;salt:</span><span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>salt <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;error:</span><span style='color:#808030; '>(</span>NSError <span style='color:#808030; '>*</span><span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>error <span style='color:#800080; '>{</span>   NSAssert<span style='color:#808030; '>(</span>iv<span style='color:#808030; '>,</span> <span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>IV must not be NULL</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>   NSAssert<span style='color:#808030; '>(</span>salt<span style='color:#808030; '>,</span> <span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>salt must not be NULL</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>    <span style='color:#808030; '>*</span>iv <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>self randomDataOfLength<span style='color:#800080; '>:</span>kAlgorithmIVSize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>   <span style='color:#808030; '>*</span>salt <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>self randomDataOfLength<span style='color:#800080; '>:</span>kPBKDFSaltSize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>    NSData <span style='color:#808030; '>*</span>key <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>self AESKeyForPassword<span style='color:#800080; '>:</span>password salt<span style='color:#800080; '>:</span><span style='color:#808030; '>*</span>salt<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>    <span style='color:#603000; '>size_t</span> outLength<span style='color:#800080; '>;</span>   NSMutableData <span style='color:#808030; '>*</span>   cipherData <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>NSMutableData dataWithLength<span style='color:#800080; '>:</span>data<span style='color:#808030; '>.</span>length <span style='color:#808030; '>+</span>                 kAlgorithmBlockSize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>    CCCryptorStatus   result <span style='color:#808030; '>=</span> CCCrypt<span style='color:#808030; '>(</span>kCCEncrypt<span style='color:#808030; '>,</span> <span style='color:#696969; '>// operation</span>                    kAlgorithm<span style='color:#808030; '>,</span> <span style='color:#696969; '>// Algorithm</span>                    kCCOptionPKCS7Padding<span style='color:#808030; '>,</span> <span style='color:#696969; '>// options</span>                    key<span style='color:#808030; '>.</span>bytes<span style='color:#808030; '>,</span> <span style='color:#696969; '>// key</span>                    key<span style='color:#808030; '>.</span>length<span style='color:#808030; '>,</span> <span style='color:#696969; '>// keylength</span>                    <span style='color:#808030; '>(</span><span style='color:#808030; '>*</span>iv<span style='color:#808030; '>)</span><span style='color:#808030; '>.</span>bytes<span style='color:#808030; '>,</span><span style='color:#696969; '>// iv</span>                    data<span style='color:#808030; '>.</span>bytes<span style='color:#808030; '>,</span> <span style='color:#696969; '>// dataIn</span>                    data<span style='color:#808030; '>.</span>length<span style='color:#808030; '>,</span> <span style='color:#696969; '>// dataInLength,</span>                    cipherData<span style='color:#808030; '>.</span>mutableBytes<span style='color:#808030; '>,</span> <span style='color:#696969; '>// dataOut</span>                    cipherData<span style='color:#808030; '>.</span>length<span style='color:#808030; '>,</span> <span style='color:#696969; '>// dataOutAvailable</span>                    <span style='color:#808030; '>&amp;</span>outLength<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#696969; '>// dataOutMoved</span>    <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>result <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> kCCSuccess<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>     cipherData<span style='color:#808030; '>.</span>length <span style='color:#808030; '>=</span> outLength<span style='color:#800080; '>;</span>   <span style='color:#800080; '>}</span>   <span style='color:#800000; font-weight:bold; '>else</span> <span style='color:#800080; '>{</span>     <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span>error<span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>       <span style='color:#808030; '>*</span>error <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>NSError errorWithDomain<span style='color:#800080; '>:</span>kRNCryptManagerErrorDomain                                    code<span style='color:#800080; '>:</span>result                                userInfo<span style='color:#800080; '>:</span>nil<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     <span style='color:#800080; '>}</span>     <span style='color:#800000; font-weight:bold; '>return</span> nil<span style='color:#800080; '>;</span>   <span style='color:#800080; '>}</span>    <span style='color:#800000; font-weight:bold; '>return</span> cipherData<span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span>  <span style='color:#696969; '>// ===================</span>  <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>randomDataOfLength<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span><span style='color:#603000; '>size_t</span><span style='color:#808030; '>)</span>length <span style='color:#800080; '>{</span>   NSMutableData <span style='color:#808030; '>*</span>data <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>NSMutableData dataWithLength<span style='color:#800080; '>:</span>length<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>    <span style='color:#800000; font-weight:bold; '>int</span> result <span style='color:#808030; '>=</span> SecRandomCopyBytes<span style='color:#808030; '>(</span>kSecRandomDefault<span style='color:#808030; '>,</span>                                   length<span style='color:#808030; '>,</span>                                   data<span style='color:#808030; '>.</span>mutableBytes<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>   NSAssert<span style='color:#808030; '>(</span>result <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>,</span> <span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>Unable to generate random bytes: </span><span style='color:#007997; '>%d</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span>            errno<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>    <span style='color:#800000; font-weight:bold; '>return</span> data<span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span>  <span style='color:#696969; '>// ===================</span>  <span style='color:#696969; '>// Replace this with a 10,000 hash calls if you don't have CCKeyDerivationPBKDF</span> <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>AESKeyForPassword<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSString <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>password <span style='color:#e34adc; '>&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;&#xa0;salt:</span><span style='color:#808030; '>(</span>NSData <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>salt <span style='color:#800080; '>{</span>   NSMutableData <span style='color:#808030; '>*</span>   derivedKey <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>NSMutableData dataWithLength<span style='color:#800080; '>:</span>kAlgorithmKeySize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>    <span style='color:#800000; font-weight:bold; '>int</span>   result <span style='color:#808030; '>=</span> CCKeyDerivationPBKDF<span style='color:#808030; '>(</span>kCCPBKDF2<span style='color:#808030; '>,</span>            <span style='color:#696969; '>// algorithm</span>                                 password<span style='color:#808030; '>.</span>UTF8String<span style='color:#808030; '>,</span>  <span style='color:#696969; '>// password</span>                                 <span style='color:#808030; '>[</span>password lengthOfBytesUsingEncoding<span style='color:#800080; '>:</span>NSUTF8StringEncoding<span style='color:#808030; '>]</span><span style='color:#808030; '>,</span>  <span style='color:#696969; '>// passwordLength</span>                                 salt<span style='color:#808030; '>.</span>bytes<span style='color:#808030; '>,</span>           <span style='color:#696969; '>// salt</span>                                 salt<span style='color:#808030; '>.</span>length<span style='color:#808030; '>,</span>          <span style='color:#696969; '>// saltLen</span>                                 kCCPRFHmacAlgSHA1<span style='color:#808030; '>,</span>    <span style='color:#696969; '>// PRF</span>                                 kPBKDFRounds<span style='color:#808030; '>,</span>         <span style='color:#696969; '>// rounds</span>                                 derivedKey<span style='color:#808030; '>.</span>mutableBytes<span style='color:#808030; '>,</span> <span style='color:#696969; '>// derivedKey</span>                                 derivedKey<span style='color:#808030; '>.</span>length<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#696969; '>// derivedKeyLen</span>    <span style='color:#696969; '>// Do not log password here</span>   NSAssert<span style='color:#808030; '>(</span>result <span style='color:#808030; '>=</span><span style='color:#808030; '>=</span> kCCSuccess<span style='color:#808030; '>,</span>            <span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>Unable to create AES key for password: </span><span style='color:#007997; '>%d</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span> result<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>    <span style='color:#800000; font-weight:bold; '>return</span> derivedKey<span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span> </pre> ",,,95eebd96-1ad1-4cf7-84ef-254f9dda4df3,1,TRUE,{2}
48,iOS SecKeyEncryptの実装,SecKeyEncryptは、iOSの公開鍵からデータを暗号化する方法を決定します。,アプリケーションは適切な SecKeyEncrypt 実装を使用していますか？,アプリケーションは適切な SecKeyEncrypt を使用していないか、あるいはなんの SecKeyEncrypt も実装していない可能性があります。,,iOS SecKeyEncrypt の実装,<p>    ほとんどの時間 iOS はすべての暗号化を処理しています。ネットワークトラフィックのために自動的に HTTPS を暗号化と復号化し、ファイル保護している暗号化ファイルを管理しています。 </p> <p>  しかしカスタム実装の場合、  SecKeyEncrypt と SecKeyDecrypt は呼び出されます。</p> ,,,,b6e7d99e-8979-4eac-bda6-cf6ac91e1c98,1,TRUE,{2}
49,安全でないピア接続,Multipeer Connectivity Frameworkは、近くにあるデバイスとの接続を確立するために使用されます。,アプリケーションは他のデバイスと MultiPeer Framework で安全に通信していますか？,アプリケーションは MultiPeer Framework を使用していないか、あるいは MultiPeer Framework が適切に構成されていないようです,<p>     暗号化チャネル使用の失敗は、送信されたデータの機密性を弱体化させる可能性があります。</p>  ,セキュリティで保護されていない Peer Connections,<p> 	Multi-peer Connectivity Framework はデータあるいは他のリソースと近くのデバイスの交換のタスクを容易にします。  framework はどこでピアとの接続を暗号化された方法で作成することが出来るかの規定を提供します。アプリは、データの機密性を保証するピアとのデータ交換の間に暗号化の特徴を有効にするべきです。</p> ,<p> ピアとの接続を構成する間に、完全なデータが暗号化チャネルで確実に共有されるように、常に	暗号化選択が 'MCEncryptionRequired' として設定されたセッションを初期化してください。</p> ,,,326d5f64-79c1-4f49-9dd9-032422be5b56,1,TRUE,{2}
50,キーチェーンのデータ,iOSのキーチェーンに安全でないデータが保存されています。,アプリケーションはキーチェーンでセキュリティで保護されずにデータを保存していますか？,アプリケーションはキーチェーンで機密情報を保存していません。,<p>    適切な注意を払わないことによって、ログイン資格情報、パスワード、そしてキーチェーンに保存された他の高度に重要なデータの損失につながる可能性があります。</p> ,セキュリティで保護されていないキーチェーンデータ,"<p>iOS はセキュリティで保護されたデータストレージのためのキーチェーンを提供します。　しかし、いくつかのシナリオでは、キーチェーンは侵害され、その後複号化される可能性があります。</p><p>  iOS 7 までの iOS のすべてのバージョンにおいて、もし攻撃者が暗号化された iTunes バックアップにアクセスすれば、キーチェーンは部分的に侵害される可能性があります。 iTunes バックアップ作成時に iOS がキーチェーンエントリーを再暗号化する方法によって、iTunes バックアップが利用可能で、バックアップ暗号化のためのパスワードが知られている時（暗号化されていない iTunes バックアップはキーチェーンアイテムの復号化を許可しないことに注意）、キーチェーンを部分的に復号化することが可能です。 </p><p>  もし ""jailbreak"" がデバイスに適用されたら、キーチェーンアクセスコントロールは無効にされます。この場合、デバイス上で実行しているどんなアプリも他のすべてのアプリのキーチェーンアイテムを読み取る可能性があります。</p><p> 最後に、iPhone 4 のような古いデバイスにとって、そのために ""bootrom exploits"" が存在し、キーチェーンが、攻撃者によるデバイスへの物理的なアクセスによって侵害される可能性があります。 </p> ","<p> たとえデバイスが侵害されても、誰も正しいパスワードを察知できないように、パスワードのような重要データは暗号化されたフォームでデバイスキーチェーン上に保存してください。</p> <p> データをキーチェーンに保存するときは、あなたのアプリが正常に機能することを許可する、最も厳しい保護クラスを使用してください（kSecAttrAccessible attribute によって定義されたように）。例えば、もしあなたのアプリがバックグラウンドで実行するよう設計されていないなら、 kSecAttrAccessibleWhenUnlocked または kSecAttrAccessibleWhenUnlockedThisDeviceOnly を使用してください。</p> <p> キーチェーンアイテムの iTunes バックアップ経由での露出を防ぐために、もし実用的なら...ThisDeviceOnly 保護クラスの一つを使用してください。</p> <p> 最後に、高度に重要なデータのためにキーチェーンによって提供されるアプリレベルの暗号化での保護の増量を考えてください。例えば、ユーザーをアプリ内での認証のためのパスフレーズに入るようにし、キーチェーンにそれを保存する前にパスフレーズを使いデータを暗号化してください。</p> 実装例：  <pre style='color:#000000;background:#ffffff;'><span style='color:#004a43; '>#</span><span style='color:#004a43; '>define</span><span style='color:#004a43; '> SALT_HASH </span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>FvTivqTqZXsgLLx1v3P8TGRyVHaSOB1pvfm02wvGadj7RLHV8GrfxaZ84oGA8RsKdNRpxdAojXYg9iAj</span><span style='color:#800000; '>""</span>  <span style='color:#808030; '>+</span> <span style='color:#808030; '>(</span>NSString <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>securedSHA256DigestHashForPIN<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>NSUInteger<span style='color:#808030; '>)</span>pinHash <span style='color:#800080; '>{</span>     <span style='color:#696969; '>// 1</span>     NSString <span style='color:#808030; '>*</span>name <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>NSUserDefaults standardUserDefaults<span style='color:#808030; '>]</span> stringForKey<span style='color:#800080; '>:</span>USERNAME<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     name <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>name stringByAddingPercentEscapesUsingEncoding<span style='color:#800080; '>:</span>NSUTF8StringEncoding<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     <span style='color:#696969; '>// 2</span>     NSString <span style='color:#808030; '>*</span>computedHashString <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>NSString stringWithFormat<span style='color:#800080; '>:</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>%@</span><span style='color:#007997; '>%i</span><span style='color:#0000e6; '>%@</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span> name<span style='color:#808030; '>,</span> pinHash<span style='color:#808030; '>,</span> SALT_HASH<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     <span style='color:#696969; '>// 3</span>     NSString <span style='color:#808030; '>*</span>finalHash <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>self computeSHA256DigestForString<span style='color:#800080; '>:</span>computedHashString<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>** Computed hash: %@ for SHA256 Digest: %@</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span> computedHashString<span style='color:#808030; '>,</span> finalHash<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>     <span style='color:#800000; font-weight:bold; '>return</span> finalHash<span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span> NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>User entered PIN</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>[</span>textField<span style='color:#808030; '>.</span>text length<span style='color:#808030; '>]</span> <span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>     NSUInteger fieldHash <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>textField<span style='color:#808030; '>.</span>text hash<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     <span style='color:#696969; '>// 4</span>     NSString <span style='color:#808030; '>*</span>fieldString <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>KeychainWrapper securedSHA256DigestHashForPIN<span style='color:#800080; '>:</span>fieldHash<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>     NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>** Password Hash - %@</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span> fieldString<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>     <span style='color:#696969; '>// Save PIN hash to the keychain (NEVER store the direct PIN)</span>     <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>[</span>KeychainWrapper createKeychainValue<span style='color:#800080; '>:</span>fieldString forIdentifier<span style='color:#800080; '>:</span>PIN_SAVED<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>         <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>NSUserDefaults standardUserDefaults<span style='color:#808030; '>]</span> setBool<span style='color:#800080; '>:</span>YES forKey<span style='color:#800080; '>:</span>PIN_SAVED<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>         <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>NSUserDefaults standardUserDefaults<span style='color:#808030; '>]</span> synchronize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>         NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>** Key saved successfully to Keychain!!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>     <span style='color:#800080; '>}</span> <span style='color:#800080; '>}</span> </pre> "," OWASP Mobile Top 10 の M8 に非準拠  - Side Channel Data Leakage  ピンコードがセキュリティで保護されず保存されるキーチェーン実装例：  <pre style='color:#000000;background:#ffffff;'>NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>User entered PIN</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span> <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>[</span>textField<span style='color:#808030; '>.</span>text length<span style='color:#808030; '>]</span> <span style='color:#808030; '>></span> <span style='color:#008c00; '>0</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>     NSUInteger fieldHash <span style='color:#808030; '>=</span> <span style='color:#808030; '>[</span>textField<span style='color:#808030; '>.</span>text hash<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>      NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>** Password Is - %@</span><span style='color:#800000; '>""</span><span style='color:#808030; '>,</span> fieldString<span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>      <span style='color:#696969; '>// Save PIN  to the keychain (NEVER store the direct PIN)</span>     <span style='color:#800000; font-weight:bold; '>if</span> <span style='color:#808030; '>(</span><span style='color:#808030; '>[</span>KeychainWrapper createKeychainValue<span style='color:#800080; '>:</span>fieldString forIdentifier<span style='color:#800080; '>:</span>PIN_SAVED<span style='color:#808030; '>]</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>{</span>         <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>NSUserDefaults standardUserDefaults<span style='color:#808030; '>]</span> setBool<span style='color:#800080; '>:</span>YES forKey<span style='color:#800080; '>:</span>PIN_SAVED<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>         <span style='color:#808030; '>[</span><span style='color:#808030; '>[</span>NSUserDefaults standardUserDefaults<span style='color:#808030; '>]</span> synchronize<span style='color:#808030; '>]</span><span style='color:#800080; '>;</span>         NSLog<span style='color:#808030; '>(</span><span style='color:#808030; '>@</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>** Key saved successfully to Keychain!!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span><span style='color:#800080; '>;</span>     <span style='color:#800080; '>}</span> <span style='color:#800080; '>}</span> </pre> ","<ul><li><a href=""https://developer.apple.com/library/ios/documentation/security/Conceptual/keychainServConcepts/01introduction/introduction.html#//apple_ref/doc/uid/TP30000897"">Keychain Services Programming Guide</a></li> <li><a href=""https://www.owasp.org/index.php/Mobile_Top_10_2014-M2"">M2 - Insecure Data Storage</a></li> <li><a href=""https://www.owasp.org/index.php/Mobile_Top_10_2014-M5"">M5 - Poor Authorization and Authentication</a></li> </ul> ",33436b1a-32e7-4d30-a52e-f0f35784ee89,1,TRUE,"{2,3}"
51,公開されたペーストボードデータ,パスワードのような重要なデータを他のアプリケーションが使用できるペーストボード/クリップボード内に公開。,アプリケーションは重要なフィールドでコピー・ペースト機能を許可していますか？,アプリケーションは一般的なペーストボードからの保護を要求していないか、あるいは適切に保護されていません。,<p>     適切な注意を払わないことによって、ログイン資格情報、パスワード、そしてクリップボードに保存された他の高度に重要なデータの損失につながる可能性があります。 </p> ,セキュリティで保護されていないペーストボードデータ,<p> iOS と Android の両方がコピー・ペーストをサポートしています。データのソースが最初に暗号化されているかどうかに関わらず、重要なデータは保存され、回復可能、あるいは平文でクリップボードから修正が可能かもしれません。もしユーザーがそれをコピーする時にそれがプレーンテキストなら、それは他のアプリがクリップボードにアクセスする時、プレーンテキストになるでしょう。 </p> ,"<p>特定のペーストボードアプリを使用してください。また、データが絶対にコピーされないよう保護されたパスワードのようなフィールドをマークしてください。 </p> <p>ペーストボードはパブリックあるいはプライベートになり得ます。 パブリックペーストボードはシステムペーストボードと呼ばれます。 プライベートペーストボードはアプリによって作成され、そのためアプリペーストボードと呼ばれます。ペーストボードはユニークな名前を持つ必要があります。UIPasteboard defines two system pasteboards, each with its own name and purpose: </p> <ul> <li>UIPasteboardNameGeneral is for cut, copy, and paste operations involving a wide range of data types. You can obtain a singleton object representing the General pasteboard by invoking the generalPasteboard class method.</li> <li>UIPasteboardNameFind is for search operations. The string currently typed by the user in the search bar (UISearchBar) is written to this pasteboard, and thus can be shared between apps. You can obtain an object representing the Find pasteboard by calling the pasteboardWithName:create: class method, passing in UIPasteboardNameFind for the name.</li> </ul> <p>Typically you use one of the system-defined pasteboards, but if necessary you can create your own app pasteboard using pasteboardWithName:create: If you invoke pasteboardWithUniqueName, UIPasteboard gives you a uniquely-named app pasteboard. You can discover the name of a pasteboard through its name property</p>  <p>Clear the Pasteboard once the application enters background. You can do this by adding the following line in the method - (void)applicationDidEnterBackground:(UIApplication *)application in AppDelegate. If you are using a custom Pasteboard, replace [UIPasteboard generalPasteboard] with your custom pasteboard.</p> <pre style='color:#000000;background:#ffffff;'>- <span style='color:#808030; '>(</span><span style='color:#800000; font-weight:bold; '>void</span><span style='color:#808030; '>)</span>applicationDidEnterBackground<span style='color:#800080; '>:</span><span style='color:#808030; '>(</span>UIApplication <span style='color:#808030; '>*</span><span style='color:#808030; '>)</span>application <span style='color:#800080; '>{</span> <span style='color:#696969; '>// Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.</span> <span style='color:#696969; '>// If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.</span> <span style='color:#808030; '>[</span>UIPasteboard generalPasteboard<span style='color:#808030; '>]</span><span style='color:#808030; '>.</span>items <span style='color:#808030; '>=</span> nil<span style='color:#800080; '>;</span> <span style='color:#800080; '>}</span> </pre> ","OWASP Mobile Top 10 の M8 に非準拠 - Side Channel Data Leakage  一般的なペーストボード実装は次のようにみえます <pre style='color:#000000;background:#ffffff;'><span style='color:#696969; '>// Setup, let's put some stuff in the UIPasteboard</span>  let pasteboard <span style='color:#808030; '>=</span> UIPasteboard<span style='color:#808030; '>.</span>general<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> pasteboard<span style='color:#808030; '>.</span>string <span style='color:#808030; '>=</span> <span style='color:#800000; '>""</span><span style='color:#0000e6; '>andy</span><span style='color:#800000; '>""</span> pasteboard<span style='color:#808030; '>.</span>url <span style='color:#808030; '>=</span> URL<span style='color:#808030; '>(</span>string<span style='color:#800080; '>:</span> <span style='color:#800000; '>""</span><span style='color:#0000e6; '>http://cleanswifter.com</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span> pasteboard<span style='color:#808030; '>.</span>image <span style='color:#808030; '>=</span> UIImage<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span> pasteboard<span style='color:#808030; '>.</span>color <span style='color:#808030; '>=</span> UIColor<span style='color:#808030; '>.</span>red<span style='color:#808030; '>(</span><span style='color:#808030; '>)</span>  <span style='color:#696969; '>// Understanding the UIPasteboard contents</span>  <span style='color:#800000; font-weight:bold; '>if</span> pasteboard<span style='color:#808030; '>.</span>hasStrings <span style='color:#800080; '>{</span>     print<span style='color:#808030; '>(</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>The pasteboard has Strings!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>if</span> pasteboard<span style='color:#808030; '>.</span>hasURLs <span style='color:#800080; '>{</span>     print<span style='color:#808030; '>(</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>The pasteboard has URLs!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>if</span> pasteboard<span style='color:#808030; '>.</span>hasImages <span style='color:#800080; '>{</span>     print<span style='color:#808030; '>(</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>The pasteboard has images!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>}</span> <span style='color:#800000; font-weight:bold; '>if</span> pasteboard<span style='color:#808030; '>.</span>hasColors <span style='color:#800080; '>{</span>     print<span style='color:#808030; '>(</span><span style='color:#800000; '>""</span><span style='color:#0000e6; '>The pasteboard has colors!</span><span style='color:#800000; '>""</span><span style='color:#808030; '>)</span> <span style='color:#800080; '>}</span> </pre> ","<ul>     <li><a href=""https://jvn.jp/en/jp/JVN76662040/"">JVN#76662040</a> - Clipboard contents alteration vulnerability in Grani</li>     <li><a href=""http://jvn.jp/en/jp/JVN64764004/index.html"">JVN#64764004</a>Clipboard contents alteration vulnerability in Sleipnir</li> </ul> ",c462577f-b92b-48f6-a492-8a71ad986adb,1,TRUE,{3}
52,バッファのオーバーフローとアンダーフロー,スタック上およびヒープ上のバッファオーバーフローは、C、Objective-C、およびC++のコードのセキュリティ脆弱性の主要な原因です。 ,アプリケーションに脆弱性関連のバッファオーバーフローあるいはアンダーフローがありますか？,アプリケーションはバッファオーバーフローあるいはアンダーフロー無しで適切にコンパイルされたようです。,,バッファオーバーフローとアンダーフロー,"<p>iOS はアプリがランタイムで危害を受けることを防ぐ、いくつかのメカニズムを持っています。 iOS アプリに影響を与えるセキュリティ問題を理解するために、プラットフォームのセキュリティの特徴を理解することが重要です。 iOS の主なセキュリティの特徴は、(<a href=""http://www.apple.com/ipad/business/docs/iOS_Security_Feb14.pdf"">http://www.apple.com/ipad/business/docs/iOS_Security_Feb14.pdf</a>) are:</p> <ul>     <li>         <p><strong>Code signing</strong></p>         <ul>             <li>Ensures that all applications come from a approved source (using Apple-issued certificates)</li>         </ul>     </li>     <li>         <p><strong>Generic exploit mitigations</strong></p>         <ul>             <li>Address Space Layout Randomization (<a href="""" http://en.wikipedia.org/wiki/Address_space_layout_randomization """">ASLR</a>)                 <ul>                     <li>Usually compiled using <code>-fPIE -pie</code></li>                 </ul>             </li>             <li>Non Executable Memory (<a href="""" http://en.wikipedia.org/wiki/Address_space_layout_randomization """">ARM's Execute Never</a> feature)</li>             <li>Stack Smashing Protections (<a href="""" http://wiki.osdev.org/Stack_Smashing_Protector """">SSP</a>)                 <ul>                     <li>Usually compiled with <code>-fstack-protector-all</code> flag</li>                 </ul>             </li>         </ul>     </li>     <li>         <p><strong>Sandboxing</strong></p>         <ul>             <li>run applications as non-privileged user</li>             <li>3rd-party apps are restricted in accessing files stored by other apps</li>         </ul>     </li>     <li>         <p><strong>Memory Management</strong></p>         <ul>             <li>Automatic Reference Counting (<a href="""" https://developer.apple.com/library/ios/releasenotes/objectivec/rn-transitioningtoarc/Introduction/Introduction.html """">ARC</a>) protects applications from memory coruption issues by letting the compiler                 do the memory management stuff</li>         </ul>     </li> </ul> ","<p>通常、 <code>ipa</code> ファイルはランタイム時にカーネルの mach loader によって復号化されます。もしバイナリが暗号化あるいは otool を使用しているのが容易に分からない場合</p> <p>バイナリが暗号化されている場所の一例：</p> <pre># otool -l OTHER_BINARY | grep -A 4 LC_ENCRYPTION_INFO        cmd LC_ENCRYPTION_INFO    cmdsize 20   cryptoff 16384  cryptsize 10502144  cryptid   1 </pre>  <ul>     <li><strong>ASLR</strong>         <ul>             <li>通常バイナリは <code>PIE</code> flag を使用してコンパイルされます</li>         </ul>     </li> </ul>  <ul>     <li><strong>Stack Smashing Protection</strong>         <ul>             <li>iOS アプリが通常使用するのは <a href="""" http://en.wikipedia.org/wiki/Stack_buffer_overflow#Stack_canaries """"><strong>stack canaries</strong></a></li>             <li>そのためバイナリ内で次のようなシンボルを見つけてください ( <code>_stack_chk_guard</code> and <code>_stack_chk_fail</code>)</li>         </ul>     </li> </ul>  <ul>     <li><strong>Automatic Reference Couting</strong>         <ul>             <li>このオプションは次のコンパイラオプションによって有効化される可能性があります。 """"Objective-C Automatic Reference Counting""""</li>             <li>このオプションでビルドされたバイナリは次のように呼ばれるシンボルを含むべきです <code>_objc_release</code>, <code>_obj_autorelease</code>, <code>_obj_storeStrong</code>, <code>_obj_retain</code></li>         </ul>     </li> </ul> ",,"<ul>     <li><a href=""https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/Articles/BufferOverflows.html""> Apple による バッファオーバーフローとアンダーフローの回避</a></li>     <li><a href=""http://books.google.de/books?id=huy8AwAAQBAJ&amp;printsec=frontcover#v=onepage&amp;q&amp;f=false"">Hacking and Securing iOS Applications</a></li> </ul> ",6e9d4b00-d39b-4dff-8555-ce181a233008,1,TRUE,{3}
