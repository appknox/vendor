msgid ""
msgstr ""
"Project-Id-Version: Appknox\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-08-03 10:34+0000\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: POEditor.com\n"

#: owasp.py:8
msgid "Improper Platform Usage"
msgstr "不適切なプラットフォームの使用"

#: owasp.py:16
msgid "Insecure Data Storage"
msgstr "安全でないデータストレージ"

#: owasp.py:24
msgid "Insecure Communication"
msgstr "安全でないコミュニケーション"

#: owasp.py:32
msgid "Insecure Authentication"
msgstr "安全でない認証"

#: owasp.py:40
msgid "Insufficient Cryptography"
msgstr "安全でない暗号化"

#: owasp.py:48
msgid "Insecure Authorization"
msgstr "安全でない承認"

#: owasp.py:56
msgid "Client Code Quality"
msgstr "クライアントコードの品質"

#: owasp.py:64
msgid "Code Tampering"
msgstr "コード改ざん"

#: owasp.py:72
msgid "Reverse Engineering"
msgstr "リバースエンジニアリング"

#: owasp.py:80
msgid "Extraneous Functionality"
msgstr "無関係な機能"

#: owasp.py:88
msgid "Injection"
msgstr "インジェクション"

#: owasp.py:96
msgid "Broken Authentication and Session Management"
msgstr "壊れた認証とセッション管理"

#: owasp.py:104
msgid "Cross Site Scripting"
msgstr "クロスサイトスクリプティング"

#: owasp.py:112
msgid "Insecure Direct Object References"
msgstr "安全でない直接オブジェクト参照"

#: owasp.py:120
msgid "Security Misconfiguration"
msgstr "セキュリティの誤設定"

#: owasp.py:128
msgid "Sensitive Data Exposure"
msgstr "機密データの暴露"

#: owasp.py:136
msgid "Missing Function Level Access Control"
msgstr "機能レベルのアクセス制御の欠如"

#: owasp.py:144
msgid "Cross-Site Request Forgery (CSRF)"
msgstr "クロスサイトリクエストフォージェリ（CSRF）"

#: owasp.py:152
msgid "Using Components with Known Vulnerabilities"
msgstr "既知の脆弱性を持つコンポーネントの使用"

#: owasp.py:160
msgid "Unvalidated Redirects and Forwards"
msgstr "未確認のリダイレクトと転送"

#: pcidss.py:7
msgid ""
"Install and maintain a firewall and router configuration to "
"protectcardholder data"
msgstr ""
"カード会員データを保護するために、ファイアウォールとルーター設定をインストー"
"ルして構成を維持する。"

#: pcidss.py:13
msgid ""
"Establish firewall and router configuration standards that formalize testing "
"whenever configurations change; that identify all connections to cardholder "
"data (including wireless); that use various technical settings for each "
"implementation; and stipulate a review of configuration rule sets at least "
"every six months."
msgstr ""
"ファイアウォールとルータの設定基準を確立し、設定が変更されるたびにテスト実施"
"を形式化する。\n"
"カード会員データ（ワイヤレス含む）へのすべての接続を識別する。\n"
"各実装にさまざまな技術設定を使用する。 \n"
"少なくとも6ヵ月ごとに構成ルールセットのレビューを規定する。"

#: pcidss.py:22 pcidss.py:35 pcidss.py:47
msgid ""
"Install and maintain a firewall and router configuration to protect "
"cardholder data"
msgstr ""
"カード会員データを保護するために、ファイアウォールとルーター設定をインストー"
"ルして構成を維持する。"

#: pcidss.py:28
msgid ""
"Build firewall and router configurations that restrict all traffic from "
"untrusted networks and hosts, except for protocols necessary for the "
"cardholder data environment."
msgstr ""
"カード会員データが存在する環境に必要なプロトコルを除き、信頼できないネット"
"ワークやホストからのすべてのトラフィックを制限するファイアウォールとルーター"
"の構成を構築する。"

#: pcidss.py:41
msgid ""
"Prohibit direct public access between the Internet and any system component "
"in the cardholder data environment."
msgstr ""
"カード会員データが存在する環境において、インターネットとシステムコンポーネン"
"トとの間の直接的なパブリックアクセスの禁止する。"

#: pcidss.py:53
msgid ""
"Install personal firewall software on any mobile and/or employee-owned "
"computers with direct connectivity to the Internet that are used to access "
"the organization's network"
msgstr ""
"組織のネットワークにアクセスするためにインターネットに直接接続している、モバ"
"イルおよび/または従業員が所有するコンピュータに、パーソナルファイアウォールの"
"ソフトウェアをインストールする。"

#: pcidss.py:60 pcidss.py:74 pcidss.py:88 pcidss.py:100
msgid ""
"Do not use vendor-supplied defaults for system passwords and other security "
"parameters"
msgstr ""
"ベンダーから提供されたままの規定値をシステムパスワードやその他のセキュリティ"
"パラメータに使用しない。"

#: pcidss.py:66
msgid ""
"Always change vendor-supplied defaults before installing a system on the "
"network. This includes wireless devices that are connected to the cardholder "
"data environment or are used to transmit cardholder data"
msgstr ""
"ネットワークにシステムをインストールする前に、ベンダー提供の既定値を変更す"
"る。 これには、カード会員データ環境に接続されているか、カード会員データを送信"
"するために使用される無線デバイスが含まれる。"

#: pcidss.py:80
msgid ""
"Develop configuration standards for all system components that address all "
"known security vulnerabilities and are consistent with industry-accepted "
"definitions. Update system configuration standards as new vulnerability "
"issues are identified."
msgstr ""
"すべての既知のセキュリティ上の脆弱性に対処し、業界で受け入れられている定義と"
"一致するすべてのシステムコンポーネントの構成基準を作成する。 新しい脆弱性の問"
"題が特定されるとシステム構成標準を更新する。"

#: pcidss.py:94
msgid ""
"Encrypt using strong cryptography all non-console administrative access such "
"as browser/web- based management tools"
msgstr ""
"強力な暗号化を使用して、ブラウザ/ Webベースの管理ツールなどコンソール以外の管"
"理アクセスをすべて暗号化する。"

#: pcidss.py:106
msgid ""
"Shared hosting providers must protect each entity's hosted environment and "
"cardholder data (details are in PCI DSS Appendix A: Additional PCI DSS "
"Requirements for Shared Hosting Providers.)"
msgstr ""
"共有ホスティングプロバイダは、各エンティティのホスト環境およびカード会員デー"
"タを保護する必要がある（詳細はPCI DSS Appendix A：共有ホスティングプロバイダ"
"の追加PCI DSS要件を参照してください）。"

#: pcidss.py:112 pcidss.py:123 pcidss.py:134 pcidss.py:146 pcidss.py:160
#: pcidss.py:169
msgid "Protect stored cardholder data"
msgstr "保存されたカード会員データを保護する"

#: pcidss.py:116
msgid ""
"Limit cardholder data storage and retention time to that required for "
"business, legal, and/or regulatory purposes, as documented in your data "
"retention policy. Purge unnecessary stored data at least quarterly."
msgstr ""
"データ保持ポリシーに文書化されているように、カード会員データ保管および保管期"
"間をビジネス、法的および/または規制目的に必要なものに制限する。 少なくとも四"
"半期ごとに不要な格納データをパージする。"

#: pcidss.py:127
msgid ""
"Do not store sensitive authentication data after authorization (even if it "
"is encrypted). See guidelines in table below. Issuers and related entities "
"may store sensitive authentication data if there is a business "
"justification, and the data is stored securely."
msgstr ""
"暗号化されている場合でも、認証後に機密性の高い認証データを保存しない。 下記の"
"ガイドラインを参照してください。 ビジネス上の正当性があり、データが安全に保管"
"されている場合、発行者および関連するエンティティは機密性の高い認証データを格"
"納することがあります。"

#: pcidss.py:138
msgid ""
"Mask PAN when displayed; the first six and last four digits are the maximum "
"number of digits you may display. Not applicable for authorized people with "
"a legitimate business need to see the full PAN. Does not supersede stricter "
"requirements in place for displays of cardholder data such as on a point-of-"
"sale receipt."
msgstr ""
"表示時に PAN をマスクして（先頭 6桁と末尾 4 桁が最大表示桁数）、業務上\n"
"の正当な理由がある関係者だけが先頭 6桁/末尾 4 桁を超える PAN を見ることが\n"
"できるようにする。 カード会員データの表示（法律上、またはペイメントカードブラ"
"ンドによるPOS レシート要件など）に関するこれより厳しい要件がある場合は、その"
"要件より優先されることはありません。"

#: pcidss.py:150
msgid ""
"Render PAN unreadable anywhere it is stored including on portable digital "
"media, backup media, in logs, and data received from or stored by wireless "
"networks. Technology solutions for this requirement may include strong one-"
"way hash functions of the entire PAN, truncation, index tokens with securely "
"stored pads, or strong cryptography. (See PCI DSS Glossary for definition of "
"strong cryptography.)"
msgstr ""
"ポータブルデジタルメディア、バックアップメディア、ログ、無線ネットワークから"
"受信または格納されたデータなど、格納されている場所がどこであっても、PANを読み"
"取ることはできません。 この要件のための技術ソリューションには、PAN全体の強固"
"な一方向ハッシュ関数、トランケーション、インデックストークンと適切に保管され"
"たパッド、または強力な暗号化が含まれます。 （強力な暗号化の定義については、"
"「PCI DSS用語集」を参照してください）。"

#: pcidss.py:164
msgid ""
"Protect any keys used for encryption of cardholder data from disclosure and "
"misuse"
msgstr "カード会員データの暗号化に使用される鍵を漏洩や不正使用から保護する"

#: pcidss.py:173
msgid ""
"Fully document and implement all appropriate key management processes and "
"procedures for cryptographic keys used for encryption of cardholder data"
msgstr ""
"カード会員データの暗号化に使用される暗号化鍵の管理プロセスおよび手順\n"
"をすべて文書化し、実装する。"

#: pcidss.py:180 pcidss.py:198
msgid "Encrypt transmission of cardholder data across open, public networks"
msgstr "公共ネットワーク経由でのカード会員データの送信を暗号化する"

#: pcidss.py:185
msgid ""
"Use strong cryptography and security protocols such as SSL/TLS, SSH or IPSec "
"to safeguard sensitive cardholder data during transmission over open, public "
"networks (e.g. Internet, wireless technologies, Global System for Mobile "
"communications [GSM], General Packet Radio Service [GPRS]). Ensure wireless "
"networks transmitting cardholder data or connected to the cardholder data "
"environment use industry best practices (e.g., IEEE 802.11i) to implement "
"strong encryption for authentication and transmission. The use of WEP as a "
"security control is prohibited"
msgstr ""
"公共ネットワーク（インターネット、無線技術、グローバル移動体通信システム"
"[GSM]、汎用パケット無線サービス[GPRS]など）を介した送信中に、SSL / TLS、SSH、"
"IPSecなどの強力な暗号化プロトコルとセキュリティプロトコルを使用して、機密性の"
"高いカード会員データを保護する。またはカード会員データの環境に接続されたワイ"
"ヤレスネットワークが業界のベストプラクティス（IEEE 802.11iなど）を使用して、"
"認証と送信のための強力な暗号化を実装する。 セキュリティ管理としてのWEPは使用"
"しない。"

#: pcidss.py:203
msgid "Never send unprotected PANs by end user messaging technologies"
msgstr ""
"保護されていない PAN をエンドユーザメッセージングテクノロジで送信しない。"

#: pcidss.py:207 pcidss.py:216
msgid "Use and regularly update anti-virus software or programs"
msgstr "アンチウイルスソフトウェアまたはプログラムを使用し、定期的に更新する。"

#: pcidss.py:211
msgid ""
"Deploy anti-virus software on all systems affected by malicious software "
"(particularly personal computers and servers)"
msgstr ""
"悪意のあるソフトウェア（特にパーソナルコンピュータやサーバー）の影響を受ける"
"すべてのシステムにアンチウイルスソフトウェアを導入する。"

#: pcidss.py:220
msgid ""
"Ensure that all anti-virus mechanisms are current, actively running, and "
"generating audit logs"
msgstr ""
"すべてのウイルス対策メカニズムが最新であり、実行中であり、監査ログが生成され"
"ていることを確認する。"

#: pcidss.py:225 pcidss.py:235 pcidss.py:245 pcidss.py:256 pcidss.py:265
#: pcidss.py:276
msgid "Develop and maintain secure systems and applications"
msgstr "安全なシステムとアプリケーションの開発と維持"

#: pcidss.py:229
msgid ""
"Ensure that all system components and software are protected from known "
"vulnerabilities by having the latest vendor-supplied security patches "
"installed. Deploy critical patches within a month of release"
msgstr ""
"すべてのシステムコンポーネントとソフトウェアに、ベンダ提供のセキュリ\n"
"ティパッチがインストールされ、既知の脆弱性から保護されている。重要なセ\n"
"キュリティパッチは、リリース後 1 カ月以内にインストールする。"

#: pcidss.py:239
msgid ""
"Establish a process to identify and assign a risk ranking to newly "
"discovered security vulnerabilities. Risk rankings should be based on "
"industry best practices and guidelines."
msgstr ""
"セキュリティの脆弱性を特定し、新たに発見されたセキュリティの脆弱性にリスクの"
"ランクを割り当てるプロセスを確立する。リスクのランク分けは、業界のベストプラ"
"クティスとガイドラインに基づいている必要があります。"

#: pcidss.py:249
msgid ""
"Develop software applications (internal and external, and including web-"
"based administrative access) in accordance with PCI DSS and based on "
"industry best practices. Incorporate information security throughout the "
"software development life cycle."
msgstr ""
"PCI DSSに従い、業界のベストプラクティスに基づいて、ソフトウェアアプリケーショ"
"ンを開発する（内部および外部、Webベースの管理アクセスを含む）。ソフトウェア開"
"発ライフサイクル全体に情報セキュリティを組み込む。"

#: pcidss.py:260
msgid ""
"Follow change control processes and procedures for all changes to system "
"components"
msgstr ""
"システムコンポーネントのすべての変更について、変更管理のプロセスと手順に従"
"う。"

#: pcidss.py:269
msgid ""
"Develop applications based on secure coding guidelines and review custom "
"application code to identify coding vulnerabilities. Follow up-to-date "
"industry best practices to identify and manage vulnerabilities."
msgstr ""
"安全なコーディングガイドラインに基づいてアプリケーションを開発し、カスタムア"
"プリケーションコードをレビューしてコーディングの脆弱性を特定する。最新の業界"
"ベストプラクティスに従い、脆弱性を識別して管理する。"

#: pcidss.py:280
msgid ""
"Ensure all public-facing web applications are protected against known "
"attacks, either by performing code vulnerability reviews at least annually "
"or by installing a web application firewall in front of public-facing web "
"applications"
msgstr ""
"少なくとも毎年、コード脆弱性のレビューを実施するか、一般公開前にWebアプリケー"
"ションファイアウォールをインストールすることによって、公開されているすべての"
"Webアプリケーションが既知の攻撃から保護されていることを確実に\n"
"する。"

#: pcidss.py:287 pcidss.py:296
msgid "Restrict access to cardholder data by business need to know"
msgstr "カード会員データへのアクセスを、業務上必要な範囲内に制限する。"

#: pcidss.py:291
msgid ""
"Limit access to system components and cardholder data to only those "
"individuals whose job requires such access."
msgstr ""
"システムコンポーネントおよびカード会員データへのアクセスを業務上必要な\n"
"人に限定する。"

#: pcidss.py:300
msgid ""
"Establish an access control system for systems components with multiple "
"users that restricts access based on a user's need to know, and is set to "
"deny all unless specifically allowed"
msgstr ""
"システムコンポーネントで、ユーザの必要性に基づいてアクセスが制限さ\n"
"れ、特に許可のない場合は「すべてを拒否」に設定された、アクセス制御システ\n"
"ムを確立する。"

#: pcidss.py:306 pcidss.py:315 pcidss.py:326 pcidss.py:340 pcidss.py:349
msgid "Assign a unique ID to each person with computer access"
msgstr "コンピュータへのアクセスが可能な各ユーザに一意のIDを割り当てる。"

#: pcidss.py:310
msgid ""
"Assign all users a unique user name before allowing them to access system "
"components or cardholder data."
msgstr ""
"すべてのユーザーにシステムコンポーネントまたはカード会員データへのアクセスを"
"許可する前に、一意のユーザー名を割り当てる。"

#: pcidss.py:319
msgid ""
"Employ at least one of these to authenticate all users: something you know, "
"such as a password or passphrase; something you have, such as a token device "
"or smart card; or something you are, such as a biometric"
msgstr ""
"すべてのユーザーを認証するには、パスワードやパスフレーズなど、あなたが知って"
"いるものを少なくとも1つ使用します。トークンデバイスやスマートカードなど、あな"
"たの所有物や生体認証などです。"

#: pcidss.py:330
msgid ""
"Implement two-factor authentication for remote access to the network by "
"employees, administrators, and third parties. For example, use technologies "
"such as remote authentication and dialin service (RADIUS) with tokens; "
"terminal access controller access control system (TACACS) with tokens; or "
"other technologies that facilitate two-factor authentication. Using one "
"factor twice (e.g. using two separate passwords) is not considered two-"
"factor authentication"
msgstr ""
"従業員、管理者、および第三者によるネットワークへのリモートアクセス用の二要素"
"認証を実装します。たとえば、リモート認証やダイヤルインサービス（RADIUS）など"
"の技術をトークンとともに使用する。トークンを持つ端末アクセスコントローラのア"
"クセス制御システム（TACACS）または二要素認証を容易にする他の技術などを用い"
"る。1 つの要素を 2 回使用すること（例えば、2 つの個別パスワードを使用する）"
"は、多要素認証とは見なされない。"

#: pcidss.py:344
msgid ""
"Render all passwords unreadable during storage and transmission, for all "
"system components, by using strong cryptography."
msgstr ""
"強力な暗号化を使用して、すべてのシステムコンポーネントについて、保存中および"
"送信中に認証情報（パスワード）をすべて読み取り不能とする。"

#: pcidss.py:353
msgid ""
"Ensure proper user identification and authentication management for non-"
"consumer users and administrators on all system components"
msgstr ""
"すべてのシステムコンポーネントで、非消費者ユーザと管理者のための適切なユーザ"
"識別管理が行われるようにする。"

#: pcidss.py:358 pcidss.py:367 pcidss.py:376 pcidss.py:388 pcidss.py:399
#: pcidss.py:407 pcidss.py:415 pcidss.py:425 pcidss.py:434 pcidss.py:442
msgid "Restrict physical access to cardholder data"
msgstr "カード会員データへの物理アクセスを制限する"

#: pcidss.py:362
msgid ""
"Use appropriate facility entry controls to limit and monitor physical access "
"to systems in the cardholder data environment"
msgstr ""
"適切な施設入館管理を使用して、カード会員データ環境内のシステムへの物理アクセ"
"スを制限および監視する。"

#: pcidss.py:371
msgid ""
"Develop procedures to easily distinguish between onsite personnel and "
"visitors, especially in areas where cardholder data is accessible"
msgstr ""
"特に、カード会員データにアクセスできる場所について、オンサイト要員と訪問者を"
"容易に区別するための手順を開発する。"

#: pcidss.py:380
msgid ""
"Ensure all visitors are authorized before entering areas where cardholder "
"data is processed or maintained; given a physical token that expires and "
"that identifies visitors as not onsite personnel; and are asked to surrender "
"the physical token before leaving the facility or at the date of expiration."
msgstr ""
"カード会員データが処理または管理されているエリアに入る前に、すべての訪問者が"
"承認されていることを確認する。有効期限付きの物理的なトークンが与えられ、訪問"
"者がオンサイトの担当者ではないと特定すると、施設を出る前に、または満了した日"
"に物理トークンを返却するよう求められます。"

#: pcidss.py:392
msgid ""
"Use a visitor log to maintain a physical audit trail of visitor information "
"and activity, including visitor name and company, and the onsite personnel "
"authorizing physical access. Retain the log for at least three months unless "
"otherwise restricted by law."
msgstr ""
"訪問者ログを使用して、カード会員データの保存または送信が行われているコン\n"
"ピュータルームやデータセンターなどの施設への訪問者の行動の物理的監査証跡を保"
"持する。\n"
"訪問者の名前、所属会社、物理アクセスを承認したオンサイト要員をログに記録す"
"る。法律によって別途定められていない限り、このログを少なくとも 3 カ月間保管す"
"る。"

#: pcidss.py:403
msgid "Store media back-ups in a secure location, preferably off site."
msgstr ""
"バックアップの入った媒体を安全な場所に保管する（オフサイト施設が望ましい）"

#: pcidss.py:411
msgid "Physically secure all media."
msgstr "すべての媒体を物理的にセキュリティ保護する。"

#: pcidss.py:419
msgid ""
"Maintain strict control over the internal or external distribution of any "
"kind of media. Classify media so the sensitivity of the data can be "
"determined."
msgstr ""
"あらゆるタイプの媒体を内部または外部に配布する際の厳格な管理を維持する。\n"
"データの機密性を識別できるように、媒体を分類する。"

#: pcidss.py:429
msgid ""
"Ensure that management approves any and all media moved from a secured area, "
"especially when media is distributed to individuals"
msgstr ""
"安全なエリアから移動されるすべての媒体を管理者が承認していることを確認する。"

#: pcidss.py:438
msgid "Maintain strict control over the storage and accessibility of media"
msgstr "媒体の保管およびアクセスについて、厳密な管理を維持する。"

#: pcidss.py:446
msgid "Destroy media when it is no longer needed for business or legal reasons"
msgstr "ビジネスまたは法律上不要になった媒体を破棄する。"

#: pcidss.py:452 pcidss.py:465 pcidss.py:482 pcidss.py:496 pcidss.py:509
#: pcidss.py:520 pcidss.py:532
msgid "Track and monitor all access to network resources and cardholder  data"
msgstr ""
"ネットワークリソースおよびカード会員データへのすべてのアクセスを追跡監視"

#: pcidss.py:458
msgid ""
"Establish a process for linking all access to system components to each "
"individual user especially access done with administrative privileges."
msgstr ""
"特に、管理者権限で実行されるアクセスについて、システムコンポーネントへのすべ"
"てのアクセスを各ユーザーにリンクするプロセスを確立する。"

#: pcidss.py:471
msgid ""
"Implement automated audit trails for all system components for "
"reconstructing these events: all individual user accesses to cardholder "
"data; all actions taken by any individual with root or administrative "
"privileges; access to all audit trails; invalid logical access attempts; use "
"of identification and authentication mechanisms; initialization of the audit "
"logs; creation and deletion of system-level objects"
msgstr ""
"次のイベントを再現するために、すべてのシステムコンポーネントの自動監査証跡を"
"実装する。;カード会員データへのすべての個人アクセス;ルート権限または管理権限"
"を持つ個人によって行われたすべてのアクション;すべての監査証跡へのアクセス;無"
"効な論理アクセス試行;識別と認証メカニズムの使用および変更;監査ログの初期化;シ"
"ステムレベルオブジェクトの作成および削除;"

#: pcidss.py:488
msgid ""
"Record audit trail entries for all system components for each event, "
"including at a minimum: user identification, type of event, date and time, "
"success or failure indication, origination of event, and identity or name of "
"affected data, system component or resource. "
msgstr ""
"ユーザー識別、イベントの種類、日付と時刻、成功または失敗を示す情報、イベント"
"の発生元、影響を受けるデータ、システムコンポーネントまたはリソースIDまたは名"
"前など、イベントごとにすべてのシステムコンポーネントについて監査証跡エントリ"
"を記録する。"

#: pcidss.py:502
msgid ""
"Using time synchronization technology, synchronize all critical system "
"clocks and times and implement controls for acquiring, distributing, and "
"storing time."
msgstr ""
"時間同期技術を使用して、すべての重要なシステムクロックおよび時間を同期し、時"
"間を取得、配布、保存するための制御を実装する。"

#: pcidss.py:515
msgid "Secure audit trails so they cannot be altered."
msgstr "監査証跡を変更されないようにする"

#: pcidss.py:526
msgid ""
"Review logs for all system components related to security functions at least "
"daily"
msgstr ""
"少なくとも毎日セキュリティ機能に関連するすべてのシステムコンポーネントのログ"
"を確認する"

#: pcidss.py:538
msgid ""
"Retain audit trail history for at least one year; at least three months of "
"history must be immediately available for analysis"
msgstr ""
"監査証跡の履歴を少なくとも 1 年間保持する。少なくとも 3 カ月はすぐに分析でき"
"る状態にしておく。"

#: pcidss.py:543 pcidss.py:555 pcidss.py:569 pcidss.py:580 pcidss.py:593
msgid "Regularly test security systems and processes"
msgstr "セキュリティシステムとプロセスを定期的にテストする"

#: pcidss.py:547
msgid ""
"Test for the presence of wireless access points and detect unauthorized "
"wireless access points on a quarterly basis. Typical methods are wireless "
"network scans, physical/logical inspections of system components and "
"infrastructure, network access control (NAC), or wireless IDS/IPS. "
msgstr ""
"四半期ごとにワイヤレスアクセスポイントの存在をテストし、不正なワイヤレスアク"
"セスポイントを検出します。一般的な方法は、ワイヤレスネットワークスキャン、シ"
"ステムコンポーネントとインフラストラクチャの物理/論理検査、ネットワークアクセ"
"ス制御（NAC）、またはワイヤレスIDS / IPSです。"

#: pcidss.py:559
msgid ""
"Run internal and external network vulnerability scans at least quarterly and "
"after any significant change in the network. After passing a scan for "
"initial PCI DSS compliance, an entity must, in subsequent years, pass four "
"consecutive quarterly scans as a requirement for compliance. Quarterly "
"external scans must be performed by an Approved Scanning Vendor (ASV). Scans "
"conducted after network changes may be performed by internal staff"
msgstr ""
"内部および外部ネットワークの脆弱性スキャンは、少なくとも四半期ごとに、また"
"ネットワークの大きな変更後に実行する。先にPCI DSS準拠のスキャンを通過した後、"
"エンティティは、コンプライアンスの要件として、四年連続で4回連続スキャンを通過"
"する必要があります。四半期ごとの外部スキャンは、承認済みスキャンベンダー"
"（ASV）によって実行されなければならない。ネットワークの変更後に実施するスキャ"
"ンは社内スタッフが行うことができる。"

#: pcidss.py:573
msgid ""
"Perform external and internal penetration testing, including network- and "
"application-layer penetration tests, at least annually and after any "
"significant infrastructure or application upgrade or modification."
msgstr ""
"少なくとも年1回、重要なインフラストラクチャまたはアプリケーションのアップグ"
"レードまたは修正が行われた後で、ネットワークおよびアプリケーション層のペネト"
"レーションテストを含む外部および内部ペネトレーションテストを実行する。"

#: pcidss.py:584
msgid ""
"Use network intrusion detection systems and/or intrusion prevention systems "
"to monitor all traffic at the perimeter of the cardholder data environment "
"as well as at critical points inside of the cardholder data environment, and "
"alert personnel to suspected compromises. IDS/IPS engines, baselines, and "
"signatures must be kept up to date"
msgstr ""
"侵入検知システムや侵入防止手法を使用して、ネットワークへの侵入を検知\n"
"および/または防止する。カード会員データ環境との境界およびカード会員データ環境"
"内の重要なポイントを通過するすべてのトラフィックを監視し、侵害の疑いがある場"
"合は担当者に警告する。すべての侵入検知および防止エンジン、ベースライン、シグ"
"ネチャを最新状態に保つ。"

#: pcidss.py:597
msgid ""
"Deploy file integrity monitoring tools to alert personnel to unauthorized "
"modification of critical system files, configuration files or content files. "
"Configure the software to perform critical file comparisons at least weekly"
msgstr ""
"変更検出メカニズム（ファイル整合性監視ツールなど）を導入して重要なシ\n"
"ステムファイル、構成ファイル、またはコンテンツファイルの不正な変更（変\n"
"更、追加、および削除を含む）を担当者に警告し、重要なファイルの比較を少な\n"
"くとも週に一度実行するようにソフトウェアを構成する。"

#: pcidss.py:605 pcidss.py:620 pcidss.py:632 pcidss.py:646 pcidss.py:658
#: pcidss.py:670 pcidss.py:682 pcidss.py:696 pcidss.py:710
msgid "Maintain a policy that addresses information security for all personnel"
msgstr "すべての担当者の情報セキュリティに対応するポリシーを維持する。"

#: pcidss.py:611
msgid ""
"Establish, publish, maintain, and disseminate a security policy that "
"addresses all PCI DSS requirements, includes an annual process for "
"identifying vulnerabilities and formally assessing risks, and includes a "
"review at least once a year and when the environment changes"
msgstr ""
"PCI DSSのすべての要件に対処するセキュリティポリシーの確立、公開、維持、および"
"普及、脆弱性を特定し、少なくとも年に一度と環境に大きな変更があった場合に実施"
"されるリスク評価プロセスを実装する。"

#: pcidss.py:626
msgid ""
"Develop daily operational security procedures that are consistent with "
"requirements in PCI DSS"
msgstr "PCI DSSの要件に沿った日々の運用セキュリティ手順を開発する"

#: pcidss.py:638
msgid ""
"Develop usage policies for critical technologies to define their proper use "
"by all personnel. These include remote access, wireless, removable "
"electronic media, laptops, tablets, handheld devices, email and Internet"
msgstr ""
"重要なテクノロジに関する使用ポリシーを作成して、これらのテクノロジの適切な使"
"用を定義する。\n"
"これには、リモートアクセス、ワイヤレス、リムーバブル電子メディア、ラップトッ"
"プ、タブレット、ハンドヘルドデバイス、電子メール、インターネットを含む。"

#: pcidss.py:652
msgid ""
"Ensure that the security policy and procedures clearly define information "
"security responsibilities for all personnel."
msgstr ""
"セキュリティポリシーと手順が、すべての担当者に関する情報セキュリティ\n"
"責任を明確に定義していることを確実にする。"

#: pcidss.py:664
msgid ""
"Assign to an individual or team information security responsibilities "
"defined by 12.5 subsections."
msgstr ""
"個人またはチームに12.5項で定義されている情報セキュリティ責任を割り当てる。"

#: pcidss.py:676
msgid ""
"Implement a formal security awareness program to make all personnel aware of "
"the importance of cardholder data security"
msgstr ""
"カード会員データセキュリティポリシーおよび手順をすべての担当者が認識できるよ"
"うに正式なセキュリティ意識向上プログラムを実装する。"

#: pcidss.py:688
msgid ""
"Screen potential personnel prior to hire to minimize the risk of attacks "
"from internal sources. Example screening includes previous employment "
"history, criminal record, credit history, and reference checks"
msgstr ""
"雇用する前に、可能性のある担当者を選別して、内部ソースからの攻撃リス\n"
"クを最小限に抑える。（バックグラウンドチェックの例には、職歴、犯罪歴、信\n"
"用履歴、経歴照会がある。）"

#: pcidss.py:702
msgid ""
"If cardholder data is shared with service providers, maintain policies and "
"procedures to formally identify service provider responsibilities for "
"securing cardholder data, and monitor service providers' PCI DSS compliance "
"status at least annually"
msgstr ""
"カード会員データをサービスプロバイダと共有する場合は、カード会員データのセ"
"キュリティ確保のためのサービスプロバイダ責任を正式に特定する方針と手順を維持"
"し、少なくとも年に一度はサービスプロバイダーのPCI DSS準拠ステータスを監視す"
"る。"

#: pcidss.py:716
msgid ""
"Implement an incident response plan. Be prepared to respond immediately to a "
"system breach."
msgstr ""
"インシデント対応計画を実施します。システム違反に直ちに対応できるようにしてく"
"ださい。"

#: report.html:14
msgid "App Security Report"
msgstr "セキュリティレポート"

#: report.html:14
msgid "For Internal Purpose"
msgstr "内部目的のみ"

#: report.html:15 report.html:18
msgid "Prepared by"
msgstr "作成"

#: report.html:15 report.html:17
msgid "Powered by"
msgstr "搭載"

#: report.html:18
msgid ""
"Portions of this document and the templates used in its production are the "
"property of Appknox"
msgstr ""
"この文書の一部およびそのプロダクションに使用されるテンプレートは、Appknoxが所"
"有権を有します。"

#: report.html:18
msgid " and "
msgstr " そして "

#: report.html:18 report.html:26
msgid ","
msgstr "、"

#: report.html:18
msgid " and cannot be copied without permission."
msgstr " 許可なくコピーすることはできません。"

#: report.html:18
msgid ""
"While precautions have been taken in the preparation of this document, the "
"publisher and the author(s) assume no responsibility for errors, omissions, "
"or for damages resulting from the use of the information contained herein. "
"Use of "
msgstr ""
"本書の作成時に充分な注意を払っていますが、出版社および著者は、ここに記載され"
"ている情報の使用に起因する誤り、省略、または損害について一切責任を負いませ"
"ん。Appknox のサービスを使用しても、システムのセキュリティが保証されるわけで"
"はなく、侵入も発生しません。"

#: report.html:18 report.html:26
msgid "Appknox"
msgstr "Appknox"

#: report.html:18
msgid ""
" services does not guarantee the security of a system, or that intrusions "
"will not occur."
msgstr ""
"サービスはシステムのセキュリティを保証するものではなく、侵入が起こらないこと"
"を保証します。"

#: report.html:18
msgid "Application Details"
msgstr "アプリケーションの詳細"

#: report.html:18
msgid "Application Name"
msgstr "アプリケーションの名称"

#: report.html:20
msgid "Platform"
msgstr "プラットフォーム"

#: report.html:20
msgid "Application Namespace"
msgstr "アプリケーションの名前空間"

#: report.html:20
msgid "Version"
msgstr "バージョン"

#: report.html:20
msgid "Audit Date"
msgstr "監査日"

#: report.html:20
msgid "Application SHA1 Hash"
msgstr "アプリケーション SHA1 ハッシュ"

#: report.html:20
msgid "Application MD5 Hash"
msgstr "アプリケーション MD5 ハッシュ"

#: report.html:20
msgid "Table of Contents"
msgstr "目次"

#: report.html:20 report.html:26
msgid "Report Summary"
msgstr "レポートの概要"

#: report.html:20 report.html:26
msgid "Audit Summary"
msgstr "監査の概要"

#: report.html:20 report.html:36
msgid "Appknox "
msgstr "Appknox"

#: report.html:20 report.html:36
msgid "Security Rating"
msgstr "Appknoxのセキュリティ評価"

#: report.html:21 report.html:40 report.html:49
msgid "Noncompliant Code Example"
msgstr "違反コードの例"

#: report.html:22 report.html:41 report.html:50
msgid "Compliant Solution"
msgstr "コンプライアンス ソリューション"

#: report.html:23 report.html:42 report.html:51
msgid "Business Implication"
msgstr "ビジネスへの影響"

#: report.html:24 report.html:43 report.html:52
msgid "Related Vulnerabilities"
msgstr "関連のある脆弱性"

#: report.html:26
msgid ", powered by "
msgstr "、 搭載 "

#: report.html:26
msgid " conducted a security assessment of the mobile application. "
msgstr " モバイルアプリケーションのセキュリティ評価を実施しました。"

#: report.html:26
msgid ""
"This report contains all the findings during the automated and manual "
"auditing processes. It also contains the process of discovering those "
"vulnerabilities in the first place, and ways to remediate those issues."
msgstr ""
"モバイルアプリケーションのセキュリティ評価を実施しました。このレポートには、"
"自動および手動監査プロセス中のすべての調査結果が含まれています。また、これら"
"の脆弱性を発見するプロセスと、その問題を改善する方法も含まれています。"

#: report.html:33
msgid "Ignored"
msgstr ""

#: report.html:36
msgid "Priority Level"
msgstr "優先レベル"

#: report.html:36
msgid "Number of failed test cases"
msgstr "失敗したテストケースの数"

#: report.html:36
msgid "Critical Risk"
msgstr "重大リスク"

#: report.html:36
msgid "High Risk"
msgstr "高リスク"

#: report.html:36
msgid "Medium Risk"
msgstr "中リスク"

#: report.html:36
msgid "Low Risk"
msgstr "低リスク"

#: report.html:36
msgid "Security Rating:"
msgstr "Appknoxセキュリティ評価："

#: report.html:36
msgid "Unsecured"
msgstr "無担保"

#: report.html:37 report.html:46
msgid "Risk Rating"
msgstr "リスク評価"

#: report.html:37 report.html:46
msgid "Regulatory"
msgstr "規制上"

#: report.html:38 report.html:47
msgid "Description"
msgstr "説明"

#: report.html:39 report.html:48
msgid "Risk Assessment"
msgstr "リスクアセスメント"

#: report.html:45
msgid "Ignored Analyses"
msgstr ""

#: report.html:53
msgid "References"
msgstr "参考文献"

#: vulnerabilities.py:78
msgid "Unprotected Services"
msgstr "保護されていないサービス"

#: vulnerabilities.py:79
msgid "Are exported services sufficiently protected?"
msgstr "エクスポートされたサービスは十分に保護されていますか？"

#: vulnerabilities.py:80
msgid "Exported services in the app are sufficiently protected."
msgstr ""
"アプリケーション内のエクスポートされたサービスは十分に保護されています。"

#: vulnerabilities.py:81
msgid ""
"\n"
"[Chin, et al.](https://www.securecoding.cert.org/confluence/display/java/AA."
"+References#AA.References-Chin11)\n"
"say: \"If a Service is exported and not\n"
"protected with strong permissions, then any application can start and\n"
"bind to the Service. Depending on the duties of a particular Service, it\n"
"may leak information or perform unauthorized tasks. Services sometimes\n"
"maintain singleton application state, which could be corrupted.\"\n"
"\n"
"To guard against such eventualities, an exported service should always\n"
"be protected with strong permissions.\n"
msgstr ""
"\n"
"[Chin, et al.] (https://www.securecoding.cert.org/confluence/display/java/AA."
"+References#AA.References-Chin11\") : \"もしサービスがエクスポートされ、強力"
"なパーミッションで保護されていない場合、どのアプリケーションでもサービスを開"
"始してバインドできます。特定のサービスの役割によっては、情報が漏洩したり、不"
"正なタスクを行う可能性があります。サービスが時々 Singleton アプリケーションの"
"状態を維持している場合は壊れている可能性があります。\"    \n"
"\n"
"そのような事態を防ぐために、エクスポートされたサービスは常に強いパーミッショ"
"ンで保護されるべきです。\n"

#: vulnerabilities.py:92
msgid ""
"\n"
"A service was found to be shared with other apps on the device without\n"
"an intent filter or a permission requirement therefore leaving it\n"
"accessible to any other application on the device.\n"
msgstr ""
"\n"
"サービスはインテントフィルタまたパーミッション要求なしで、デバイス上の他のア"
"プリケーションと共有されているため、デバイス上の他のアプリケーションからアク"
"セス可能な状態になっています。\n"

#: vulnerabilities.py:97
msgid ""
"\n"
"Data can be shared through other services resulting in loss of sensitive\n"
"information.\n"
msgstr ""
"\n"
"データは他のサービスを通じて共有され、機密情報が失われる可能性があります。\n"

#: vulnerabilities.py:101
msgid ""
"\n"
"Always protect the Activity with `export=false`\n"
"\n"
"    <activity exported=\"false\" />\n"
"\n"
msgstr ""
"\n"
"アクティビティは常に`export=false`で保護してください。\n"
"\n"
"    <activity exported=\"false\" />\n"
"\n"

#: vulnerabilities.py:116
msgid "Improper Content Provider Permissions"
msgstr "不適切なコンテンツプロバイダのアクセス権"

#: vulnerabilities.py:117
msgid "Are Content Providers sufficiently protected?"
msgstr "コンテンツプロバイダーは十分に保護されていますか？"

#: vulnerabilities.py:118
msgid ""
"Application seems to properly implement SSL, or HTTPS is not implemented."
msgstr ""
"アプリケーションはSSLを適切に実装しているか、あるいはHTTPSが実装されていない"
"ようです。"

#: vulnerabilities.py:119
msgid ""
"\n"
"The `ContentProvider` class provides a mechanism for managing and sharing\n"
"data with other applications. When sharing a provider's data with other\n"
"apps, access control should be carefully implemented to prohibit\n"
"unauthorized access to sensitive data.\n"
"\n"
"There are three ways to limit access to the content provider:\n"
"\n"
"- Public\n"
"- Private\n"
"- Restricted access\n"
"\n"
msgstr ""
"\n"
"`ContentProvider`クラスは、他のアプリケーションとのデータの管理と共有の仕組み"
"を提供します。 プロバイダのデータを他のアプリと共有する場合、機密データへの不"
"正アクセスを防ぐために、アクセス制御を慎重にj実装する必要があります。\n"
"コンテンツプロバイダへのアクセスを制限するには、次の3つの方法があります。\n"
"\n"
"- パブリック\n"
"- プライベート\n"
"- 制限付きアクセス\n"
"\n"

#: vulnerabilities.py:132
msgid ""
"\n"
"A content provider permission was set to allow access from any other app\n"
"on the device. Content providers may contain sensitive information about\n"
"an app and therefore should not be shared.\n"
msgstr ""
"\n"
"コンテンツプロバイダのアクセス権が、デバイス上の他のアプリケーションからのア"
"クセスを許可するよう設定されました。\n"
"コンテンツプロバイダはアプリケーションに関する機密情報を含む可能性があるた"
"め、共有されるべきではありません。\n"

#: vulnerabilities.py:137
msgid ""
"\n"
"If security controls are not properly implemented, content providers can\n"
"lead to client side attacks like SQL injection. This works similarly to\n"
"traditional SQL injection attacks.\n"
msgstr ""
"\n"
"セキュリティコントロールが適切に実装されていないと、コンテンツプロバイダはSQL"
"インジェクションのようなクライアントサイドアタックに繋がる可能性がありま"
"す。\n"
"これは従来のSQLインジェクション攻撃と同様に機能します。\n"

#: vulnerabilities.py:142
msgid ""
"\n"
"The following entry in the AndroidManifest.xml file makes the content\n"
"provider private so that other apps cannot access the data:\n"
"\n"
"    <provider\n"
"        android:name=\".content.AccountProvider\"\n"
"        android:exported=\"false\"\n"
"        android:authorities=\"jp.co.vulnerable.accountprovider\" />\n"
"\n"
msgstr ""
"\n"
"AndroidManifest.xmlファイルの次のエントリは、他のアプリがデータにアクセスでき"
"ないようにコンテンツプロバイダを非公開にします。\n"
"\n"
"    <provider\n"
"        android:name=\".content.AccountProvider\"\n"
"        android:exported=\"false\"\n"
"        android:authorities=\"jp.co.vulnerable.accountprovider\" />\n"
"\n"

#: vulnerabilities.py:152
msgid ""
"\n"
"MovatwiTouch, a Twitter client application, used a content provider to\n"
"manage Twitter's consumer key, consumer secret, and access token.\n"
"However, the content provider was made public, which enabled\n"
"applications installed on users' devices to access this sensitive\n"
"information.\n"
"\n"
"The following entry in the AndroidManifest.xml does not have the\n"
"`android:exported` attribute, which means, before API Level 16, the\n"
"content provider is made public:\n"
"\n"
"    <provider\n"
"        android:name=\".content.AccountProvider\"\n"
"        android:authorities=\"jp.co.vulnerable.accountprovider\" />\n"
"\n"
msgstr ""
"\n"
"TwitterクライアントアプリケーションであるMovatwiTouchは、コンテンツプロバイ"
"ダーを使用して、Twitterのコンシューマー·キー、コンシューマー·シークレット、お"
"よびアクセストークンを管理していました。しかし、コンテンツプロバイダーが公開"
"されると、ユーザのデバイスにインストールされたアプリケーションはこの機密情報"
"にアクセスできるようになりました。\n"
" AndroidManifest.xmlの次のエントリにはandroid：exported属性がありません。つま"
"り、APIレベル16以前はコンテンツプロバイダが公開されていることを意味しま"
"す。:\n"
"    <provider\n"
"        android:name=\".content.AccountProvider\"\n"
"        android:authorities=\"jp.co.vulnerable.accountprovider\" />\n"
"\n"

#: vulnerabilities.py:168
msgid ""
"\n"
"- [JVN\\#90289505](https://jvn.jp/en/jp/JVN90289505/) Content provider\n"
"  in MovatwiTouch fails to restrict access permissions\n"
"\n"
msgstr ""
"\n"
"- [JVN\\#90289505](https://jvn.jp/en/jp/JVN90289505/) MovatwiTouch のコンテン"
"ツプロバイダがアクセス権の制限に失敗\n"

#: vulnerabilities.py:181
msgid "Application Debugging"
msgstr "アプリケーションのデバッグ"

#: vulnerabilities.py:182
msgid "Does the application have debug enabled?"
msgstr "アプリケーションでデバッグが有効になっていますか？"

#: vulnerabilities.py:183
msgid "Debug was found to be disabled."
msgstr "デバッグが無効であることが判明しました。"

#: vulnerabilities.py:184
msgid ""
"\n"
"Android allows the attribute `android:debuggable` to be set to true so\n"
"that the app can be debugged. By default this attribute is disabled,\n"
"i.e., it is set to false, but it may be set to true to help with\n"
"debugging during development of the app. However, an app should never be\n"
"released with this attribute set to true as it enables users to gain\n"
"access to details of the app that should be kept secure. With the\n"
"attribute set to true, users can debug the app even without access to\n"
"its source code.\n"
msgstr ""
"\n"
"Androidでは、アプリケーションをデバッグできるように、android:debuggable属性を"
"trueに設定することが許可されています。デフォルトでは、この属性は無効です。つ"
"まり、falseに設定されていますが、アプリケーションの開発中のデバッギングを支援"
"するためにtrueに設定される可能性があります。ただし、安全に保つべきアプリの詳"
"細情報にユーザがアクセスできるようにこの属性をtrueにした状態のアプリケーショ"
"ンは決してリリースしないでください。属性をtrueに設定すると、ユーザはソース"
"コードにアクセスしなくてもアプリケーションをデバッグできます。\n"

#: vulnerabilities.py:194
msgid ""
"\n"
"Debugging was enabled on the app which makes it easier for reverse\n"
"engineers to hook a debugger to it. This allows dumping a stack trace\n"
"and accessing debugging helper classes.\n"
msgstr ""
"\n"
"リバースエンジニアがデバッガーをフックすることを容易にするアプリでデバッギン"
"グが有効化されました。これによってスタックトレースのダンプと、デバッギングヘ"
"ルパークラスへのアクセスが可能になります。\n"

#: vulnerabilities.py:199
msgid ""
"\n"
"Application can be debugged and reverse engineers can debug and manipulate "
"the\n"
"runtime logic of the application.\n"
msgstr ""
"\n"
"アプリケーションをデバッグすることができ、リバースエンジニアはアプリケーショ"
"ンのランタイムロジックをデバッグして操作できます。\n"

#: vulnerabilities.py:203
msgid ""
"\n"
"Ensure that the `android:debuggable` attribute is set to false before the\n"
"app is released:\n"
"\n"
"    <application\n"
"        ...\n"
"        android:debuggable=\"false\" >\n"
"        ...\n"
"    </application>\n"
"\n"
"Note that some development environments (including Eclipse/ADT and Ant)\n"
"automatically set `android:debuggable` to true for incremental or\n"
"debugging builds but set it to false for release builds.\n"
msgstr ""
"\n"
"アプリケーションをリリースする前に、android:debuggable 属性が false に設定さ"
"れていることを確認してください。:\n"
"\n"
"    <application\n"
"        ...\n"
"        android:debuggable=\"false\" >\n"
"        ...\n"
"    </application>\n"
"\n"
"いくつかの開発環境（Eclipse/ADTおよびAntを含む）は、インクリメンタルビルドま"
"たはデバッギングビルドのために、android:debuggable を自動的に true にします"
"が、リリースビルドでは false に設定されることに注意してください。\n"

#: vulnerabilities.py:217
msgid ""
"\n"
"This non-compliant code example shows an app that has the\n"
"`android:debuggable` attribute set to true being accessed to reveal\n"
"sensitive data.\n"
"\n"
"    $ adb shell\n"
"    shell@android:/ $ run-as com.example.someapp sh\n"
"    shell@android:/data/data/com.example.someapp $ id\n"
"    uid=10060(app_60) gid=10060(app_60)\n"
"    shell@android:/data/data/com.example.someapp $ ls files/\n"
"    secret_data.txt\n"
"    shell@android:/data/data/com.example.some $ cat files/secret_data.txt\n"
"    password=GoogolPlex\n"
"    account_number=31974286\n"
"\n"
"Clearly, with the `android:debuggable` attribute set to true, sensitive\n"
"date related to the app can be revealed to any user.\n"
msgstr ""
"\n"
"この規格に準拠していないコード例は、android:debuggable 属性が true に設定され"
"ていて機密データを漏らすためにアクセスされるアプリケーションを示していま"
"す。\n"
"\n"
"    $ adb shell\n"
"    shell@android:/ $ run-as com.example.someapp sh\n"
"    shell@android:/data/data/com.example.someapp $ id\n"
"    uid=10060(app_60) gid=10060(app_60)\n"
"    shell@android:/data/data/com.example.someapp $ ls files/\n"
"    secret_data.txt\n"
"    shell@android:/data/data/com.example.some $ cat files/secret_data.txt\n"
"    password=GoogolPlex\n"
"    account_number=31974286\n"
"\n"
"`android：debuggable`属性が true に設定されていると、アプリに関連する機密性の"
"高いデータが漏洩することがあります。\n"

#: vulnerabilities.py:244
msgid "Improper Custom Permissions"
msgstr "不適切なカスタム権限"

#: vulnerabilities.py:245
msgid "Are protection levels of the custom permission safe?"
msgstr "カスタム権限の保護レベルは安全ですか？"

#: vulnerabilities.py:246
msgid ""
"Custom permissions in the app have sufficient protection levels, or custom "
"permissions are absent."
msgstr ""
"アプリのカスタム権限は十分な保護レベルに設定されているか、カスタム権限があり"
"ません。"

#: vulnerabilities.py:247
msgid ""
"\n"
"If an app is using a granted permission to respond to a calling app then\n"
"it must check that the calling app as that permission as well.\n"
"Otherwise, the responding app may be granting privileges to the calling\n"
"app that it should not have. (This is sometimes called the \"confused\n"
"deputy\" problem.)\n"
"\n"
"The methods `Context.checkCallingPermission()` and\n"
"`Context.enforceCallingPermission()` can be used to ensure that the\n"
"calling app has the correct permissions.\n"
msgstr ""
"\n"
"アプリが呼び出し元のアプリケーションに応答するために付与された権限を使用して"
"いる場合は、呼び出し元のアプリもその権限としてチェックする必要があります。そ"
"れ以外の場合は、応答しているアプリケーションが、呼び出してはならないアプリ"
"ケーションに権限を与えている可能性があります。呼び出し元のアプリケーションに"
"正しいパーミッションがあることを確認するために、 `Context."
"checkCallingPermission（）`と `Context.enforceCallingPermission（）`メソッド"
"を使用することができます（これは「Confused deputy problem 混乱した使節の問"
"題」とも呼ばれます）。\n"

#: vulnerabilities.py:258
msgid ""
"\n"
"A custom permission controls whether other applications can access the\n"
"affected apps features. The use of the dangerous label places no\n"
"restrictions on which apps can access the application declaring the\n"
"permission but the user will be warned that the dangerous permission is\n"
"required during installation.\n"
msgstr ""
"\n"
"カスタムアクセス権は、他のアプリケーションが影響を受けるアプリケーション機能"
"にアクセスできるかどうかを制御します。危険なラベルを使用すると、許可を宣言す"
"るアプリケーションにどのアプリがアクセスできるかは制限されませんが、インス"
"トール中に危険な許可が必要であることが警告されます。\n"

#: vulnerabilities.py:266
msgid ""
"\n"
"Remove custom permissions which are not required from the\n"
"custom-permission sets defined in the `AndroidManifest.xml`\n"
msgstr ""
"\n"
"`AndroidManifest.xml`で定義されたカスタム権限セットから不要なカスタム権限を削"
"除します。\n"

#: vulnerabilities.py:280
msgid "Broken SSL Trust Manager"
msgstr "壊れたSSLトラストマネージャ"

#: vulnerabilities.py:281
msgid "Is the Trust Manager for SSL implemented properly?"
msgstr "Trust Manager for SSLは正しく実装されていますか?"

#: vulnerabilities.py:282
msgid "Trust Managers for SSL, if any, seem to be properly implemented."
msgstr "SSLのトラストマネージャがある場合は、適切に実装されているようです。"

#: vulnerabilities.py:283
msgid ""
"\n"
"Android apps that use SSL/TLS protocols for secure communication should\n"
"properly verify server certificates. The basic verification includes:\n"
"\n"
"- verify that the subject (CN) of X.509 certificate and the URL\n"
"  matches\n"
"- verify that the certificate is signed by the trusted CA\n"
"- verify that the signature is correct\n"
"- verify that the certificate is not expired\n"
"\n"
"A developer has the freedom to customize their SSL implementation. The\n"
"developer should properly use SSL as appropriate to the intent of the\n"
"app and the environment the apps are used in. If the SSL is not\n"
"correctly used, a user's sensitive data may leak via the vulnerable SSL\n"
"communication channel.\n"
"\n"
"Fahl et al [Fahl\n"
"2012](https://www.securecoding.cert.org/confluence/display/java/AA."
"+References#AA.References-Fahl2012)\n"
"describes the following patterns of the insecure use of SSL:\n"
"\n"
"- Trusting All Certificates: The developer implements the\n"
"  TrustManager interface so that it will trust all the server\n"
"  certificate (regardless of who signed it, what is the CN etc.)\n"
"- Mixed-Mode/No SSL: A developer mixes secure and insecure\n"
"  connections in the same app or does not use SSL at all.\n"
"\n"
"On Android, using `HttpURLConnection` is recommended for HTTP client\n"
"implementation.\n"
msgstr ""
"\n"
"安全な通信のためにSSL/TLSプロトコルを使用するAndroidアプリケーションは、サー"
"バ証明書を正しく検証すべきです。基本的な検証には次のものが含まれます。: \n"
"\n"
"- X.509証明書のsubject(CN)とURLが一致することを検証。\n"
"- 証明書が信頼できるCAによって署名されていることを検証。\n"
"- 署名が正しいことを検証。\n"
"- 証明書が期限切れでないことを検証。\n"
"\n"
"開発者は自由にSSL実装をカスタマイズすることができます。開発者は、アプリケー"
"ションのインテントとアプリケーションが使用されている環境に対して適切にSSLを使"
"用する必要があります。SSLを正しく使用しないと、ユーザの機密データが脆弱なSSL"
"通信チャネルを介して漏洩する可能性があります。\n"
"\n"
"Fahl et al [Fahl 2012](https://www.securecoding.cert.org/confluence/display/"
"java/AA.+References#AA.References-Fahl2012) はSSLの安全ではない使用の次のパ"
"ターンを説明しています。:\n"
"\n"
"- すべての証明書を信頼する。: 開発者はTrustManagerインターフェイスを実装し"
"て、すべてのサーバー証明書を信頼するようにします。(誰が署名したのかやCNが何か"
"などにかかわらず。)     \n"
"- Mixed-Mode/No SSL: 開発者は同じアプリケーション内の安全な接続と安全ではない"
"接続を混ぜる、もしくは全くSSLを使用しません。\n"
"\n"
"Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨"
"されています。\n"
"\n"

#: vulnerabilities.py:312
msgid ""
"\n"
"Implements naive certificate check. This Trust Manager breaks\n"
"certificate validation.\n"
msgstr ""
"\n"
"欠如した証明書検査を実装しています。このトラストマネジャーは証明書検証を中断"
"します。\n"

#: vulnerabilities.py:316 vulnerabilities.py:450 vulnerabilities.py:626
#: vulnerabilities.py:4252 vulnerabilities.py:4381
msgid ""
"\n"
"In the event that a user (anonymous or verified) is able to execute\n"
"over-privileged functionality, the business may experience:\n"
"\n"
"- Reputational Damage\n"
"- Fraud\n"
"- Information Theft\n"
"\n"
msgstr ""
"\n"
"ユーザ（匿名または検証済み）が特権を必要とする機能を実行できるという場合に"
"は、ビジネスには次のような問題が発生する可能性があります。:  \n"
"\n"
"- 風評被害\n"
"- 詐欺\n"
"- 情報盗難\n"
"\n"
"\n"

#: vulnerabilities.py:325
msgid ""
"\n"
"The compliant solution is given below which shows how to solve the issue\n"
"with the non compliant code:\n"
"\n"
"    public void checkCertTrusted(X509Certificate[] chain, String authType, "
"boolean isServer) throws CertificateException {\n"
"        try {\n"
"            if (isServer)\n"
"                appTrustManager.checkServerTrusted(chain, authType);\n"
"            else\n"
"                appTrustManager.checkClientTrusted(chain, authType);\n"
"        } catch (CertificateException ae) {\n"
"            // if the cert is stored in our appTrustManager, we ignore "
"expiredness\n"
"            if (isExpiredException(ae)) {\n"
"                Log.i(\"log\", \"accepting expired certificate from keystore"
"\");\n"
"                return;\n"
"            }\n"
"            if (isCertKnown(chain[0])) {\n"
"                Log.i(\"log\", \"accepting cert already stored in keystore"
"\");\n"
"                return;\n"
"            }\n"
"            try {\n"
"                if (defaultTrustManager == null)\n"
"                    throw ae;\n"
"                Log.d(\"log\", \"trying defaultTrustManager\");\n"
"                if (isServer)\n"
"                    defaultTrustManager.checkServerTrusted(chain, "
"authType);\n"
"                else\n"
"                    defaultTrustManager.checkClientTrusted(chain, "
"authType);\n"
"            } catch (CertificateException e) {\n"
"                Log.d(\"log\", \"defaultTrustManager failed: \" + e);\n"
"                interactCert(chain, authType, e);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    public void checkTrustManager() throws IOException, "
"KeyManagementException, NoSuchAlgorithmException {\n"
"        TrustManager tm = new X509TrustManager() {\n"
"\n"
"            @Override\n"
"            public void checkClientTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                checkCertTrusted(chain, authType, false);\n"
"            }\n"
"\n"
"            @Override\n"
"            public void checkServerTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                checkCertTrusted(chain, authType, false);\n"
"            }\n"
"\n"
"            @Override\n"
"            public X509Certificate[] getAcceptedIssuers() {\n"
"                return defaultTrustManager.getAcceptedIssuers();\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"The method `checkCertTrusted()` gives an idea about how to solve this\n"
"issue. If a custom keystore is being used to load certificates then we\n"
"need to define and do a failsafe load of those certificates.\n"
msgstr ""
"\n"
"準拠していないコードを使用して問題を解決する方法を示した準拠ソリューションを"
"以下に示します。: \n"
"\n"
"    public void checkCertTrusted(X509Certificate[] chain, String authType, "
"boolean isServer) throws CertificateException {\n"
"        try {\n"
"            if (isServer)\n"
"                appTrustManager.checkServerTrusted(chain, authType);\n"
"            else\n"
"                appTrustManager.checkClientTrusted(chain, authType);\n"
"        } catch (CertificateException ae) {\n"
"            // if the cert is stored in our appTrustManager, we ignore "
"expiredness\n"
"            if (isExpiredException(ae)) {\n"
"                Log.i(\"log\", \"accepting expired certificate from keystore"
"\");\n"
"                return;\n"
"            }\n"
"            if (isCertKnown(chain[0])) {\n"
"                Log.i(\"log\", \"accepting cert already stored in keystore"
"\");\n"
"                return;\n"
"            }\n"
"            try {\n"
"                if (defaultTrustManager == null)\n"
"                    throw ae;\n"
"                Log.d(\"log\", \"trying defaultTrustManager\");\n"
"                if (isServer)\n"
"                    defaultTrustManager.checkServerTrusted(chain, "
"authType);\n"
"                else\n"
"                    defaultTrustManager.checkClientTrusted(chain, "
"authType);\n"
"            } catch (CertificateException e) {\n"
"                Log.d(\"log\", \"defaultTrustManager failed: \" + e);\n"
"                interactCert(chain, authType, e);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    public void checkTrustManager() throws IOException, "
"KeyManagementException, NoSuchAlgorithmException {\n"
"        TrustManager tm = new X509TrustManager() {\n"
"\n"
"            @Override\n"
"            public void checkClientTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                checkCertTrusted(chain, authType, false);\n"
"            }\n"
"\n"
"            @Override\n"
"            public void checkServerTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                checkCertTrusted(chain, authType, false);\n"
"            }\n"
"\n"
"            @Override\n"
"            public X509Certificate[] getAcceptedIssuers() {\n"
"                return defaultTrustManager.getAcceptedIssuers();\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"`checkCertTrusted（）`メソッドは、この問題の解決方法を示します。カスタムキー"
"ストアを使用して証明書をロードする場合、これらの証明書のfailsafe loadを定義し"
"て実行する必要があります。\n"

#: vulnerabilities.py:386
msgid ""
"\n"
"The following code implements a custom `MySSLSocketFactory` class that\n"
"inherits `javax.net.ssl.SSLContext:`\n"
"\n"
"    public void emptyTrustManager() throws IOException, "
"KeyManagementException, NoSuchAlgorithmException {\n"
"        TrustManager tm = new X509TrustManager() {\n"
"\n"
"            @Override\n"
"            public void checkClientTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                // Do nothing -> accept any certificates\n"
"            }\n"
"\n"
"            @Override\n"
"            public void checkServerTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                // Do nothing -> accept any certificates\n"
"            }\n"
"\n"
"            @Override\n"
"            public X509Certificate[] getAcceptedIssuers() {\n"
"                return null;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"In the example above, `checkClientTrusted()` and `checkServerTrusted()` are\n"
"overridden to make a blank implementation so that SSLSocketFactory does\n"
"not verify the SSL certificate. The MySSLSocketFactory class is used to\n"
"create an instance of HttpClient in another part of the application.\n"
msgstr ""
"\n"
"以下のコードは `javax.net.ssl.SSLContext：`を継承するカスタム"
"`MySSLSocketFactory`クラスを実装しています。\n"
"\n"
"    public void emptyTrustManager() throws IOException, "
"KeyManagementException, NoSuchAlgorithmException {\n"
"        TrustManager tm = new X509TrustManager() {\n"
"\n"
"            @Override\n"
"            public void checkClientTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                // Do nothing -> accept any certificates\n"
"            }\n"
"\n"
"            @Override\n"
"            public void checkServerTrusted(X509Certificate[] chain,\n"
"                    String authType) throws CertificateException {\n"
"                // Do nothing -> accept any certificates\n"
"            }\n"
"\n"
"            @Override\n"
"            public X509Certificate[] getAcceptedIssuers() {\n"
"                return null;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"上記の例では、 `checkClientTrusted（）`と `checkServerTrusted（）`は、"
"SSLSocketFactoryがSSL証明書を検証しないように空の実装を作るためにオーバーライ"
"ドされています。MySSLSocketFactoryクラスは、アプリケーションの別の部分に"
"HttpClientのインスタンスを作成するために使用されます。\n"

#: vulnerabilities.py:417 vulnerabilities.py:519 vulnerabilities.py:588
#: vulnerabilities.py:659 vulnerabilities.py:725
msgid ""
"\n"
"- [JVN\\#39218538](http://jvn.jp/en/jp/JVN39218538/) Pizza Hut Japan\n"
"  Official Order App for Android has a problem whereby it fails to\n"
"  verify SSL server certificates.\n"
"- [JVN\\#75084836](http://jvn.jp/en/jp/JVN75084836/) Yome Collection\n"
"  for Android has a problem with management of IMEI.\n"
"- [JVN\\#68156832](http://jvn.jp/en/jp/JVN68156832/) Yafuoku! contains\n"
"  an issue where it fails to verify SSL server certificates\n"
"\n"
msgstr ""
"\n"
"-  [JVN\\#39218538](http://jvn.jp/en/jp/JVN39218538/) Android用Pizza Hut "
"Japan Official Appは、SSLサーバー証明書の確認に失敗するという問題がありま"
"す。 \n"
"- [JVN\\#75084836](http://jvn.jp/en/jp/JVN75084836/)  YOME Collection for "
"AndroidはIMEIの管理に問題があります。 \n"
"-  [JVN\\#68156832](http://jvn.jp/en/jp/JVN68156832/)  ヤフオク！SSLサーバー"
"証明書の検証に失敗する問題があります。\n"

#: vulnerabilities.py:434
msgid "Broken HostnameVerifier for SSL"
msgstr "HostnameVerifier for SSLの破損"

#: vulnerabilities.py:435
msgid "Is the HostnameVerifier for SSL implemented properly?"
msgstr "HostnameVerifier for SSLは正しく実装されていますか?"

#: vulnerabilities.py:436
msgid ""
"HostnameVerifiers for SSL, if any, seem to be verfying hostnames properly."
msgstr ""
"SSLのHostnameVerifiersがある場合、ホスト名を正しく検証しているようです。"

#: vulnerabilities.py:437
msgid ""
"\n"
"Allowing All Hostnames: The app does not verify if the certificate is\n"
"issued for the URL the client is connecting to. For example, when a\n"
"client connects to example.com, it will accept a server certificate\n"
"issued for some-other-domain.com.\n"
"\n"
"On Android, using `HttpURLConnection` is recommended for HTTP client\n"
"implementation.\n"
msgstr ""
"\n"
"すべてのホスト名を許可: アプリケーションは、クライアントが接続しているURLに対"
"して証明書が発行されているかどうかは検証しません。例えば、クライアントが"
"example.comに接続すると、some-other-domain.comに対して発行されたサーバ証明書"
"を受け入れます。\n"
"\n"
"Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨"
"されています。\n"
"\n"

#: vulnerabilities.py:446
msgid ""
"\n"
"Implements naive hostname verification. This HostnameVerifier breaks\n"
"certificate validation!\n"
msgstr ""
"\n"
"ナイーブなホスト名検査を実装しています。この HostnameVerifier は証明書検証を"
"中断します。\n"

#: vulnerabilities.py:459
msgid ""
"\n"
"The code example shows how to verify hostname using a\n"
"wrappper `HostnameVerifier` which also checks for custom loaded "
"certificates\n"
"\n"
"    public HostnameVerifier wrapHostnameVerifier(final HostnameVerifier "
"defaultVerifier) {\n"
"        if (defaultVerifier == null)\n"
"            throw new IllegalArgumentException(\"The default verifier may "
"not be null\");\n"
"\n"
"        return new SecuringHostnameVerifier(defaultVerifier);\n"
"    }\n"
"\n"
"    class SecuringHostnameVerifier implements HostnameVerifier {\n"
"        private HostnameVerifier defaultVerifier;\n"
"\n"
"        public MemorizingHostnameVerifier(HostnameVerifier wrapped) {\n"
"            defaultVerifier = wrapped;\n"
"        }\n"
"\n"
"        @Override\n"
"        public boolean verify(String hostname, SSLSession session) {\n"
"            Log.d(\"log\", \"hostname verifier for \" + hostname + \", "
"trying default verifier first\");\n"
"            // if the default verifier accepts the hostname, we are done\n"
"            if (defaultVerifier.verify(hostname, session)) {\n"
"                Log.d(\"log\", \"default verifier accepted \" + hostname);\n"
"                return true;\n"
"            }\n"
"            // otherwise, we check if the hostname is an alias for this cert "
"in our keystore\n"
"            try {\n"
"                X509Certificate cert = (X509Certificate)session."
"getPeerCertificates()[0];\n"
"                if (cert.equals(appKeyStore.getCertificate(hostname."
"toLowerCase(Locale.US)))) {\n"
"                    Log.d(\"log\", \"certificate for \" + hostname + \" is "
"in keystore. accepting.\");\n"
"                    return true;\n"
"                } else {\n"
"                    Log.d(\"log\", \"server \" + hostname + \" provided "
"wrong certificate.\");\n"
"                    return false;\n"
"                }\n"
"            } catch (Exception e) {\n"
"                e.printStackTrace();\n"
"                return false;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
msgstr ""
"\n"
"このコード例では、カスタムで読み込まれた証明書もチェックする"
"wrapHostnameVerifierを使用してホスト名を検証する方法を示しています。\n"
"\n"
"   public HostnameVerifier wrapHostnameVerifier(final HostnameVerifier "
"defaultVerifier) {\n"
"        if (defaultVerifier == null)\n"
"            throw new IllegalArgumentException(\"The default verifier may "
"not be null\");\n"
"\n"
"        return new SecuringHostnameVerifier(defaultVerifier);\n"
"    }\n"
"\n"
"    class SecuringHostnameVerifier implements HostnameVerifier {\n"
"        private HostnameVerifier defaultVerifier;\n"
"\n"
"        public MemorizingHostnameVerifier(HostnameVerifier wrapped) {\n"
"            defaultVerifier = wrapped;\n"
"        }\n"
"\n"
"        @Override\n"
"        public boolean verify(String hostname, SSLSession session) {\n"
"            Log.d(\"log\", \"hostname verifier for \" + hostname + \", "
"trying default verifier first\");\n"
"            // if the default verifier accepts the hostname, we are done\n"
"            if (defaultVerifier.verify(hostname, session)) {\n"
"                Log.d(\"log\", \"default verifier accepted \" + hostname);\n"
"                return true;\n"
"            }\n"
"            // otherwise, we check if the hostname is an alias for this cert "
"in our keystore\n"
"            try {\n"
"                X509Certificate cert = (X509Certificate)session."
"getPeerCertificates()[0];\n"
"                if (cert.equals(appKeyStore.getCertificate(hostname."
"toLowerCase(Locale.US)))) {\n"
"                    Log.d(\"log\", \"certificate for \" + hostname + \" is "
"in keystore. accepting.\");\n"
"                    return true;\n"
"                } else {\n"
"                    Log.d(\"log\", \"server \" + hostname + \" provided "
"wrong certificate.\");\n"
"                    return false;\n"
"                }\n"
"            } catch (Exception e) {\n"
"                e.printStackTrace();\n"
"                return false;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"

#: vulnerabilities.py:503
msgid ""
"\n"
"The following code inherits `javax.net.ssl.SSLContext`:\n"
"\n"
"    public void HostnameVerifier() {\n"
"        HostnameVerifier hv = new HostnameVerifier() {\n"
"            @Override\n"
"            public boolean verify(String hostname, SSLSession session) {\n"
"                // Always return true -> Accespt any host names\n"
"                return true;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"`HostnameVerifier` will always return true without checking the contents\n"
"or verifying the hostname\n"
msgstr ""
"\n"
"次のコードはjavax.net.ssl.SSLContextを継承しています。\n"
"\n"
"    public void HostnameVerifier() {\n"
"        HostnameVerifier hv = new HostnameVerifier() {\n"
"            @Override\n"
"            public boolean verify(String hostname, SSLSession session) {\n"
"                // Always return true -> Accespt any host names\n"
"                return true;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"`HostnameVerifier`は、内容を確認したり、ホスト名を確認することなく常にtrueを"
"返します。\n"
"\n"

#: vulnerabilities.py:537
msgid "Insecure SSLSocketFactories"
msgstr "安全でないSSLSocketFactories"

#: vulnerabilities.py:538
msgid "Does the application have a probable SSL error in implementation?"
msgstr ""
"このアプリケーションは実装中にSSLエラーが発生する可能性がありませんか？"

#: vulnerabilities.py:539
msgid "No implementation errors were found."
msgstr "実装エラーは見つかりませんでした。"

#: vulnerabilities.py:540
msgid ""
"\n"
"Android SDK 4.0 and later offers packages to implement capabilities to\n"
"establish network connections. For example, by using `java.net`\n"
"`javax.net` `android.net` `org.apache.http` a developer can create server\n"
"sockets or HTTP connection. `org.webkit` offers functions necessary to\n"
"implement web browsing capabilities.\n"
"\n"
"A developer has the freedom to customize their SSL implementation. The\n"
"developer should properly use SSL as appropriate to the intent of the\n"
"app and the environment the apps are used in.\n"
"\n"
"On Android, using `HttpURLConnection` is recommended for HTTP client\n"
"implementation.\n"
msgstr ""
"\n"
"Android SDK 4.0以降には、ネットワーク接続を確立するための機能を実装するための"
"パッケージが用意されています。例えば、java.net, javax.net, android.net org."
"apache.httpを使用することで、開発者はサーバーソケットまたはHTTP接続を作成でき"
"ます。org.webkitは、Webブラウジング機能を実装するために必要な機能を提供しま"
"す。\n"
"\n"
"開発者は自由にSSL実装をカスタマイズすることができます。開発者は、アプリケー"
"ションのインテントとアプリケーションが使用されている環境に対して適切にSSLを使"
"用する必要があります。\n"
"\n"
"Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨"
"されています。\n"
"\n"

#: vulnerabilities.py:554
msgid ""
"\n"
"SSL Implementations are not proper in this application\n"
msgstr ""
"\n"
"SSL実装はこのアプリケーションにおいて適切ではありません。\n"

#: vulnerabilities.py:557 vulnerabilities.py:696
msgid ""
"\n"
"If proper implementation of SSL is not used, sensitive data may leak\n"
"from the vulnerable SSL communication channel.\n"
msgstr ""
"\n"
"SSLの適切な実装が使用されない場合、脆弱なSSL通信チャネルから機密データが漏洩"
"する可能性があります。\n"

#: vulnerabilities.py:561
msgid ""
"\n"
"The compliant solution may vary, depending on the actual implementation.\n"
"For examples of secure implementation such as using a self-signed server\n"
"certificate, please refer to [Android Application Secure Design/Secure\n"
"Coding Guidebook](http://www.jssec.org/dl/android_securecoding.pdf),\n"
"Section 5.4 Communicate by HTTPS.\n"
msgstr ""
"\n"
"準拠したソリューションは、実際の実装に応じて変わる場合があります。自己署名"
"サーバ証明書を使用するなどの安全な実装の例については、[Android Application "
"Secure Design/Secure Coding Guidebook](http://www.jssec.org/dl/"
"android_securecoding.pdf)のセクション5.4 HTTPSで通信するを参照してくださ"
"い。\n"
"\n"

#: vulnerabilities.py:568
msgid ""
"\n"
"The following code implements a custom MySSLSocketFactory class that\n"
"inherits `javax.net.ssl.SSLContext`:\n"
"\n"
"    public class InsecureSocketFactory extends SSLSocketFactory {\n"
"        protected SSLSocketFactory _factory;\n"
"        public InsecureSocketFactory() {\n"
"            try {\n"
"                SSLContext ctx = SSLContext.getInstance(\"SSL\");\n"
"                ctx.init(null, new TrustManager[] { new "
"InsecureTrustManager() }, null);\n"
"                _factory = ctx.getSocketFactory();\n"
"            } catch (Exception e) {\n"
"                throw new RuntimeException(e);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"In the example above, the `InsecureSocketFactory` accepts all certificates\n"
"silently, which even bypasses the check for trustmanagers\n"
msgstr ""
"\n"
"次のコードは、 `javax.net.ssl.SSLContext`を継承するカスタムの"
"MySSLSocketFactory クラスを実装しています。：\n"
"\n"
"\n"
"    public class InsecureSocketFactory extends SSLSocketFactory {\n"
"        protected SSLSocketFactory _factory;\n"
"        public InsecureSocketFactory() {\n"
"            try {\n"
"                SSLContext ctx = SSLContext.getInstance(\"SSL\");\n"
"                ctx.init(null, new TrustManager[] { new "
"InsecureTrustManager() }, null);\n"
"                _factory = ctx.getSocketFactory();\n"
"            } catch (Exception e) {\n"
"                throw new RuntimeException(e);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"上記の例では、 `InsecureSocketFactory`はすべての証明書を黙って受け取り、"
"trustmanager のチェックをバイパスします。\n"

#: vulnerabilities.py:606
msgid "HostnameVerifier Allowing All Hostnames"
msgstr "すべてのホスト名を許可する HostnameVerifier"

#: vulnerabilities.py:607
msgid "Does the application have AllowAllHostnameVerification?"
msgstr "このアプリケーションは AllowAllHostnameVerification がありますか?"

#: vulnerabilities.py:608
msgid "AllowAllHostname is properly configured, or is disabled."
msgstr "AllowAllHostname が正しく構成されているか、または無効になっています。"

#: vulnerabilities.py:609
msgid ""
"\n"
"Android apps that use SSL/TLS protocols for secure communication should\n"
"properly verify server certificates which should verify that the subject\n"
"(CN) of X.509 certificate and the URL matches\n"
"\n"
"Allowing All Hostnames: The app does not verify if the certificate\n"
"issued is for the URL the client is connecting to. For example, when a\n"
"client connects to example.com, it will accept a server certificate\n"
"issued for some-other-domain.com.\n"
"\n"
"On Android, using `HttpURLConnection` is recommended for HTTP client\n"
"implementation.\n"
msgstr ""
"\n"
"安全な通信のためにSSL/TLSプロトコルを使用するAndroidアプリは、X.509証明書の"
"subject(CN)とURLが一致することを確認するサーバ証明書を正しく検証する必要があ"
"ります。\n"
"\n"
"すべてのホスト名を許可: アプリケーションは、発行された証明書がクライアントが"
"接続しているURL用であるかどうかを検証しません。例えば、クライアントがexample."
"comに接続すると、some-other-domain.comに対して発行されたサーバ証明書を受け入"
"れます。\n"
"\n"
"Androidでは、HTTPクライアントの実装にはHttpURLConnectionを使用することが推奨"
"されています。\n"
"\n"

#: vulnerabilities.py:622
msgid ""
"\n"
"Implements AllowAllHostname verifier which might allow hacker to\n"
"eavesdrop into the connection.\n"
msgstr ""
"\n"
"ハッカーに盗聴される可能性がある AllowAllHostnameVerifierを実装しています。\n"

#: vulnerabilities.py:635
msgid ""
"\n"
"Never use `SSLSocketFactory.ALLOW\\_ALL\\_HOSTNAME\\_VERIFIER` in\n"
"production code\n"
"\n"
"Please refer to [Android Application Secure Design/Secure Coding\n"
"Guidebook](http://www.jssec.org/dl/android_securecoding.pdf), Section\n"
"5.4 Communicate by HTTPS.\n"
msgstr ""
"\n"
"プロダクションコードでは、`SSLSocketFactory.ALLOW\\_ALL\\_HOSTNAME"
"\\_VERIFIER` を絶対に使用しないでください。 \n"
"\n"
"[Android Application Secure Design/Secure Coding Guidebook](http://www.jssec."
"org/dl/android_securecoding.pdf) のセクション5.4 HTTPSで通信するを参照してく"
"ださい。\n"
"\n"

#: vulnerabilities.py:643
msgid ""
"\n"
"The following code extends `HttpClient` class that inherits\n"
"`javax.net.ssl.SSLContext`:\n"
"\n"
"    public void allowAllHostnameVerifier() {\n"
"        SSLSocketFactory sf = null;\n"
"\n"
"        sf.setHostnameVerifier(SSLSocketFactory."
"ALLOW_ALL_HOSTNAME_VERIFIER);\n"
"    }\n"
"\n"
"This will enable the use of\n"
"`SSLSocketFactory.ALLOW\\_ALL\\_HOSTNAME\\_VERIFIER` as a result, host\n"
"name verification that should take place when establishing an SSL\n"
"connection is disabled and will lead to the same situation as all the\n"
"certificate is trusted.\n"
msgstr ""
"\n"
"次のコードは、javax.net.ssl.SSLContextを継承するHttpClientクラスを拡張してい"
"ます。：\n"
"\n"
"    public void allowAllHostnameVerifier() {\n"
"        SSLSocketFactory sf = null;\n"
"\n"
"        sf.setHostnameVerifier(SSLSocketFactory."
"ALLOW_ALL_HOSTNAME_VERIFIER);\n"
"    }\n"
"\n"
"これにより、結果として `SSLSocketFactory.ALLOW \\ _ ALL \\ _ HOSTNAME \\ _ "
"VERIFIER`を使用できるようになります。\n"
"SSL接続の確立時に行われるホスト名の検証は無効になり、すべての証明書が信頼され"
"るのと同じ状況になります。\n"
"\n"

#: vulnerabilities.py:677
msgid "App Extending WebViewClient"
msgstr "アプリケーション WebViewClient の拡張"

#: vulnerabilities.py:678
msgid ""
"Does the application use WebViewClients correctly and handle the "
"onReceivedSSLError method?"
msgstr ""
"このアプリケーションは、onreceivedsslerrorメソッドを正しく処理する"
"WebViewClientを使用していますか?"

#: vulnerabilities.py:679
msgid ""
"Application seems to be handling WebViewClient correctly, or has no "
"implementation of WebViewClient."
msgstr ""
"アプリケーションはWebViewClientを正しく処理していないか、もしくはアプリケー"
"ションにWebViewClientの実装がないようです。"

#: vulnerabilities.py:680
msgid ""
"\n"
"WebViews can introduce a number of security concerns and should be\n"
"implemented carefully. In particular, many vulnerabilities have been\n"
"discovered that exploit the use of the addJavscriptInterface API and\n"
"bypassing onReceivedSslError check.\n"
"\n"
"WebView does support SSL/TLS, however, the blank screen is an indication\n"
"that the WebView does not believe that the certificate is valid. This\n"
"may happen with a certificate that is self-signed or a from a root auth\n"
"that is not set up in android. However if that check is bypassed, then\n"
"it removes all security from SSL.\n"
msgstr ""
"\n"
"WebViewsはセキュリティ上の懸念事項を多数もたらすことができ、慎重に実装する必"
"要があります。特に、多くの脆弱性がaddJavscriptInterface APIの使用と"
"onReceivedSslErrorチェックのバイパスを利用しているのが発見されています。\n"
"\n"
"WebViewはSSL/TLSをサポートしていますが、空白の画面はWebViewが証明書が有効であ"
"るとは信じていないことを示しています。これは自己署名証明書やアンドロイドに設"
"定されていないルート認証からの証明書で発生する可能性があります。ただし、その"
"チェックをバイパスすると、SSLからすべてのセキュリティーが削除されます。\n"
"\n"

#: vulnerabilities.py:692
msgid ""
"\n"
"The default handling of WebViewClient should handle the\n"
"onReceivedSSLError properly, which might break certificate validation\n"
msgstr ""
"\n"
"WebViewClient のデフォルトの処理は、証明書検証を中断する可能性がある"
"onReceivedSSLError を適切に処理するべきです。\n"

#: vulnerabilities.py:700
msgid ""
"\n"
"This can be fixed by using the onReceivedSslError to stop or notify the\n"
"user and the application.\n"
"\n"
"    public void onReceivedSslError(WebView view, SslErrorHandler handler, "
"SslError error)  {\n"
"        //STOP OR ALERT THE USER\n"
"    }\n"
msgstr ""
"\n"
"これは、onReceivedSslErrorを使用してユーザとアプリケーションを停止または通知"
"することで修正できます。\n"
"\n"
"    public void onReceivedSslError(WebView view, SslErrorHandler handler, "
"SslError error)  {\n"
"        //STOP OR ALERT THE USER\n"
"    }\n"
"\n"

#: vulnerabilities.py:708
msgid ""
"\n"
"The following code shows how onReceivedSslError was used to bypass the\n"
"check in WebViewClient:\n"
"\n"
"    public class SSLAcceptingWebViewClient extends CordovaWebViewClient {\n"
"        public SSLAcceptingWebViewClient(DroidGap ctx) {\n"
"            super(ctx);\n"
"        }\n"
"        @Override\n"
"        public void onReceivedSslError(WebView view, SslErrorHandler "
"handler, SslError error) {\n"
"            //proceed or pass\n"
"            handler.proceed(); // Ignore SSL certificate errors\n"
"        }\n"
"\n"
"    }\n"
"\n"
msgstr ""
"\n"
"次のコードは、onReceivedSslError を使用して WebViewClient のチェックをバイパ"
"スする方法を示しています。\n"
"\n"
"    public class SSLAcceptingWebViewClient extends CordovaWebViewClient {\n"
"        public SSLAcceptingWebViewClient(DroidGap ctx) {\n"
"            super(ctx);\n"
"        }\n"
"        @Override\n"
"        public void onReceivedSslError(WebView view, SslErrorHandler "
"handler, SslError error) {\n"
"            //proceed or pass\n"
"            handler.proceed(); // Ignore SSL certificate errors\n"
"        }\n"
"\n"
"    }\n"
"\n"

#: vulnerabilities.py:743
msgid "Unused Permissions"
msgstr "未使用のパーミッション"

#: vulnerabilities.py:744
msgid "Is the application over-privileged?"
msgstr "このアプリケーションの権限は特権ですか？"

#: vulnerabilities.py:745
msgid ""
"Application seems to have just the essential set of permissions required."
msgstr ""
"アプリケーションに必須なパーミッションのセットだけを持っているようです。"

#: vulnerabilities.py:746
msgid ""
"\n"
"An app might request a user for certain permissions, like access to SD\n"
"card, contacts, social profiles, etc. which has not actually been\n"
"invoked while the scan was running. We list out all these permissions so\n"
"that you can optimize your app and follow proper compliance checks.\n"
msgstr ""
"\n"
"スキャンが実行されている間に実際に呼び出されていないSDカード、連絡先、ソー"
"シャルプロファイルなどへのアクセスのような特定のパーミッションをアプリケー"
"ションはユーザに要求することがあります。あなたがアプリを最適化し、適切なコン"
"プライアンスチェックを行うことができるために、全てのパーミッションをリストア"
"ウトします。\n"
"\n"

#: vulnerabilities.py:752
msgid ""
"\n"
"Application seems to be using extra permissions which are not really\n"
"needed\n"
msgstr ""
"\n"
"アプリケーションは実際には必要ない余分なパーミッションを使用しているようで"
"す。\n"

#: vulnerabilities.py:756
msgid ""
"\n"
"Users may not download your app when presented with a long list of\n"
"permissions. Imagine a flashlight app requesting access to SD card,\n"
"camera, contacts, SMS and more. This is an invitation to poor ratings\n"
"and reviews on App Stores. This also breaks compliance standards.\n"
msgstr ""
"\n"
"ユーザは、パーミッションの長いリストが表示されている場合は、あなたのアプリ"
"ケーションをダウンロードしないことがあります。SDカード、カメラ、連絡先、SMSな"
"どへのアクセスを要求する懐中電灯アプリを想像してみてください。これは、App "
"Storeの乏しい評価やレビューへの招待状です。これはコンプライアンス基準も破りま"
"す。\n"
"\n"

#: vulnerabilities.py:762
msgid ""
"\n"
"Do not request for permissions beyond what your app actually needs\n"
msgstr ""
"\n"
"あなたのアプリケーションが実際に必要とするもの以外のパーミッションを要求しな"
"いでください。\n"
"\n"

#: vulnerabilities.py:775
msgid "JavascriptInterface Remote Code Execution"
msgstr "JavascriptInterfaceリモートコードの実行"

#: vulnerabilities.py:776
msgid ""
"Is the application using JavascriptInterface? Does the application "
"communicate over non-SSL or broken SSL Implementation?"
msgstr ""
"あなたのアプリケーションはJavascriptInterfaceを使用していますか?このアプリ"
"ケーションはnon-SSL経由かSSL実装が壊れていませんか?"

#: vulnerabilities.py:777
msgid ""
"Application is safe from remote code execution through JavascriptInterface."
msgstr ""
"アプリケーションはJavascriptInterfaceを介したリモートコード実行からは安全で"
"す。"

#: vulnerabilities.py:778
msgid ""
"\n"
"For API level JELLY\\_BEAN or below, allowing an app to use the\n"
"addJavascriptInterface method with untrusted content in a WebView leaves\n"
"the app vulnerable to scripting attacks using reflection to access\n"
"public methods from JavaScript. Untrusted content examples include\n"
"content from any HTTP URL (as opposed to HTTPS) and user-provided\n"
"content. The method `addJavascriptInterface(Object, String)` is called\n"
"from the `android.webkit.WebView` class. Sensitive data and app control\n"
"should not be exposed to scripting attacks.\n"
msgstr ""
"\n"
"APIレベルJELLY_BEAN以下にとっては、アプリケーションにWebView内の信頼できない"
"コンテンツでaddJavascriptInterfaceを使用することを許可することは、Javaからパ"
"ブリックメソッドにアクセスするためのリフレクションを使用したスクリプト攻撃に"
"対する脆弱性をアプリケーションに残します。信頼されていないコンテンツの例に"
"は、HTTP URL(HTTPSと対するもの)とユーザ提供のコンテンツが含まれます。メソッド"
"addJavascriptInterface(Object, String)は、android.webkit.WebViewクラスから呼"
"び出されます。機密データとアプリケーションコントロールは、スクリプト攻撃にさ"
"らされるべきではありません。\n"
"\n"

#: vulnerabilities.py:788
msgid ""
"\n"
"Application seems to use `JavascriptInterface`. An attacker can use it to\n"
"do a Remote Code Execution on your application and steal sensitive\n"
"informations.\n"
msgstr ""
"\n"
"アプリケーションはJavascriptInterfaceを使用しているようです。これを使用して攻"
"撃者はあなたのアプリケーションに対してリモートでコードの実行を行い、機密情報"
"を盗むことができます。\n"

#: vulnerabilities.py:793
msgid ""
"\n"
"The app may be susceptible to JavaScript scripting attacks from\n"
"user-supplied content or content from HTTP causing loss of sensitive\n"
"information.\n"
msgstr ""
"\n"
"このアプリは、ユーザ提供のコンテンツやHTTPのコンテンツからのJavaScriptスクリ"
"プト攻撃の影響を受けやすく、機密情報が失われる可能性があります。\n"

#: vulnerabilities.py:798
msgid ""
"\n"
"-   Compliant code could refrain from calling the addJavascriptInterface() "
"method.\n"
"\n"
"        WebView webView = new WebView(this);\n"
"        setContentView(webView);\n"
"\n"
"-   Another compliant solution is to specify in the app's manifest that\n"
"    the app is only for API levels JELLY\\_BEAN\\_MR1 and above. For these\n"
"    API levels, only public methods that are annotated with\n"
"    JavascriptInterface can be accessed from JavaScript. API level 17\n"
"    is JELLY\\_BEAN\\_MR1.\n"
"\n"
"        <manifest>\n"
"            <uses-sdk android:minSdkVersion=\"17\" />\n"
"            ...\n"
"        </manifest>\n"
"\n"
msgstr ""
"\n"
"- 準拠しているコードでは、addJavascriptInterface()メソッドの呼び出しを控える"
"ことができます。\n"
"\n"
"        WebView webView = new WebView(this);\n"
"        setContentView(webView);\n"
"\n"
"- もう1つの準拠した解決策は、アプリケーションがAPIレベルJELLY_BEAN_MR1以上の"
"み用であることをアプリケーションのマニフェストに指定することです。これらのAPI"
"レベルに対しては、JavascriptInterfaceでアノテーションされたパブリックメソッド"
"のみがJavaScriptからアクセスできます。APIレベル17はJELLY_BEAN_MR1で"
"す。     \n"
"\n"
"        <manifest>\n"
"            <uses-sdk android:minSdkVersion=\"17\" />\n"
"            ...\n"
"        </manifest>\n"
"\n"

#: vulnerabilities.py:816
msgid ""
"\n"
"This non-compliant code example shows an application that calls the\n"
"`addJavascriptInterface()` method, and hence is not secure for API level\n"
"JELLY\\_BEAN and lower.\n"
"\n"
"    WebView webView = new WebView(this);\n"
"    setContentView(webView);...\n"
"    class JsObject {\n"
"        private String sensitiveInformation;\n"
"        ...\n"
"        public String toString() {\n"
"            return sensitiveInformation;\n"
"        }\n"
"    }\n"
"    webView.addJavascriptInterface(new JsObject(), \"injectedObject\");\n"
"    webView.loadData(\"\", \"text/html\", null);\n"
"    webView.loadUrl(\"http://www.example.com\");\n"
"\n"
"JavaScript can now control the host. Java reflection could be used to\n"
"access any of the public methods of an injected object, using the\n"
"permissions of the app.\n"
msgstr ""
"\n"
"この非準拠のコード例は、 `addJavascriptInterface（）`メソッドを呼び出すアプリ"
"ケーションを示しているため、APIレベル JELLY \\ _ BEAN 以下では安全ではありま"
"せん。\n"
"\n"
"    WebView webView = new WebView(this);\n"
"    setContentView(webView);...\n"
"    class JsObject {\n"
"        private String sensitiveInformation;\n"
"        ...\n"
"        public String toString() {\n"
"            return sensitiveInformation;\n"
"        }\n"
"    }\n"
"    webView.addJavascriptInterface(new JsObject(), \"injectedObject\");\n"
"    webView.loadData(\"\", \"text/html\", null);\n"
"    webView.loadUrl(\"http://www.example.com\");\n"
"\n"
"JavaScript がホストを制御できるようになりました。 Javaリフレクションは、アプ"
"リケーションのパーミッションを使用して、注入されたオブジェクトの public メ"
"ソッドにアクセスするために使用できます。\n"

#: vulnerabilities.py:847
msgid "Unprotected Activities"
msgstr "保護されていないアクティビティ"

#: vulnerabilities.py:848
msgid "Are application activities protected?"
msgstr "アプリケーションのアクティビティは保護されていますか？"

#: vulnerabilities.py:849
msgid "Activities seem to be sufficiently protected."
msgstr "アクティビティは十分に保護されているようです。"

#: vulnerabilities.py:850
msgid ""
"\n"
"On Android, declaring an intent filter for an activity in the\n"
"`AndroidManifest.xml` file means that the activity may be exported to\n"
"other apps. If the activity is intended solely for the internal use of\n"
"the app and an intent filter is declared, then any other apps, including\n"
"malware, can activate the activity for unintended use.\n"
"\n"
"In the case of the vulnerability in the Twicca app (in versions 0.7.0\n"
"through 0.9.30), by launching Twicca's activity, another app that does\n"
"not have permission to access the SD card or network could upload images\n"
"or movies stored on the SD card to a social networking service with the\n"
"Twicca user's Twitter account.\n"
msgstr ""
"\n"
" Androidでは、AndroidManifest.xmlファイル内のアクティビティのインテントフィル"
"タを宣言することは、アクティビティが他のアプリケーションにエクスポートされる"
"可能性があることを意味します。もしアクティビティが単にアプリケーションの内部"
"使用のみを意図していて、インテントフィルタが宣言されていたら、マルウェアを含"
"む他のアプリケーションは、意図しない使用のためにアクティビティをアクティベー"
"トすることができます。</p>  <p>     Twiccaアプリ（バージョン0.7.0から0.9.30ま"
"で）の脆弱性の場合、Twiccaのアクティビティを起動すると、SDカードやネットワー"
"クにアクセスするパーミッションを持たない別のアプリは、TwiccaユーザのTwitterア"
"カウントを使用して、SDカードに保存されている画像や動画をソーシャルネットワー"
"キングサービスにアップロードできました。\n"
"\n"

#: vulnerabilities.py:863
msgid ""
"\n"
"An activity was found to be shared with other apps on the device without\n"
"an intent filter or a permission requirement, therefore leaving it\n"
"accessible to any other application on the device.\n"
msgstr ""
"\n"
"アクティビティはインテントフィルタまたパーミッション要求なしでデバイス上の他"
"のアプリケーションと共有されているため、デバイス上の他のアプリケーションから"
"アクセス可能な状態になっています。\n"

#: vulnerabilities.py:868
msgid ""
"\n"
"Unauthorized apps may use vulnerable activities to perform malicious\n"
"actions.\n"
msgstr ""
"\n"
" 許可されていないアプリケーションは、悪意のあるアクションを実行するために脆弱"
"なアクティビティを使用することがあります。\n"
"\n"

#: vulnerabilities.py:872
msgid ""
"\n"
"-   In this compliant solution the activity is not exported:\n"
"\n"
"    <activity\n"
"        android:configChanges=\"keyboard|keyboardHidden|orientation\"\n"
"        android:name=\".media.yfrog.YfrogUploadDialog\"\n"
"        android:theme=\"@style/ VulnerableTheme.Dialog\"\n"
"        android:windowSoftInputMode=\"stateAlwaysHidden\"\n"
"        android:exported=\"false\">\n"
"    </activity>\n"
"\n"
"    By declaring android:exported=\"false\" for an activity tag in the\n"
"    AndroidManifest.xml file, the activity is restricted to only accept\n"
"    intents from within the same app or from an app with the same\n"
"    user ID.\n"
"\n"
"-   This vulnerability was fixed in Twicca v0.9.31. Instead of declaring\n"
"    the activity exported=\"false\" in AndroidManifest.xml, Twicca fixed\n"
"    this vulnerability by validating the caller of this activity. In\n"
"    the onCreate() method of the activity class, code was added to check\n"
"    if the package name of the caller is the same as the package name\n"
"    of itself. If the package names are different, the activity exits:\n"
"\n"
"    public void onCreate(Bundle arg5) {\n"
"        super.onCreate(arg5);\n"
"        ...\n"
"        ComponentName v0 = this.getCallingActivity();\n"
"        if (v0 == null) {\n"
"            this.finish();\n"
"        } else if (!jp.r246.twicca.equals(v0.getPackageName())) {\n"
"            this.finish();\n"
"        } else {\n"
"            this.a = this.getIntent().getData();\n"
"            if (this.a == null) {\n"
"                this.finish();\n"
"            }\n"
"            ...\n"
"        }\n"
"    }\n"
"\n"
"An Android developer can arbitrarily choose a package name, so\n"
"different app developers could choose the same package name.\n"
"Therefore, it is generally not recommended to use the package name\n"
"for validating the caller of the activity. The recommended\n"
"alternative is to check the developer's certificate, instead of the\n"
"package name.\n"
"\n"
"However, considering the following facts, Twicca's solution may be\n"
"logical and safe against the exploit:\n"
"\n"
"- Only one app with a particular package name can exist on\n"
"  Google Play.\n"
"\n"
"- If a user tries to install an app whose package name already\n"
"  exists on the device, the installation either will fail or will\n"
"  overwrite the previously installed app.\n"
"\n"
msgstr ""
"\n"
"この準拠ソリューションでは、アクティビティはエクスポートされません。\n"
"\n"
"    <activity\n"
"        android:configChanges=\"keyboard|keyboardHidden|orientation\"\n"
"        android:name=\".media.yfrog.YfrogUploadDialog\"\n"
"        android:theme=\"@style/ VulnerableTheme.Dialog\"\n"
"        android:windowSoftInputMode=\"stateAlwaysHidden\"\n"
"        android:exported=\"false\">\n"
"    </activity>\n"
"\n"
"AndroidManifest.xmlファイル内のactivityタグに対してandroid:exported=\"false"
"\"を宣言することにより、アクティビティは同じアプリケーション内、または同じ"
"ユーザIDのアプリケーションからのインテントのみを受け入れるように制限されま"
"す。\n"
"\n"
"    public void onCreate(Bundle arg5) {\n"
"        super.onCreate(arg5);\n"
"        ...\n"
"        ComponentName v0 = this.getCallingActivity();\n"
"        if (v0 == null) {\n"
"            this.finish();\n"
"        } else if (!jp.r246.twicca.equals(v0.getPackageName())) {\n"
"            this.finish();\n"
"        } else {\n"
"            this.a = this.getIntent().getData();\n"
"            if (this.a == null) {\n"
"                this.finish();\n"
"            }\n"
"            ...\n"
"        }\n"
"    }\n"
"\n"
"Android開発者は、任意にパッケージ名を選択できるため、異なるアプリケーション開"
"発者は同じパッケージ名を選択できました。したがって、通常はアクティビティの呼"
"び出し元を検証するためにパッケージ名を使用することは推奨されません。推奨され"
"ている代案は、パッケージ名の代わりに開発者の証明書を確認することです。\n"
"\n"
"しかし、以下の事実を考慮すると、Twiccaのソリューションは、論理的でエクスプロ"
"イトに対して安全である可能性があります。:\n"
"\n"
"- 特定のパッケージ名を持つ1つのアプリのみがGoogle Playに存在することができま"
"す。\n"
"- もしユーザがパッケージ名が既にデバイス上に存在するアプリケーションをインス"
"トールしようとすると、インストールが失敗するか、以前にインストールされたアプ"
"リケーションを上書きします。\n"
"\n"

#: vulnerabilities.py:930
msgid ""
"\n"
"This non-compliant code example shows an `AndroidManifest.xml` file for an\n"
"application that exports the activity to other apps, but does not\n"
"restrict access to its sensitive activity:\n"
"\n"
"    <activity\n"
"        android:configChanges=\"keyboard|keyboardHidden|orientation\"\n"
"        android:name=\".media.yfrog.YfrogUploadDialog\"\n"
"        android:theme=\"@style/Vulnerable.Dialog\"\n"
"        android:windowSoftInputMode=\"stateAlwaysHidden\">\n"
"        <intent-filter android:icon=\"@drawable/yfrog_icon\" android:label="
"\"@string/YFROG\">\n"
"            <action android:name=\"jp.co.vulnerable.ACTION_UPLOAD\" />\n"
"            <category android:name=\"android.intent.category.DEFAULT\" />\n"
"            <data android:mimeType=\"image/*\" />\n"
"            <data android:mimeType=\"video/*\" />\n"
"        </intent-filter>\n"
"    </activity>\n"
"\n"
"`android:name` refers to the name of the class that implements this\n"
"activity. The name of the package is `jp.co.vulnerable` so the fully\n"
"qualified name of the class implementing this activity is\n"
"`jp.co.vulnerable.media.yfrog.YfrogUploadDialog`. Since the intent filter\n"
"is defined, this activity is exported to other apps.\n"
msgstr ""
"\n"
" この非準拠のコード例は、アクティビティを他のアプリケーションにエクスポートす"
"るアプリケーションのAndroidManifest.xmlファイルを示していますが、機密性の高い"
"アクティビティへのアクセスを制限しません。: \n"
"\n"
"    <activity\n"
"        android:configChanges=\"keyboard|keyboardHidden|orientation\"\n"
"        android:name=\".media.yfrog.YfrogUploadDialog\"\n"
"        android:theme=\"@style/Vulnerable.Dialog\"\n"
"        android:windowSoftInputMode=\"stateAlwaysHidden\">\n"
"        <intent-filter android:icon=\"@drawable/yfrog_icon\" android:label="
"\"@string/YFROG\">\n"
"            <action android:name=\"jp.co.vulnerable.ACTION_UPLOAD\" />\n"
"            <category android:name=\"android.intent.category.DEFAULT\" />\n"
"            <data android:mimeType=\"image/*\" />\n"
"            <data android:mimeType=\"video/*\" />\n"
"        </intent-filter>\n"
"    </activity>\n"
"\n"
"`android：name`はこのアクティビティを実装するクラスの名前を参照します。 パッ"
"ケージの名前は `jp.co.vulnerable`なので、このアクティビティを実装するクラスの"
"完全修飾名は ` jp.co.vulnerable.media.yfrog.YfrogUploadDialog` です。 インテ"
"ントフィルタが定義されているため、このアクティビティは他のアプリケーションに"
"エクスポートされます。\n"
"\n"

#: vulnerabilities.py:954
msgid ""
"\n"
"- [JVN\\#31860555](https://jvn.jp/en/jp/JVN31860555/) Twicca fails to\n"
"  restrict access permissions\n"
"\n"
msgstr ""
"\n"
"- [JVN\\#31860555](https://jvn.jp/en/jp/JVN31860555/) Twiccaはアクセス権を制"
"限しません。\n"

#: vulnerabilities.py:968
msgid "SQL Injection"
msgstr "SQLインジェクション"

#: vulnerabilities.py:969
msgid "Is the application vulnerable to SQL Injection through Web API?"
msgstr ""
"アプリケーションはWeb APIを通じたSQLインジェクションに対して脆弱ではありませ"
"んか？"

#: vulnerabilities.py:970
msgid "Application is not vulnerable to SQL Injection through Web API."
msgstr ""
"アプリケーションはWeb APIを通じたSQLインジェクションに対して脆弱ではありませ"
"ん。"

#: vulnerabilities.py:971
msgid ""
"\n"
"An SQL injection vulnerability arises when the original SQL query can be\n"
"altered to form an altogether different query. Execution of this altered\n"
"query may result in information leaks or data modification. The primary\n"
"means of preventing SQL injection are validating and sanitizing user\n"
"input, and parameterizing the query.\n"
msgstr ""
"\n"
"SQLインジェクションの脆弱性は、元のSQLクエリを変更して全く異なるクエリを作成"
"できる場合に発生します。 この変更されたクエリを実行すると、情報が漏洩したり、"
"データが変更される可能性があります。 SQLインジェクションを防止する主な手段"
"は、ユーザー入力の検証とサニタイズ、およびクエリのパラメータ化です。\n"

#: vulnerabilities.py:978
msgid ""
"\n"
"Data retrieved from a mobile app's server contains malformed data that\n"
"results in a SQL injection within the mobile device's local databases.\n"
"Local SQL injections may result in local malware injection, information\n"
"theft, and more\n"
msgstr ""
"\n"
"モバイルアプリケーションのサーバーから取得したデータに不正なデータが含まれて"
"いると、モバイルデバイスのローカルデータベース内でSQLインジェクションが発生す"
"る可能性があります。ローカルのSQLインジェクションは、ローカルのマルウェア注"
"入、情報の盗難などを招く可能性があります。\n"

#: vulnerabilities.py:984
msgid ""
"\n"
"SQL injection allows the intruder to view and modify data contained in\n"
"the database. The attacker could also gain much higher privileges over\n"
"the database over time thus compromising the confidentiality and\n"
"integrity of the data stored.\n"
msgstr ""
"\n"
"SQLインジェクションにより、侵入者はデータベースに含まれるデータを表示および変"
"更できます。 さらに攻撃者はデータベース上で、時間の経過とともにより高い権限を"
"得ることができ、格納されたデータの機密性と完全性を損なう可能性があります。\n"

#: vulnerabilities.py:990
msgid ""
"\n"
"Input validation is a prerequisite for proper query construction. This\n"
"compliant solution validates the length of the username and password\n"
"arguments. It also uses a java.sql.PreparedStatement instead of\n"
"java.sql.Statement.\n"
"\n"
"    class Login {\n"
"        public void doPrivilegedAction(String username, String password) "
"throws SQLException {\n"
"\n"
"            // ensure that the length of username and password is "
"legitimate\n"
"            if ((username.length() >= 8) || (password.length() >= 20)) {\n"
"                // handle error\n"
"                ...\n"
"            }\n"
"\n"
"            DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver."
"SQLServerDriver());\n"
"            Connection connection = DriverManager.getConnection(\"jdbc:"
"microsoft:sqlserver://:1433\", \"\", \"\");\n"
"\n"
"            if (connection != null) {\n"
"                String sql = \"select * from db_user where username=? and "
"password=?\";\n"
"\n"
"                // use PreparedStatement for type enforcement\n"
"                PreparedStatement stmt = connection.prepareStatement(sql);\n"
"                stmt.setString(1, username);\n"
"                stmt.setString(2, password);\n"
"                ResultSet rs = stmt.executeQuery();\n"
"\n"
"                if (!rs.next()) {\n"
"                    throw new SecurityException(\"User name or Password "
"incorrect\");\n"
"                }\n"
"                // we've authenticated; proceed\n"
"                ...\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
msgstr ""
"\n"
"入力検証は、適切なクエリ構築の前提条件です。 この準拠のソリューションは、ユー"
"ザー名とパスワードの引数の長さを検証します。 また、java.sql.Statement の代わ"
"りに java.sql.PreparedStatement も使用します。\n"
"\n"
"    class Login {\n"
"        public void doPrivilegedAction(String username, String password) "
"throws SQLException {\n"
"\n"
"            // ensure that the length of username and password is "
"legitimate\n"
"            if ((username.length() >= 8) || (password.length() >= 20)) {\n"
"                // handle error\n"
"                ...\n"
"            }\n"
"\n"
"            DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver."
"SQLServerDriver());\n"
"            Connection connection = DriverManager.getConnection(\"jdbc:"
"microsoft:sqlserver://:1433\", \"\", \"\");\n"
"\n"
"            if (connection != null) {\n"
"                String sql = \"select * from db_user where username=? and "
"password=?\";\n"
"\n"
"                // use PreparedStatement for type enforcement\n"
"                PreparedStatement stmt = connection.prepareStatement(sql);\n"
"                stmt.setString(1, username);\n"
"                stmt.setString(2, password);\n"
"                ResultSet rs = stmt.executeQuery();\n"
"\n"
"                if (!rs.next()) {\n"
"                    throw new SecurityException(\"User name or Password "
"incorrect\");\n"
"                }\n"
"                // we've authenticated; proceed\n"
"                ...\n"
"            }\n"
"        }\n"
"    }\n"
"\n"

#: vulnerabilities.py:1027
msgid ""
"\n"
"This non-compliant code example shows JDBC code that is vulnerable to\n"
"SQL injection. The SQL statement SQL accepts unsanitized input\n"
"arguments.\n"
"\n"
"    class Login {\n"
"        public void doPrivilegedAction(String username, String password) "
"throws SQLException {\n"
"\n"
"            DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver."
"SQLServerDriver());\n"
"            Connection connection = DriverManager.getConnection(\n"
"                \"jdbc:microsoft:sqlserver://<HOST>:1433\", \"<UID>\", "
"\"<PWD>\");\n"
"\n"
"            if (connection != null) {\n"
"                String sql = \"select * from db_user where username = '\" + "
"username +\n"
"                    \"' and password = '\" + password + \"'\";\n"
"\n"
"                Statement stmt = connection.createStatement();\n"
"                ResultSet rs = stmt.executeQuery(sql);\n"
"                if (!rs.next()) {\n"
"                    throw new SecurityException(\"User name or Password "
"incorrect\");\n"
"                }\n"
"                // Authenticated; proceed\n"
"            }\n"
"        }\n"
"        ...\n"
"\n"
"If the attacker enters a valid user name securecoding and enters 'OR\n"
"username = 'securecoding for the password argument, the SQL statement\n"
"evaluates to select \\* from db\\_user where username = '' OR username =\n"
"'securecoding' and password='', consequently bypassing the login\n"
"password check. Similarly, an input ofsomeuser' OR '1' = '1 would bypass\n"
"both the user name and password checks, granting the attacker\n"
"unrestricted access.\n"
msgstr ""
"\n"
"この非準拠のコード例は、SQLインジェクションに対して脆弱なJDBCコードを示してい"
"ます。 SQLステートメントは、入力引数を受け入れます。\n"
"\n"
"    class Login {\n"
"        public void doPrivilegedAction(String username, String password) "
"throws SQLException {\n"
"\n"
"            DriverManager.registerDriver(new com.microsoft.jdbc.sqlserver."
"SQLServerDriver());\n"
"            Connection connection = DriverManager.getConnection(\n"
"                \"jdbc:microsoft:sqlserver://<HOST>:1433\", \"<UID>\", "
"\"<PWD>\");\n"
"\n"
"            if (connection != null) {\n"
"                String sql = \"select * from db_user where username = '\" + "
"username +\n"
"                    \"' and password = '\" + password + \"'\";\n"
"\n"
"                Statement stmt = connection.createStatement();\n"
"                ResultSet rs = stmt.executeQuery(sql);\n"
"                if (!rs.next()) {\n"
"                    throw new SecurityException(\"User name or Password "
"incorrect\");\n"
"                }\n"
"                // Authenticated; proceed\n"
"            }\n"
"        }\n"
"        ...\n"
"\n"
"攻撃者が有効なユーザー名 securecoding を入力し、パスワード引数に 'OR "
"username =' \n"
"securecodingと入力すると、SQL文は、username '' OR \n"
"username = 'securecoding'およびpassword = ''のdb\n"
" \\ _ userから\\ *を選択し、結果的にログインパスワードチェックをバイパスしま"
"す。\n"
"同様に、ユーザー 'OR' 1 '=' 1の入力は、\n"
"ユーザー名とパスワードの両方のチェックをバイパスし、攻撃者に無制限アクセスを"
"許可します。\n"

#: vulnerabilities.py:1070
msgid "Storing Information in Shared Preferences"
msgstr "Shared Preferencesへの情報の保存"

#: vulnerabilities.py:1071
msgid "Is any sensitive information is leaking through Shared Preferences?"
msgstr "機密情報がSharedPreferenceを通じて漏洩していませんか？"

#: vulnerabilities.py:1072
msgid "No leakage of data were found via Shared Preference."
msgstr "SharedPreferenceを介したデータの漏洩は検出されませんでした。"

#: vulnerabilities.py:1073
msgid ""
"\n"
"In Android apps, data can be communicated via intents, or data can be\n"
"written to files, distributed using shared references, or stored in\n"
"databases. In all these cases, if the data is sensitive, it is important\n"
"to keep the data secure. That is, it should not be possible for other\n"
"apps (or, more strictly, apps with different userids) to be able to\n"
"access this data, or for the data to be accessible to other programs or\n"
"people, if the data owner does not intend that.\n"
"\n"
"Data security (for non-intent communication channels) can be supported\n"
"by creating the file, shared preference or database with MODE\\_PRIVATE\n"
"on internal storage or with MODE\\_PRIVATE and encrypted (using secure\n"
"encryption techniques, and using an encryption key only secure\n"
"parties/apps have) on external storage. MODE\\_PRIVATE is a constant\n"
"defined by the class android.content.Context. It may be used as the mode\n"
"parameter in the methods openFileOutput(), getSharedPreferences(),\n"
"andopenOrCreateDatabase() (which are all also defined in the class\n"
"android.content.Context).\n"
"\n"
"Static taint flow analysis can be done for a set of apps, to trace data\n"
"from each source (an input of data which cannot be fully predicted by\n"
"static analysis, e.g., text input by a user) to reachable sinks (data\n"
"output to a location that other applications or methods can access,\n"
"e.g., sending the data over a Bluetooth connection). Taint flow analysis\n"
"helps users understand many possible source to sink flows, including\n"
"flows that include intents and/or static fields.\n"
msgstr ""
"\n"
"Androidアプリでは、データはインテントを経由して通信することができたり、データ"
"をファイルに書き込むことができたり、SharedPreferenceを使用して配信したり、"
"データベースに保存したりすることができます。これらのすべてのケースで、データ"
"が機密性が高い場合、データを安全に保つことが重要です。つまり、データ所有者が"
"意図していない場合は、他のアプリケーション(もしくは、より厳密には、異なるユー"
"ザーIDを持つアプリケーション)がこのデータにアクセスできたり、他のプログラムや"
"ユーザがデータにアクセスできるようにすべきではありません。\n"
"データセキュリティ(非インテント通信チャネル用)は、ファイルや"
"SharedPreference、内部ストレージ上のMODE_PRIVATEのデータベース、外部ストレー"
"ジ上のMODE_PRIVATEで暗号化(安全な暗号化手法を使用し、セキュアパーティー/アプ"
"リのみが持つ暗号化キーを使用)されたデータベースを作成することで、サポートする"
"ことができます。MODE_PRIVATEは、android.content.Contextクラスによって定義され"
"る定数です。それはopenFileOutput(), getSharedPreferences(), "
"andopenOrCreateDatabase()のメソッドのモードパラメータとして使用される可能性が"
"あります。(これらはすべてandroid.content.Contextクラスでも定義されていま"
"す。) \n"
"静的テイントフロー解析は、一連のアプリケーションに対して、各ソース(静的解析に"
"よって完全には予測できないデータの入力、例えばユーザによるテキスト入力)から到"
"達可能なシンク(他のアプリケーションやメソッドがアクセスできる場所へのデータ出"
"力、例えばBluetooth接続を介したデータ送信)までのデータをトレースするために行"
"うことができます。テイントフロー分析は、インテントや静的フィールドを含んだフ"
"ローを含め、多くの可能性のあるシンクソースフローをユーザが理解するのに役立ち"
"ます。\n"

#: vulnerabilities.py:1100
msgid ""
"\n"
"Insecured informations were found in shared preference. One shouldn't\n"
"use un-encrypted information in SharedPreference.\n"
msgstr ""
"\n"
"SharedPreference内に安全でない情報が見つかりました。SharedPreferenceでは暗号"
"化されていない情報を使用するべきではありません。\n"

#: vulnerabilities.py:1104
msgid ""
"\n"
"Typically, malicious code steals sensitive information (passwords,\n"
"session cookies, personally identifiable information, etc). Hence, the\n"
"associated business impacts include:\n"
"\n"
"- Fraud\n"
"- Privacy Violations\n"
"\n"
msgstr ""
"\n"
"通常、悪意のあるコードは機密情報(パスワード、セッションCookie、個人を特定でき"
"る情報など)を盗みます。したがって、関連するビジネスへの影響は次を含みま"
"す。: \n"
"\n"
"- 詐欺\n"
"- プライバシー侵害\n"
"\n"

#: vulnerabilities.py:1113
msgid ""
"\n"
"In this compliant solution the file is created using MODE\\_PRIVATE, so\n"
"it can be accessed only by the app that created the file.\n"
"\n"
"    openFileOutput(\"someFile\", MODE_PRIVATE);\n"
"\n"
msgstr ""
"\n"
" この準拠ソリューションでは、ファイルはMODE_PRIVATEを使用して作成されるため、"
"ファイルを作成したアプリによってのみアクセスできます。\n"
"\n"
"   openFileOutput(\"someFile\", MODE_PRIVATE);\n"
"\n"

#: vulnerabilities.py:1120
msgid ""
"\n"
"This non-compliant code example shows an application that creates a file\n"
"that is world readable, and hence not secure.\n"
"\n"
"    openFileOutput(\"someFile\", MODE_WORLD_READABLE);\n"
"\n"
"Any application could read the file and access any data stored in it.\n"
msgstr ""
"\n"
"この規格に準拠していないコード例は、世界中から読み取り可能な、安全でないファ"
"イルを作成するアプリケーションを示しています。\n"
"\n"
"     openFileOutput（ \"someFile\"、MODE_WORLD_READABLE）;\n"
"\n"
"どのアプリケーションでもファイルを読み込むことができ、そこに格納されている"
"データにアクセスできます。\n"

#: vulnerabilities.py:1137 vulnerabilities.py:3547
msgid "Insufficient Transport Layer Protection"
msgstr "トランスポート層の不十分な保護"

#: vulnerabilities.py:1138
msgid ""
"Is your application using proper Transport Layer protection? Is HTTPS "
"enabled in your application?"
msgstr ""
"アプリケーションは適切なトランスポート層の保護を使用していますか？アプリケー"
"ションでHTTPSは有効になっていますか？"

#: vulnerabilities.py:1139
msgid ""
"Application seems to have SSL enabled and sufficient protection is being "
"used to prevent Information leakage."
msgstr ""
"アプリケーションでSSLが有効になっており、情報漏洩を防止するために十分な保護が"
"使用されているようです。"

#: vulnerabilities.py:1140 vulnerabilities.py:3550
msgid ""
"\n"
"Insufficient transport layer protection issues happen when the data is\n"
"sent from the mobile app to the server over unsecured channels. Whether\n"
"the data is transmitted through the carrier network or through WiFi, it\n"
"will end up through the Internet either way before it could reach the\n"
"remote server. There are several ways where unprotected data transmitted\n"
"over the network could be sniffed; things like routers, proxies, cell\n"
"towers, are some of the few ways data could be sniffed while in transit.\n"
msgstr ""
"\n"
"トランスポート層の不充分な保護に関する問題は、モバイルアプリケーションから"
"サーバに安全ではないチャネルを介してデータが送信されたときに発生します。デー"
"タが送信されるのが通信キャリアのネットワーク、あるいはWiFiを介した場合のいず"
"れにしても、リモートサーバに到達するまでにインターネットを経由することになり"
"ます。ネットワークを介して送信される保護されていないデータを盗聴する方法はい"
"くつかあり、ルータ、プロキシ、携帯電話の基地局などは、データの送信中に盗聴さ"
"れる可能性があります。\n"

#: vulnerabilities.py:1149 vulnerabilities.py:3559
msgid ""
"\n"
"Insufficient transport layer protection issues happen when the data is\n"
"sent from the mobile app to the server over unsecure channels. Whether\n"
"the data is transmitted through the carrier network or through WiFi, it\n"
"will end up through the Internet either way before it could reach the\n"
"remote server. There are several ways where unprotected data transmitted\n"
"over the network could be sniffed; things like routers, proxies, cell\n"
"towers, are some of the few ways data could be sniffed while in transit.\n"
msgstr ""
"\n"
"トランスポート層の不充分な保護に関する問題は、モバイルアプリケーションから"
"サーバに安全ではないチャネルを介してデータが送信されたときに発生します。デー"
"タが送信されるのが通信キャリアのネットワーク、あるいはWiFiを介した場合のいず"
"れにしても、リモートサーバに到達するまでにインターネットを経由することになり"
"ます。ネットワークを介して送信される保護されていないデータを盗聴する方法はい"
"くつかあり、ルータ、プロキシ、携帯電話の基地局などは、データの送信中に盗聴さ"
"れる可能性があります。\n"

#: vulnerabilities.py:1158 vulnerabilities.py:3568
msgid ""
"\n"
"The violation of a user's confidentiality may result in:\n"
"\n"
"- Identity theft\n"
"- Fraud\n"
"- Reputational Damage\n"
"\n"
msgstr ""
"\n"
"ユーザの機密性を侵害すると、次のような結果になることがあります。: \n"
"\n"
"- 個人情報の盗難\n"
"- 詐欺\n"
"- 風評被害\n"
"\n"

#: vulnerabilities.py:1166
msgid ""
"\n"
"Applications should make sure that they do not send sensitive\n"
"information to log output. If the app includes a third party library,\n"
"the developer should make sure that the library does not send sensitive\n"
"information to log output. One common solution is for an application to\n"
"declare and use a custom log class, so that log output is automatically\n"
"turned on/off based on Debug/Release. Developers can use ProGuard to\n"
"delete specific method calls. This assumes that the method contains no\n"
"side effects.\n"
"\n"
"Never use HTTP URL to download data. Instead, create a valid HTTPS\n"
"request through which only sensitive data can be downloaded.\n"
msgstr ""
"\n"
"アプリケーションは、重要な情報をログ出力に送信しないようにする必要がありま"
"す。\n"
"アプリにサードパーティのライブラリが含まれている場合、開発者はライブラリが重"
"要な情報をログとして出力しないようにする必要があります。\n"
"1つの一般的な解決策は、アプリケーションがカスタムログクラスを宣言して使用する"
"ことです。そのため、ログ出力はDebug / Releaseに基づいて自動的にオン/オフされ"
"ます。\n"
"開発者は ProGuard を使用して特定のメソッド呼び出しを削除できます。 これは、メ"
"ソッドが副作用を含まないことを前提としています。\n"
"\n"
"絶対にHTTP URLを使用してデータをダウンロードしないでください。代わりに、機密"
"データのみをダウンロードできる有効なHTTPSリクエストを作成してください。\n"
"\n"

#: vulnerabilities.py:1179
msgid ""
"\n"
"Using HTTP with SSL or TLS to connect to internet, or without a proper\n"
"certificate the connection can be easily eavesdropped by attacker\n"
"without the knowledge of the user.\n"
"\n"
"    String link = \"http://www.google.com\";\n"
"    URL url = new URL(link);\n"
"\n"
"    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n"
"    conn.connect();\n"
"\n"
"    InputStream is = conn.getInputStream();\n"
"    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "
"\"UTF-8\"));\n"
"    String webPage = \"\", data=\"\";\n"
"    while ((data = reader.readLine()) != null) {\n"
"       webPage += data;\n"
"    }\n"
"\n"
"An attacker can perform a MITM attack and the user wouldn't even know\n"
"that someone is eavesdropping the connection.\n"
msgstr ""
"\n"
"SSLまたはTLSでHTTPを使用してインターネットに接続するか、適切な証明書を使用し"
"ないと、ユーザーに気づかれずに攻撃者が簡単に接続を盗聴できます。\n"
"\n"
"    String link = \"http://www.google.com\";\n"
"    URL url = new URL(link);\n"
"\n"
"    HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n"
"    conn.connect();\n"
"\n"
"    InputStream is = conn.getInputStream();\n"
"    BufferedReader reader = new BufferedReader(new InputStreamReader(is, "
"\"UTF-8\"));\n"
"    String webPage = \"\", data=\"\";\n"
"    while ((data = reader.readLine()) != null) {\n"
"       webPage += data;\n"
"    }\n"
"\n"
"ユーザーに誰かが接続を盗聴していることさえ気づかせずに、攻撃者はMITM攻撃を行"
"うことができます。\n"

#: vulnerabilities.py:1209
msgid "Derived Crypto Keys"
msgstr "派生した暗号鍵"

#: vulnerabilities.py:1210
msgid "Does the application use insecure encryption methods?"
msgstr "アプリケーションが安全でない暗号化方式を使用していますか？"

#: vulnerabilities.py:1211
msgid ""
"Application seems to be using the correct cryptographic encryption method, "
"if any."
msgstr ""
"もし使用しているのであれば、アプリケーションは正しい暗号化メソッドを使用して"
"いるようです。"

#: vulnerabilities.py:1212
msgid ""
"\n"
"The predominant Android cryptographic security provider API defaults to\n"
"using an insecure AES encryption method: ECB block cipher mode for AES\n"
"encryption. Android's default cryptographic security provider (since\n"
"version 2.1) is BouncyCastle.\n"
"\n"
"Note that Java also selects ECB as a default value when only the AES\n"
"encryption method is chosen. So, this rule also applies to Java, but for\n"
"Java's different default cryptographic security provider. Oracle Java's\n"
"default cryptographic security provider is SunJCE.\n"
"\n"
"Default behaviors of cryptographic libraries used in Android systems\n"
"often do not use recommended practices. For example, the predominant\n"
"Android Java security provider API defaults to using an insecure AES\n"
"encryption method: ECB block cipher mode for AES encryption. Extensive\n"
"app testing by Egele 2013 has shown that the following 6 rules are\n"
"often not followed, resulting in 88 percent of apps with cryptographic APIs "
"on\n"
"Google Play making at least one mistake.\n"
"\n"
"Six common cryptography rules that were tested:\n"
"\n"
"1.  Do not use ECB mode for encryption.\n"
"2.  Do not use a non-random IV for CBC encryption.\n"
"3.  Do not use constant encryption keys.\n"
"4.  Do not use constant salts for PBE.\n"
"5.  Do not use fewer than 1,000 iterations for PBE.\n"
"6.  Do not use static seeds to seed SecureRandom().\n"
"\n"
msgstr ""
"\n"
"主な Android 暗号化セキュリティプロバイダ API は、デフォルトで、安全でない"
"AES 暗号化メソッド、つまり AES 暗号化用の ECB ブロック暗号モードを使用しま"
"す。 Android のデフォルトの暗号化セキュリティプロバイダ（バージョン2.1以降）"
"は BouncyCastleです。\n"
"\n"
"Javaでは、AES 暗号化方式のみが選択されている場合でも ECB がデフォルト値として"
"選択されます。したがって、このルールは Java にも適用されますが、Javaの異なる"
"デフォルトの暗号化セキュリティー·プロバイダーにも適用されます。 Oracle Java "
"のデフォルトの暗号化セキュリティプロバイダは SunJCE です。\n"
"\n"
"Android システムで使用される暗号ライブラリのデフォルトの動作は、しばしば推奨"
"される方法を使用しません。たとえば、主な Android Java セキュリティプロバイダ "
"API では、デフォルトで、安全でない AES 暗号化方式、AES 暗号化用のECBブロック"
"暗号モードが使用されます。 Egele 2013 の広範なアプリテストでは、次の6つのルー"
"ルに従わないことが多く、Google Play の暗号 API を使用しているアプリのうち88％"
"が少なくとも1つはミスをしています。\n"
"テストされた6つの一般的な暗号化ルール：\n"
"\n"
"1. 暗号化に ECB モードを使用しないでください。\n"
"2. CBC 暗号化に非ランダムIVを使用しないでください。\n"
"3. 一定の暗号鍵を使用しないでください。\n"
"4. PBEには一定の塩を使用しないでください。\n"
"5. PBEには1,000回未満の反復を使用しないでください。\n"
"6. 静的なシードを使用してSecureRandom（）をシードしないでください。\n"
"\n"

#: vulnerabilities.py:1241
msgid ""
"\n"
"Traces of Crypto Keys which might be intermediate keys used when loading\n"
"the different libraries.\n"
msgstr ""
"\n"
"異なるライブラリをロードする際に使用される中間鍵である可能性のある暗号鍵の形"
"跡。\n"

#: vulnerabilities.py:1245
msgid ""
"\n"
"Broken cryptography will result in the following:\n"
"\n"
"- Privacy Violations\n"
"- Information Theft\n"
"- Code Theft\n"
"- Intellectual Property Theft\n"
"- Reputational Damage\n"
"\n"
msgstr ""
"\n"
"暗号を破られると次のようになります。\n"
"\n"
"- プライバシー違反\n"
"- 情報盗難\n"
"- コード盗難\n"
"- 知的財産の盗難\n"
"- 評判の損失\n"
"\n"

#: vulnerabilities.py:1255
msgid ""
"\n"
"The following are the rules which should be followed while using\n"
"encryption:\n"
"\n"
"- If AES encryption is used, always pair it with CBC (Cipher Block "
"Chaining)\n"
"- Never use just AES as encryption because it defaults to AES/ECB "
"(Electronic Codebook)\n"
"- Always use padding with the encryption, for example, AES/CBC/PKCS7 is "
"stronger than just AES/CBC\n"
"- Never use older algorithim like DES (Data Encryption Standard)\n"
"- Assume that the network layer is not secure and may potentially be hostile "
"and eavesdropping.\n"
"- Enforce the use of SSL/TLS for all transport channels in which\n"
"  sensitive information, session tokens, or other sensitive data is\n"
"  going to be communicated to a backend API or web service.\n"
"- Remember to account for outside entities like third-party analytics,\n"
"  social networks, etc. and use their SSL versions even when an\n"
"  application runs a routine via the browser/webkit. Mixed SSL\n"
"  sessions should be avoided and may expose the user's session ID.\n"
"- Use strong, industry standard encryption algorithms and appropriate\n"
"  key lengths.\n"
"- Use certificates signed by a trusted CA provider.\n"
"- Never allow self-signed certificates, and consider certificate\n"
"  pinning for security conscious applications.\n"
"- Do not disable or ignore SSL chain verification.\n"
"- Only establish a secure connection after verifying the identity of\n"
"  the endpoint server with trusted certificates in the key chain.\n"
"- Alert users through the UI if an invalid certificate is detected.\n"
"- Do not send sensitive data over alternate channels, such as SMS,\n"
"  MMS, or notifications.\n"
msgstr ""
"\n"
"暗号化を使用する際に従うべきルールは次のとおりです。 \n"
"\n"
"- AES暗号化を使用する場合は、必ずECB(Electronic Codebook)とペアリングしてくだ"
"さい。\n"
"- AES/CBCにデフォルト設定されているため、単に\"AES\"を暗号化として使用しない"
"でください。\n"
"- 必ず暗号化に加えてパディングを使用してください。\"RSA/ECB\"は\"RSA/ECB/"
"PKCS7\"は\"RSA/ECB\"より安全です。\n"
"- DES(Data Encryption Standard)のような古いアルゴリズムを使用しないでくださ"
"い。    \n"
"- ネットワーク層が安全ではなく、敵対的で盗聴される可能性があるとした想定して"
"ください。 \n"
"- 機密情報、セッショントークン、またはその他の機密データがバックエンドAPIまた"
"はWebサービスに伝達されるすべてのトランスポートチャネルにSSL / TLSの使用を強"
"制します。\n"
"- アプリケーションがブラウザ/ Webkitを介してルーチンを実行する場合でも、サー"
"ドパーティの分析、ソーシャルネットワークなどの外部のエンティティを考慮し、SSL"
"バージョンを使用することを忘れないでください。混合SSLセッションは避け、ユー"
"ザーのセッションIDを公開する必要があります。\n"
"- 強力な業界標準の暗号化アルゴリズムと適切な鍵長を使用します。\n"
"- 信頼できるCAプロバイダが署名した証明書を使用する。\n"
"- 署名証明書を許可せず、セキュリティに配慮したアプリケーションのための証明書"
"のピン割り当てを検討してください。 \n"
"- SSLチェーン検証を無効または無視しないでください。\n"
"- キーチェーン内の信頼できる証明書を使用してエンドポイントサーバーのIDを確認"
"した後でのみ、安全な接続を確立します。 \n"
"- 無効な証明書が検出された場合、UIを介してユーザーに警告します。\n"
"- SMS、MMS、通知などの代替チャネルで機密データを送信しないでください。\n"
"\n"

#: vulnerabilities.py:1293
msgid "Application Logs"
msgstr "アプリケーションログ"

#: vulnerabilities.py:1294
msgid "Is this application leaking data through logs?"
msgstr "このアプリケーションはログを介してデータを漏洩していますか？"

#: vulnerabilities.py:1295
msgid "No application logs were found."
msgstr "アプリケーションログは見つかりませんでした。"

#: vulnerabilities.py:1296
msgid ""
"\n"
"Android provides capabilities for an app to output logging information\n"
"and obtain log output. Applications can send information to log output\n"
"using the android.util.Log class. To obtain log output, applications can\n"
"execute the logcat command.\n"
msgstr ""
"\n"
"Android はアプリケーションがロギング情報の出力と、ログを出力する機能を提供し"
"ます。 アプリケーションは、android.util.Log クラスを使用してログ出力に情報を"
"送信できます。 ログ出力を取得するには、アプリケーションで logcat コマンドを実"
"行します。\n"

#: vulnerabilities.py:1302
msgid ""
"\n"
"Application was found to be writing logs to the system logs\n"
msgstr ""
"\n"
"アプリケーションがシステムログにログを書き込んでいました。\n"

#: vulnerabilities.py:1305 vulnerabilities.py:1467
msgid ""
"\n"
"Sensitive data can inadvertently leak into the logs and may aid in\n"
"further attacks\n"
msgstr ""
"\n"
"機密データが意図せずにログにリークされ、更なる攻撃を助長する可能性がありま"
"す。\n"
"\n"

#: vulnerabilities.py:1309
msgid ""
"\n"
"Never use logs in production. Find all `Log.d()` and remove them.\n"
"\n"
"Use exception parsers and crash-based-analytics tool capture crashes in\n"
"production so that it can be debugged\n"
msgstr ""
"\n"
"本番環境ではログを絶対に使用しないでください。すべての `Log.d（）`を削除して"
"ください。\n"
"\n"
"本番環境では、例外パーサを使用し、クラッシュベースの分析ツールでクラッシュを"
"キャプチャしてデバッグすることができます。\n"

#: vulnerabilities.py:1315
msgid ""
"\n"
"Facebook SDK for Android contained the following code which sends Facebook "
"access tokens to log output in plain text format.\n"
"\n"
"    Log.d(\"Facebook-authorize\", \"Login Success! access_token=\" + "
"getAccessToken() + \" expires=\" + getAccessExpires());\n"
"\n"
"Here is another example. A weather report for Android sent a user's location "
"data to the log output as follows:\n"
"\n"
"    I/MyWeatherReport( 6483): Re-use MyWeatherReport data\n"
"    I/ ( 6483): GET JSON:\n"
"    http://example.com/smart/repo_piece.cgi?"
"arc=0&lat=26.209026&lon=127.650803&rad=50&dir=-999&lim=52&category=1000\n"
"\n"
"If a user is using Android OS 4.0 or before, other applications with READ"
"\\_LOGS\n"
"permission can obtain the user's location information without declaring\n"
"ACCESS\\_FINE\\_LOCATION permission in the manifest file.\n"
msgstr ""
"\n"
"Facebook SDK for Android contained the following code which sends Facebook "
"access tokens to log output in plain text format.\n"
"\n"
"    Log.d(\"Facebook-authorize\", \"Login Success! access_token=\" + "
"getAccessToken() + \" expires=\" + getAccessExpires());\n"
"\n"
"Here is another example. A weather report for Android sent a user's location "
"data to the log output as follows:\n"
"\n"
"    I/MyWeatherReport( 6483): Re-use MyWeatherReport data\n"
"    I/ ( 6483): GET JSON:\n"
"    http://example.com/smart/repo_piece.cgi?"
"arc=0&lat=26.209026&lon=127.650803&rad=50&dir=-999&lim=52&category=1000\n"
"\n"
"ユーザーが Android OS 4.0 以前を使用している場合、READ\\_LOGS 権限を持つ他の"
"アプリケーションは、マニフェストファイルで ACCESS\\_FINE \\_ LOCATION 権限を"
"宣言せずにユーザーの場所情報を取得できます。\n"
"\n"

#: vulnerabilities.py:1330
msgid ""
"\n"
"- [Facebook SDK for Android](http://readwrite.com/2012/04/10/what-developers-"
"and-users-can#awesm=~o9iqZAMlUPshPu)\n"
"- [JVN\\#23328321](https://jvn.jp/en/jp/JVN23328321/) Puella Magi\n"
"  Madoka Magica iP for Android vulnerable to information disclosure\n"
"- [JVN\\#86040029](https://jvn.jp/en/jp/JVN86040029/) Weathernews Touch\n"
"  for Android stores location information in the system log file\n"
"- [JVN\\#33159152](https://jvn.jp/en/jp/JVN33159152/) Loctouch for\n"
"  Android information management vulnerability\n"
"- [JVN\\#56923652](https://jvn.jp/en/jp/JVN56923652/) Monaca Debugger\n"
"  for Android information management vulnerability\n"
"\n"
msgstr ""
"\n"
"- [Facebook SDK for Android](http://readwrite.com/2012/04/10/what-developers-"
"and-users-can#awesm=~o9iqZAMlUPshPu)\n"
"- [JVN\\#23328321](https://jvn.jp/en/jp/JVN23328321/) Puella Magi\n"
"  Madoka Magica iP for Android 情報漏えいに関する脆弱性\n"
"- [JVN\\#86040029](https://jvn.jp/en/jp/JVN86040029/) Weathernews Touch\n"
"  for Android システムログファイルに位置情報を保存\n"
"- [JVN\\#33159152](https://jvn.jp/en/jp/JVN33159152/) Loctouch for\n"
"  Android 情報管理に関する脆弱性\n"
"- [JVN\\#56923652](https://jvn.jp/en/jp/JVN56923652/) Monaca Debugger\n"
"  for Android 情報管理に関する脆弱性\n"
"\n"

#: vulnerabilities.py:1350 vulnerabilities.py:1419
msgid "Business Logic"
msgstr "ビジネスロジック"

#: vulnerabilities.py:1351 vulnerabilities.py:1420
msgid "Were flaws found in the business logic?"
msgstr "ビジネスロジックに欠陥が見つかりましたか？"

#: vulnerabilities.py:1352 vulnerabilities.py:1421
msgid "No flaws were found in the business logic."
msgstr "ビジネスロジックに欠陥が見つかりませんでした。"

#: vulnerabilities.py:1353
msgid ""
"\n"
"Most security problems are weaknesses in an application that result from\n"
"a broken or missing security control (authentication, access control,\n"
"input validation, etc...). By contrast, business logic vulnerabilities\n"
"are ways of using the legitimate processing flow of an application in a\n"
"way that results in a negative consequence to the organization.\n"
"\n"
"Too often, the business logic category is used for vulnerabilities that\n"
"can't be scanned for automatically. This makes it very difficult to\n"
"apply any kind of categorization scheme. Business logic problems are\n"
"different from authentication problems and every other category. There\n"
"are many significant business logic vulnerabilities, but they are far\n"
"less common than the type of items.\n"
msgstr ""
"\n"
"ほとんどのセキュリティの問題はセキュリティ管理（認証、アクセス制御、入力検証"
"など）の破損あるいは欠如から生じるアプリケーション内の脆弱性です。\n"
"一方、ビジネスロジック脆弱性は、組織にとってマイナスな結果をもたらすようにア"
"プリの正規のプロセスフローを利用する方法です。\n"
"しばしば、ビジネスロジックのカテゴリーは自動的にスキャン出来ない脆弱性に使用"
"されます。この事はカテゴリー化スキームの適用を非常に難しくしています。\n"
"ビジネスロジックの問題は認証問題や他のすべてのカテゴリーと異なります。多くの"
"重大なビジネスロジック脆弱性がありますが、それらはアイテムのタイプよりはるか"
"に一般的ではありません。\n"

#: vulnerabilities.py:1367
msgid ""
"\n"
"Logical Flaws through API which can bypass authorization and get\n"
"information about other users. Authorization and\n"
"authenticated sessions were not properly validated on both client or\n"
"server side\n"
msgstr ""
"\n"
"認証をバイパスして他のユーザ情報とリセットパスワードを取得することができるAPI"
"による論理的欠陥です。認証および認証セッションは、クライアント側またはサー"
"バー側の両方で正しく検証されませんでした。\n"

#: vulnerabilities.py:1374
msgid ""
"\n"
"The following should be checked and properly fixed\n"
"\n"
"- Check for OTP in server side rather than in Client Side\n"
"- Use proper Authentication not same authorization token like\n"
"  Authorization: Basic aW50ZXJhY3Rpb25vbmU6bW9iaTEyMw== which\n"
"  translates to: interactionone:mobi123\n"
"- never use passwords like mobi123\n"
"\n"
msgstr ""
"\n"
"<p> 次のようなものはチェックと適切な修正をしてください。 </p> <ul> <li>クライ"
"アントサイドではなくサーバーサイドのOTPへのチェック</li> <li>次のような同じ承"
"認トークンではなく、適切な認証を使用してください。<b>Authorization: Basic "
"aW50ZXJhY3Rpb25vbmU6bW9iaTEyMw==</b> which translates to: <b>interactionone:"
"mobi123</b></li> <li>mobi123 のようなパスワードを絶対に使用しないでください。"
"</li> </ul>\n"

#: vulnerabilities.py:1385
msgid ""
"\n"
"Automated tools find it hard to understand context, hence it's up to a\n"
"person to perform these kinds of tests. The following two examples will\n"
"illustrate how understanding the functionality of the application, the\n"
"developer's intentions, and some creative \"out-of-the-box\" thinking can\n"
"break the application's logic. The first example starts with a\n"
"simplistic parameter manipulation, whereas the second is a real world\n"
"example of a multi-step process leading to completely subvert the\n"
"application.\n"
"\n"
"Example 1: Suppose an e-commerce site allows users to select items to "
"purchase,\n"
"view a summary page and then tender the sale. What if an attacker was\n"
"able to go back to the summary page, maintaining their same valid\n"
"session and inject a lower cost for an item and complete the\n"
"transaction, and then check out?\n"
"\n"
"Example 2: Holding/locking resources and keeping others from purchases these "
"items\n"
"online may result in attackers purchasing items at a lower price. The\n"
"countermeasure to this problem is to implement timeouts and mechanisms\n"
"to ensure that only the correct price can be charged.\n"
"\n"
"Example 3: What if a user was able to start a transaction linked to their\n"
"club/loyalty account and then after points have been added to their\n"
"account cancel out of the transaction? Will the points/credits still be\n"
"applied to their account?\n"
msgstr ""
"\n"
"自動化されたツールはコンテキストを理解することが難しいので、この種のテスト"
"を\n"
"実行するのは人間に任されています。 \n"
"次の2つの例は、アプリケーションの機能、開発者の意図、および独創的な「すぐに"
"使\n"
"える」思考がアプリケーションのロジックを破壊する可能性があることを示してい"
"ま\n"
"す。最初の例は、単純なパラメータ操作で始まりますが、2番目の例は、アプリケー\n"
"ションを完全に覆す多段階プロセスが実在する例です。 \n"
"例1：eコマースサイトで、ユーザーが購入するアイテムを選択できるとします。\n"
"サマリページを表示してから、同じ有効なセッションを維持したまま攻撃者がサマ"
"リ\n"
"ページに戻り、商品を本来の価格より安く設定してトランザクションを完了し、会"
"計\n"
"を済ませることができた場合はどうなりますか？ \n"
"\n"
"例2：リソースを保持/ロックし、他の人にこれらのアイテムをオンラインで購入さ"
"せ\n"
"ないようにすることで、攻撃者はより安い価格で商品を購入する可能性がありま"
"す。\n"
"この問題の対策は、タイムアウトと本来の正しい価格だけを請求できるようなメカ"
"ニ\n"
"ズムを実装することです。 \n"
"\n"
"例3：ユーザーが自分のクラブまたはロイヤルティアカウントを通じて取引をした"
"後、\n"
"アカウントにポイントが付与されます。その後、取引自体をキャンセルした場合は"
"ど\n"
"うなりますか？ポイントまたはクレジットは引き続きアカウントに適用されます\n"
"か？\n"

#: vulnerabilities.py:1422
msgid ""
"\n"
"Most security problems are weaknesses in an application that result from\n"
"a broken or missing security control (authentication, access control,\n"
"input validation, etc.). By contrast, business logic vulnerabilities are\n"
"ways of using the legitimate processing flow of an application in a way\n"
"that results in a negative consequence to the organization.\n"
"\n"
"Too often, the business logic category is used for vulnerabilities that\n"
"can't be scanned for automatically. This makes it very difficult to\n"
"apply any kind of categorization scheme. Business logic problems are\n"
"different from authentication problems and every other category. There\n"
"are many signficant business logic vulnerabilities, but they are far\n"
"less common than the type of items.\n"
msgstr ""
"\n"
"ほとんどのセキュリティの問題はセキュリティ管理（認証、アクセス制御、入力検証"
"など）の破損あるいは欠如から生じるアプリケーション内の脆弱性です。\n"
"一方、ビジネスロジック脆弱性は、組織にとってマイナスな結果をもたらすようにア"
"プリの正規のプロセスフローを利用する方法です。\n"
"しばしば、ビジネスロジックのカテゴリーは自動的にスキャン出来ない脆弱性に使用"
"されます。この事はカテゴリー化スキームの適用を非常に難しくしています。\n"
"ビジネスロジックの問題は認証問題や他のすべてのカテゴリーと異なります。多くの"
"重大なビジネスロジック脆弱性がありますが、それらはアイテムのタイプよりはるか"
"に一般的ではありません。\n"

#: vulnerabilities.py:1436
msgid ""
"\n"
"Logical Flaws through API which can bypass Authorization and get\n"
"information about other users. Authorization and\n"
"authenticated sessions were not properly validated on both client or\n"
"server side\n"
msgstr ""
"\n"
"認証をバイパスして他のユーザ情報とリセットパスワードを取得することができるAPI"
"による論理的欠陥です。認証および認証セッションは、クライアント側またはサー"
"バー側の両方で正しく検証されませんでした。\n"

#: vulnerabilities.py:1454
msgid "Debug Logging with NSLog"
msgstr "NSLogによるデバッグロギング"

#: vulnerabilities.py:1455
msgid "Is the application logging to the system logs?"
msgstr "このアプリケーションはシステムログにログの出力をしていませんか？"

#: vulnerabilities.py:1456
msgid "Application does not log to system logs."
msgstr "アプリケーションはシステムログに記録されません。"

#: vulnerabilities.py:1457
msgid ""
"\n"
"Applications tend to add some data in logs for debugging purpose. If\n"
"sensitive data is shown in the application logs then it may lead to\n"
"leakage of data.\n"
msgstr ""
"\n"
"アプリケーションはデバッグの目的でログにいくつかのデータを追加する傾向があり"
"ます。もし重要なデータがアプリケーションログに見られたら、それはデータ漏洩に"
"つながる可能性があります。\n"

#: vulnerabilities.py:1462
msgid ""
"\n"
"Debug Logs are usually left enabled during application development.\n"
"These application logs are easily accessible via XCode or by root access\n"
"to the device.\n"
msgstr ""
"\n"
"デバッグログは通常、アプリケーション開発中は有効化されたままになっていま"
"す。\n"
"これらのアプリケーションログは、Xcode あるいはデバイスへのルートアクセスに\n"
"よって容易にアクセスすることが可能です。\n"

#: vulnerabilities.py:1471
msgid ""
"\n"
"Wipe off the application log at particular intervals or when the user\n"
"signs out of the application. Do not log any sensitive information.\n"
msgstr ""
"\n"
"一定の間隔、あるいはユーザがアプリケーションからサインアウトした時にアプリ"
"ケーションログを削除してください。機密情報はログに記録しないようにしてくださ"
"い。\n"

#: vulnerabilities.py:1485
msgid "Sensitive Information in Property Lists"
msgstr "プロパティリストの機密情報"

#: vulnerabilities.py:1486
msgid ""
"Does the application store sensitive information in Property Lists (plist)?"
msgstr "アプリケーションは機密情報をプロパティリスト（plist）に保存しますか？"

#: vulnerabilities.py:1487
msgid "The application does not store sensitive information in Property Lists."
msgstr "アプリケーションは、機密情報をプロパティリストに保存しません。"

#: vulnerabilities.py:1488
msgid ""
"\n"
"Information Property List Files are the files that contain configuration\n"
"information about the application executable. These files are stored in\n"
"unencrypted form on the device & hence, can be read by anyone by\n"
"accessing the application sandbox via any third-party tools (up to iOS\n"
"v8.2), by gaining root access to the device (after v8.2) or by taking an\n"
"iOS backup.\n"
msgstr ""
"\n"
"情報プロパティリストファイルはアプリケーション実行可能ファイルに関する構成情"
"報を含むファイルです。これらのファイルはデバイス上に暗号化されていない形式で"
"保存されます。そのため、サードパーティのツール経由でのアプリケーションサンド"
"ボックスへのアクセス(iOS v8.2以前)、デバイスへのルートアクセスの取得(v8.2以"
"降)、あるいはiOSバックアップの取得によって誰にでも読まれる可能性がありま"
"す。\n"

#: vulnerabilities.py:1496
msgid ""
"\n"
"Plist files contain data in plaintext format\n"
msgstr ""
"\n"
"Plistファイルは平文フォーマットのデータを含んでいます。\n"

#: vulnerabilities.py:1499
msgid ""
"\n"
"An attacker can steal sensitive data if they have access to the device\n"
"or device backup\n"
msgstr ""
"\n"
"攻撃者がデバイスまたはデバイスのバックアップにアクセスできる場合、機密データ"
"を盗まれる可能性があります。\n"

#: vulnerabilities.py:1503
msgid ""
"\n"
"It's recommended not to store any sensitive data such as usernames,\n"
"authentication tokens, passwords, personal information in any of the\n"
"plist files of the application.\n"
msgstr ""
"\n"
"アプリケーションのPlistファイルにはユーザ名、認証トークン、パスワード、個人情"
"報などの機密情報を保存しないことが推奨されています。\n"

#: vulnerabilities.py:1518
msgid "Sensitive Data in NSUserDefaults"
msgstr "NSUserDefaultsの機密データ"

#: vulnerabilities.py:1519
msgid "Does this application store sensitive information in NSUserDefaults?"
msgstr "このアプリケーションはNSUserDefaultsに機密情報を保存していませんか？"

#: vulnerabilities.py:1520
msgid ""
"This application does not store sensitive information in NSUserDefaults."
msgstr "このアプリケーションはNSUserDefaultsに機密情報を保存していません。"

#: vulnerabilities.py:1521
msgid ""
"\n"
"NSUserDefaults are stored in plist in binary format, with no encryption,\n"
"and is stored in your app's directory. Any user can edit, see, share,\n"
"move and whatever they want to. Thus, if any sensitive information is\n"
"stored in NSUserDefaults then it may reach wrong hands & can be used for\n"
"personal use later on.\n"
msgstr ""
"\n"
"NSUserDefaultsは暗号化されずにバイナリフォーマットでplistに保存され、あなたの"
"アプリのディレクトリに保存されます。どんなユーザでも編集、閲覧、共有、移動な"
"どやりたいことを何でもできます。そのため、もし何らかの機密情報が"
"NSUserDefaultsに保存されるなら、それは誤った手に届き、個人利用される可能性が"
"あります。\n"

#: vulnerabilities.py:1528
msgid ""
"\n"
"NSUserDefaults is an alternative way by which data can be stored in\n"
"Plist files\n"
msgstr ""
"\n"
"NSUserDefaultsはデータをplistファイルに保存することができる代替方法です。\n"

#: vulnerabilities.py:1532
msgid ""
"\n"
"Sensitive information can get compromised since plist files store data\n"
"unencrypted.\n"
msgstr ""
"\n"
"plistファイルはデータを暗号化保存しないため、機密情報が侵害される可能性があり"
"ます。</p>\n"

#: vulnerabilities.py:1536
msgid ""
"\n"
"Avoid using NSUserDefaults to store sensitive pieces of information as\n"
"it stores data in plist files which contain information in unencrypted\n"
"form.\n"
msgstr ""
"\n"
"暗号化されていない形式の情報を含んだplistファイルにデータを保存する際は、"
"NSUserDefaultsを機密情報を保存するために使用しないでください。\n"

#: vulnerabilities.py:1551
msgid "Sensitive Information in SQLite3 Databases"
msgstr "SQLite3データベースの機密情報"

#: vulnerabilities.py:1552
msgid "Does this application store sensitive information in SQLite3 databases?"
msgstr ""
"このアプリケーションはSQLite3データベース内に機密情報を保存していませんか？"

#: vulnerabilities.py:1553
msgid ""
"This application does not store sensitive information in SQLite3 databases."
msgstr ""
"このアプリケーションはSQLite3データベース内に機密情報を保存していません。"

#: vulnerabilities.py:1554
msgid ""
"\n"
"SQLite databases are often used by the applications to store persistent\n"
"or temporary data which can be further used by the application at later\n"
"stages. For example, in order to provide seamless experience to the\n"
"user, an application may store user credentials in SQLite database so\n"
"that the user doesn't need to enter them again later on. However, these\n"
"databases don't have any built-in support for encryption and hence, all\n"
"the information is stored in plain-text format in these files.\n"
msgstr ""
"\n"
"SQLiteデータベースはアプリケーションで使用可能な永続的または一時的なデータを"
"保存するために使用されます。例えば、ユーザにシームレスな体験を与えるために、"
"アプリケーションはユーザが再度入力する必要がないように、ユーザ資格情報を"
"SQLiteデータベースに保存することができます。しかし、これらのデータベースはい"
"かなる暗号ためのビルトインサポートを持っていないので、すべての情報は平文形式"
"でこれらのファイルに保存されます。</p>\n"

#: vulnerabilities.py:1563
msgid ""
"\n"
"SQLite3 databases are stored in unencrypted form on the device. Storing\n"
"sensitive information in such databases may lead to leakage of data.\n"
msgstr ""
"\n"
"SQLite3データベースはデバイス上に暗号化されずに保存されます。そのようなデータ"
"ベースへに機密情報を保存することはデータ漏洩につながる可能性があります。\n"

#: vulnerabilities.py:1567 vulnerabilities.py:1606 vulnerabilities.py:1661
#: vulnerabilities.py:1714 vulnerabilities.py:1754 vulnerabilities.py:4803
msgid ""
"\n"
"Failure to use encryption routines may result in the database and its\n"
"associated data including user credentials getting compromised.\n"
msgstr ""
"\n"
"暗号化ルーチンの使用の失敗によって、データベースとユーザ資格情報を含む関連"
"データの侵害につながる可能性があります。\n"

#: vulnerabilities.py:1571
msgid ""
"\n"
"It is suggested to use custom encryption while storing data in SQLite\n"
"databases.\n"
"\n"
"SQLite engine writes the data into Write Ahead Log (WAL) before storing\n"
"it in the actual database file. Using WAL, there is a possibility to\n"
"recover the deleted data from the database file. Hence, before deleting\n"
"any SQLite record, always overwrite it with some junk data so that it\n"
"can't be read even if someone tries to recover it.\n"
msgstr ""
"\n"
"SQLiteデータベースにデータ保存する際、カスタム暗号化の使用が推奨されます。\n"
"SQLiteエンジンはデータを実際のデータベースファイルに保存する前にWrite "
"Ahead \n"
"Log (WAL)に書き込みます。WALの利用によって、データベースファイルから削除さ"
"れ\n"
"たデータを復元する可能性があります。それゆえ、誰かが復元しようとしても読め"
"な\n"
"いように、SQLiteのレコードを削除する前は常に何らかのジャンクデータで上書き"
"し\n"
"てください。\n"

#: vulnerabilities.py:1591
msgid "Unsecured Data in CoreData"
msgstr "CoreDataの安全でないデータ"

#: vulnerabilities.py:1592
msgid "Does this application store sensitive information in CoreData?"
msgstr "このアプリケーションはCoreDataに機密情報を保存していませんか？"

#: vulnerabilities.py:1593
msgid "This application does not store sensitive information in CoreData."
msgstr "このアプリケーションはCoreDataに機密情報を保存していません。"

#: vulnerabilities.py:1594
msgid ""
"\n"
"Core Data is used by the applications to store data which can be further\n"
"used by the application at later stages. However, these databases don't\n"
"have any built-in support for encryption and hence, all the information\n"
"is stored in plain-text format in these files. If an application stores\n"
"user credentials or some sensitive user specific data in this database\n"
"then it can be accessed by any third party.\n"
msgstr ""
"\n"
"CoreDataはアプリケーションで使用可能なデータを保存するために使用されます。し"
"かし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていな"
"いので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリ"
"ケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータ"
"ベースに保存するなら、第三者にアクセスされる可能性があります。\n"

#: vulnerabilities.py:1602
msgid ""
"\n"
"Core Data is often used by applications to store data to improve\n"
"application performance\n"
msgstr ""
"\n"
"CoreData はアプリケーションのパフォーマンス改善のために、アプリケーションに"
"よってデータ保存のため使用されます。\n"

#: vulnerabilities.py:1610
msgid ""
"\n"
"It is suggested to use custom encryption while storing data in Core\n"
"Data.\n"
"\n"
"EncryptedStore is known to work successfully on iOS versions 6.0 through\n"
"9.3.4 to store CoreData in encrypted format\n"
"\n"
"If you wish to set a custom cache size and/or custom database URL:\n"
"create an NSDictionary to set the options for your EncryptedStore,\n"
"replacing customPasscode, customCacheSize, and/or customDatabaseURL:\n"
"\n"
"    NSDictionary *options = @{ EncryptedStorePassphraseKey: (NSString *) "
"customPasscode,\n"
"                               EncryptedStoreCacheSize: (NSNumber *) "
"customCacheSize,\n"
"                               EncryptedStoreDatabaseLocation: (NSURL *) "
"customDatabaseURL\n"
"    };\n"
"\n"
"In your application delegate source file (i.e. AppDelegate.m) you should "
"see\n"
"\n"
"    NSPersistentStoreCoordinator *coordinator = [self "
"persistentStoreCoordinator];\n"
"\n"
"If you created an NSDictionary with custom options, replace that line with\n"
"\n"
"    NSPersistentStoreCoordinator *coordinator = [EncryptedStore "
"makeStoreWithOptions:options managedObjectModel:[self managedObjectModel]];\n"
"\n"
"The project is available [here](https://github.com/project-imas/encrypted-"
"core-data).\n"
msgstr ""
"\n"
"CoreDataにデータ保存する際、カスタム暗号化の使用が推奨されます。\n"
"EncryptedStoreはCoreDataを暗号化形式で保存するためにiOSバージョン6.0～9.3.4で"
"正常に動作することが知られています。\n"
"もしカスタムキャッシュサイズ、あるいはカスタムデータベースURLをセットしたいな"
"ら、カスタムパスコード、カスタムキャッシュサイズ、および/またはカスタムデータ"
"ベースURLの代わりに、あなたのEncryptedStoreのオプションをセットする"
"NSDictionaryを作成してください。\n"
"\n"
"    NSDictionary *options = @{ EncryptedStorePassphraseKey: (NSString *) "
"customPasscode,\n"
"                               EncryptedStoreCacheSize: (NSNumber *) "
"customCacheSize,\n"
"                               EncryptedStoreDatabaseLocation: (NSURL *) "
"customDatabaseURL\n"
"    };\n"
"\n"
"In your application delegate source file (i.e. AppDelegate.m) you should "
"see\n"
"\n"
"    NSPersistentStoreCoordinator *coordinator = [self "
"persistentStoreCoordinator];\n"
"\n"
"If you created an NSDictionary with custom options, replace that line with\n"
"\n"
"    NSPersistentStoreCoordinator *coordinator = [EncryptedStore "
"makeStoreWithOptions:options managedObjectModel:[self managedObjectModel]];\n"
"\n"
"The project is available [here](https://github.com/project-imas/encrypted-"
"core-data).\n"

#: vulnerabilities.py:1646
msgid "Unsecured Data in CouchDB"
msgstr "CouchDBの安全でないデータ"

#: vulnerabilities.py:1647
msgid "Does this application store data in CouchDB?"
msgstr "このアプリケーションはCouchDBにデータを保存していますか？"

#: vulnerabilities.py:1648
msgid "This application does not store sensitive information in CouchDB."
msgstr "このアプリケーションはCouchDBに機密情報を保存していません。"

#: vulnerabilities.py:1649
msgid ""
"\n"
"Couch databases are used by the applications to store data which can be\n"
"further used by the application at later stages. However, these\n"
"databases don't have any built-in support for encryption and hence, all\n"
"the information is stored in plain-text format in these files. If an\n"
"application stores user credentials or some sensitive user specific data\n"
"in this database then it can be accessed by any third party.\n"
msgstr ""
"\n"
"CouchDBはアプリケーションで使用可能なデータを保存するために使用されます。しか"
"し、これらのデータベースはいかなる暗号ためのビルトインサポートを持っていない"
"ので、すべての情報は平文形式でこれらのファイルに保存されます。もしアプリケー"
"ションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこのデータベー"
"スに保存するなら、第三者にアクセスされる可能性があります。\n"

#: vulnerabilities.py:1657
msgid ""
"\n"
"CouchDB is an alternative to SQLite3 database, used by applications to\n"
"store data\n"
msgstr ""
"\n"
"CouchDB は SQLite3 データベースの代替として、データ保存のためにアプリケーショ"
"ンに使用されます。\n"

#: vulnerabilities.py:1665
msgid ""
"\n"
"It is suggested to use custom encryption while storing data in Couch\n"
"Database.\n"
"\n"
"Database encryption is available for both ForestDB and SQLite storage\n"
"types. It is automatically hooked into ForestDB's filesystem abstraction\n"
"layer and for SQLite storage, Couchbase Lite uses SQLCipher; an open\n"
"source extension to SQLite that provides transparent encryption of\n"
"database files. In both cases, the encryption specification is 256-bit\n"
"AES.\n"
"\n"
"SQLCipher is an optional dependency. The section below describes how to\n"
"add it to platform.\n"
"\n"
"- Download the iOS SDK from [here](http://www.couchbase.com/nosql-databases/"
"downloads#couchbase-mobile).\n"
"- Add the libsqlcipher.a library to your XCode project.\n"
"- Go to the Link Binary With Libraries build phase of your app target.\n"
"- Remove libsqlite.dylib\n"
"\n"
msgstr ""
"\n"
"CouchDBにデータ保存する際、カスタム暗号化の使用が推奨されます。</p> <p> デー"
"タベース暗号化はForestDBとSQLiteストレージタイプの両方で利用できます。それは"
"自動的にForestDBのファイルシステムの抽象化レイヤーにフックされ、SQLiteスト"
"レージにはCouchbase LiteがSQLCipherを使用します。それはデータベースファイルの"
"透過的な暗号化を付与するSQLiteのオープンソース拡張機能です。両方の場合におい"
"て、暗号化仕様は256-bit AESです。</p> <p> SQLCipherは任意の依存関係です。次の"
"セクションはそれをプラットフォームに追加する方法を記述しています。\n"
"\n"
"- 次のURLからiOS SDKをダウンロード: <a href=\"http://www.couchbase.com/nosql-"
"databases/downloads#couchbase-mobile\">http://www.couchbase.com/nosql-"
"databases/downloads#couchbase-mobile</a>.\n"
"- Xcodeプロジェクトにlibsqlcipher.aライブラリを追加してください。</li>     "
"<li>あなたのapp targetのLink Binary With Librariesビルドフェーズに進んでくだ"
"さい。\n"
"- libsqlite.dylibを除去してください。\n"
"\n"

#: vulnerabilities.py:1695
msgid "Unsecured Data in RealmDB"
msgstr "RealmDBの無担保データ"

#: vulnerabilities.py:1696 vulnerabilities.py:1740
msgid "Does this application store data in RealmDB?"
msgstr "このアプリケーションはRealmDBにデータを保存していますか？"

#: vulnerabilities.py:1697
msgid "This application does not store sensitive information in RealmDB."
msgstr "このアプリケーションはRealmDBに機密情報を保存していません。"

#: vulnerabilities.py:1698
msgid ""
"\n"
"Realm databases are used by the applications to store data which can be\n"
"further used by the application at later stages. However, these\n"
"databases don't have any built-in support for encryption and hence, all\n"
"the information is stored in plain-text format in these files. If an\n"
"application stores user credentials or some sensitive user specific data\n"
"in this database then it can be accessed by any third party.\n"
msgstr ""
"\n"
"Realmデータベースはアプリケーションで使用可能なデータを保存するために使用され"
"ます。しかし、これらのデータベースは暗号のためのビルトインサポートを持ってい"
"ないため、すべての情報が平文形式でファイル保存されます。もしアプリケーション"
"がユーザ資格情報、あるいは重要なユーザ固有データをこのデータベースに保存した"
"場合、第三者にアクセスされる可能性があります。\n"

#: vulnerabilities.py:1706
msgid ""
"\n"
"Realm databases are used by the applications to store data which can be\n"
"further used by the application at later stages. However, these\n"
"databases do not have any built-in support for encryption and hence, all\n"
"the information is stored in plaintext format in these files. If an\n"
"application stores user credentials or some sensitive user specific data\n"
"in this database then it can be accessed by any third party.\n"
msgstr ""
"\n"
"Realmデータベースはアプリケーションで使用可能なデータを保存するために使用され"
"ます。しかし、これらのデータベースは暗号のためのビルトインサポートを持ってい"
"ないため、すべての情報が平文形式でファイル保存されます。もしアプリケーション"
"がユーザ資格情報、あるいは重要なユーザ固有データをこのデータベースに保存した"
"場合、第三者にアクセスされる可能性があります。\n"

#: vulnerabilities.py:1718
msgid ""
"\n"
"It is suggested to use custom encryption while storing data in Realm\n"
"databases.\n"
"\n"
"An encrypted copy of the unencrypted Realm file, which can be done by\n"
"using\n"
"\n"
"    Realm().writeCopyToPath(_:encryptionKey:)\n"
"\n"
"and then can use the encrypted file at the new location.\n"
msgstr ""
"\n"
"RealmDBにデータ保存する際、カスタム暗号化の使用が推奨されます。\n"
"暗号化されていないRealmファイルの暗号化コピー \n"
"\n"
"    Realm().writeCopyToPath(_:encryptionKey:)\n"
"\n"
"新しいロケーションで暗号化されたファイルを使用することができます。\n"

#: vulnerabilities.py:1739
msgid "Unsecured Data in YapDB"
msgstr "YapDBの安全でないデータ"

#: vulnerabilities.py:1741
msgid "This application does not store sensitive information in YapDB."
msgstr "このアプリケーションはYapDBに機密情報を保存していません。"

#: vulnerabilities.py:1742
msgid ""
"\n"
"Yap databases are used by the applications to store data which can be\n"
"further used by the application at later stages. However, these\n"
"databases don't have any built-in support for encryption and hence, all\n"
"the information is stored in plain-text format in these files. If an\n"
"application stores user credentials or some sensitive user specific data\n"
"in this database then it can be accessed by any third party.\n"
msgstr ""
"\n"
"<p>     YapDBはアプリケーションで使用可能なデータを保存するために使用されま"
"す。しかし、これらのデータベースはいかなる暗号ためのビルトインサポートを持っ"
"ていないので、すべての情報は平文形式でこれらのファイルに保存されます。もしア"
"プリケーションがユーザ資格情報あるいは何らかの重要なユーザ固有データをこの"
"データベースに保存するなら、第三者にアクセスされる可能性があります。</p>\n"

#: vulnerabilities.py:1750
msgid ""
"\n"
"YapDB is an alternative to SQLite3 database, used by applications to\n"
"store data\n"
msgstr ""
"\n"
"YapDB は SQLite3 データベースの代替として、データ保存のためにアプリケーション"
"に使用されます。\n"

#: vulnerabilities.py:1758
msgid ""
"\n"
"It is suggested to use custom encryption while storing data in Yap\n"
"databases.\n"
"\n"
"SQLCipher is a SQLite extension that transparently encrypts the entire\n"
"database, and is available under a BSD-style license. SQLCipher support\n"
"has been added as a Cocoapod subspec. Simply change your Podfile:\n"
"\n"
"    pod 'YapDatabase/SQLCipher'\n"
"\n"
"If you aren't using the SQLCipher subspec, the project won't compile the\n"
"encryption configuration options to prevent the case of accidentally\n"
"trying to use encryption when support is not available.\n"
"\n"
"Once the project is configured to use SQLCipher, it then needs to tell\n"
"YapDatabase the passphrase. This is done by setting the cipherKeyBlock\n"
"of YapDatabaseOptions.\n"
"\n"
"    YapDatabaseOptions *options = [[YapDatabaseOptions alloc] init];\n"
"        options.corruptAction = YapDatabaseCorruptAction_Fail;\n"
"        options.cipherKeyBlock = ^ NSData *(void){\n"
"            // You can also do things like fetch from the keychain in here.\n"
"            return [@\"super secure passphrase\" dataUsingEncoding:"
"NSUTF8StringEncoding];\n"
"\n"
"            // Note: The return type is NSData, and does NOT have to be a "
"string in UTF-8.\n"
"            // It can be any kind of blob of data, including randomly "
"generated bytes.\n"
"        };\n"
"\n"
"        self.database = [[YapDatabase alloc] initWithPath:databasePath "
"options:options];\n"
"\n"
"The cipherKeyBlock helps prevent storing the credentials in memory any\n"
"longer than necessary. This block will be executed on database setup,\n"
"and when new connections are made to the database.\n"
msgstr ""
"\n"
"YapDBにデータ保存する際、カスタム暗号化の使用が推奨されます。\n"
"SQLCipherはデータベース全体を透過的に暗号化するSQLiteの拡張機能であり、BSDス"
"タイルのライセンス下で利用可能です。SQLCipherサポートはCocoaPodsのsubspecとし"
"て追加されました。単純にPodfileを変更してください。\n"
"\n"
"    pod 'YapDatabase/SQLCipher'\n"
"\n"
"もしSQLCipherのsubspecを使用していないなら、そのプロジェクトはサポートが利用"
"可能ではないときは偶発的に暗号化を使用されることを防ぐために暗号化構成オプ"
"ションをコンパイルしないでしょう。\n"
"いったんプロジェクトがSQLCipherの使用のために構成されると、YapDBにパスフレー"
"ズを伝える必要があります。これはYapDatabaseOptionsのcipherKeyBlockをセットす"
"ることで実行されます。\n"
"\n"
"    YapDatabaseOptions *options = [[YapDatabaseOptions alloc] init];\n"
"        options.corruptAction = YapDatabaseCorruptAction_Fail;\n"
"        options.cipherKeyBlock = ^ NSData *(void){\n"
"            // You can also do things like fetch from the keychain in here.\n"
"            return [@\"super secure passphrase\" dataUsingEncoding:"
"NSUTF8StringEncoding];\n"
"\n"
"            // Note: The return type is NSData, and does NOT have to be a "
"string in UTF-8.\n"
"            // It can be any kind of blob of data, including randomly "
"generated bytes.\n"
"        };\n"
"\n"
"        self.database = [[YapDatabase alloc] initWithPath:databasePath "
"options:options];\n"
"\n"
"cipherKeyBlockは必要以上に長くメモリに資格情報を保存するのを防ぐのに役立ちま"
"す。このブロックはデータベースセットアップ時、そしてデータベースへの新たな接"
"続が作成された時に実行されます。\n"

#: vulnerabilities.py:1802
msgid "Deprecated NSURLConnection"
msgstr "非推奨のNSURLConnection"

#: vulnerabilities.py:1803
msgid "Does this application use NSURLConnection?"
msgstr "このアプリケーションは NSURLConnection を使用していますか？"

#: vulnerabilities.py:1804
msgid "This application does not use NSURLConnection to connect over Internet."
msgstr ""
"このアプリケーションはインターネットへの接続に NSURLConnection を使用していま"
"せん。"

#: vulnerabilities.py:1805
msgid ""
"\n"
"`NSURLConnection` is the most common API used for establishing network\n"
"connections with the server. However, it has been replaced by\n"
"`NSURLSession` & deprecated by Apple starting iOS 9.0. `NSURLSession`\n"
"provides support for configuring per-session cache, protocol, cookie,\n"
"and credential policies, rather than sharing them across the app which\n"
"handles authentication challenge in a more appropriate way.\n"
msgstr ""
"\n"
"<p>     NSURLConnection はサーバとのネットワーク接続の構築に使われる最も一般"
"的な API です。しかし、 NSURLSession によって取って代わられてきました。iOS "
"9.0を始めた Apple に推奨されておりません。NSURLSession はセッション単位の"
"キャッシュ、プロトコル、クッキー、そして資格情報ポリシーの、より適切な方法で"
"認証チャレンジをするアプリ同士の共有ではなく、構成のサポートをします。 </p>\n"

#: vulnerabilities.py:1813
msgid ""
"\n"
"`NSURLConnection` is the most common API used for establishing network\n"
"connections with the server. However, it has been replaced by\n"
"`NSURLSession` & deprecated by Apple starting iOS 9.0\n"
msgstr ""
"\n"
"NSURLConnection はサーバとのネットワーク接続を確立するのために使用される最も"
"一般的なAPIでしたが、 NSURLSession に移行され、iOS 9.0 以降 Apple は非推奨と"
"しています。\n"

#: vulnerabilities.py:1818
msgid ""
"\n"
"Using deprecated routines may potentially result in:\n"
"\n"
"- Programming errors due to fatal flaws in deprecated methods.\n"
"- Data corruption due to unsafe deprecated methods.\n"
"\n"
msgstr ""
"\n"
"<p>   推奨されないルーティンの使用は次の結果につながる可能性があります:    "
"<ol>         <li>推奨されないメソッド内の致命的な欠陥によるプログラミングエ"
"ラー</li>         <li>安全でない推奨されないメソッドによるデータ破損</"
"li>     </ol> </p\n"

#: vulnerabilities.py:1825
msgid ""
"\n"
"It is advisable to use `NSURLSession` for all types of network connections\n"
"instead of `NSURLConnection` because Apple can stop supporting\n"
"`NSURLConnection` anytime in near future.\n"
"\n"
"`NSURLSession` is the key object responsible for sending and receiving\n"
"HTTP requests. It can be created via `NSURLSessionConfiguration`, which\n"
"comes in three flavors:\n"
"\n"
"`defaultSessionConfiguration`: Creates a default configuration object\n"
"that uses the disk-persisted global cache, credential and cookie storage\n"
"objects.\n"
"\n"
"`ephemeralSessionConfiguration`: Similar to the default configuration,\n"
"except that all session-related data is stored in memory. Think of this\n"
"as a \"private\" session.\n"
"\n"
"`backgroundSessionConfiguration`: Lets the session perform upload or\n"
"download tasks in the background. Transfers continue even when the app\n"
"itself is suspended or terminated.\n"
"\n"
"NSURLSessionConfiguration also lets you configure session properties\n"
"such as timeout values, caching policies and additional HTTP headers.\n"
"Refer to the documentation for a full list of configuration options.\n"
"\n"
"    /* Sent when a download task that has completed a download.  The "
"delegate should\n"
"     * copy or move the file at the given location to a new location as it "
"will be\n"
"     * removed when the delegate message returns. URLSession:task:"
"didCompleteWithError: will\n"
"     * still be called.\n"
"     */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                  didFinishDownloadingToURL:(NSURL "
"*)location;\n"
"\n"
"    /* Sent periodically to notify the delegate of download progress. */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                               didWriteData:"
"(int64_t)bytesWritten\n"
"                                          totalBytesWritten:"
"(int64_t)totalBytesWritten\n"
"                                  totalBytesExpectedToWrite:"
"(int64_t)totalBytesExpectedToWrite;\n"
"\n"
"    /* Sent when a download has been resumed. If a download failed with an\n"
"     * error, the -userInfo dictionary of the error will contain an\n"
"     * NSURLSessionDownloadTaskResumeData key, whose value is the resume\n"
"     * data.\n"
"     */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                          didResumeAtOffset:"
"(int64_t)fileOffset\n"
"                                         expectedTotalBytes:"
"(int64_t)expectedTotalBytes;\n"
"\n"
msgstr ""
"\n"
"Appleが近い将来 NSURLConnection のサポートを停止する可能性があるため、すべて"
"のタイプのネットワーク接続に、NSURLConnection の代わりとして NSURLSession を"
"使用することをお勧めします。\n"
"\n"
"NSURLSessionは、HTTPリクエストの送受信を担うキーオブジェクトです。 "
"NSURLSessionConfiguration を介して作成することができます。これには3つの種類が"
"あります。\n"
"\n"
"`defaultSessionConfiguration`：ストレージに永続化されたキャッシュ、資格情報お"
"よびcookieのストレージを使用するデフォルト設定オブジェクトを作成します。\n"
"\n"
"`ephemeralSessionConfiguration`：defaultSessionConfiguration と似ていますが、"
"すべてのセッション関連のデータがメモリに格納される点が異なります。これを「プ"
"ライベートセッション」と考えてください。\n"
"\n"
"`backgroundSessionConfiguration`：セッションがバックグラウンドでアップロード"
"またはダウンロードタスクを実行できるようにします。アプリケーション自体が一時"
"停止または終了してもセッションは継続されます。\n"
"\n"
"NSURLSessionConfigurationでは、タイムアウト値、キャッシュポリシー、追加のHTTP"
"ヘッダーなどのセッションプロパティーを設定することもできます。構成オプション"
"の一覧については、資料を参照してください。\n"
"\n"
"    /* Sent when a download task that has completed a download.  The "
"delegate should\n"
"     * copy or move the file at the given location to a new location as it "
"will be\n"
"     * removed when the delegate message returns. URLSession:task:"
"didCompleteWithError: will\n"
"     * still be called.\n"
"     */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                  didFinishDownloadingToURL:(NSURL "
"*)location;\n"
"\n"
"    /* Sent periodically to notify the delegate of download progress. */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                               didWriteData:"
"(int64_t)bytesWritten\n"
"                                          totalBytesWritten:"
"(int64_t)totalBytesWritten\n"
"                                  totalBytesExpectedToWrite:"
"(int64_t)totalBytesExpectedToWrite;\n"
"\n"
"    /* Sent when a download has been resumed. If a download failed with an\n"
"     * error, the -userInfo dictionary of the error will contain an\n"
"     * NSURLSessionDownloadTaskResumeData key, whose value is the resume\n"
"     * data.\n"
"     */\n"
"    - (void)URLSession:(NSURLSession *)session downloadTask:"
"(NSURLSessionDownloadTask *)downloadTask\n"
"                                          didResumeAtOffset:"
"(int64_t)fileOffset\n"
"                                         expectedTotalBytes:"
"(int64_t)expectedTotalBytes;\n"
"\n"

#: vulnerabilities.py:1884
msgid "PhoneGap JavaScript Injection"
msgstr "PhoneGapのJavaScriptインジェクション"

#: vulnerabilities.py:1885
msgid "Does the application have PhoneGap javascript injection vulnerability?"
msgstr ""
"アプリケーションに PhoneGap の JavaScript インジェクションの脆弱性があります"
"か？"

#: vulnerabilities.py:1886
msgid ""
"The application does not seem to be affected by PhoneGap javascript "
"injection."
msgstr ""
"アプリケーションは、PhoneGap の JavaScript インジェクションの影響を受けていな"
"いようです。"

#: vulnerabilities.py:1887
msgid ""
"\n"
"PhoneGap uses web technology to help bridge the gap between mobile and\n"
"web.\n"
"\n"
"Applications built for PhoneGap are hybrid apps, and are neither fully\n"
"native or truly web-based, living somewhere in between. Because mobile\n"
"OSes don't natively support HTML5 and JavaScript, PhoneGap apps use\n"
"WebView, a web container that allows mobile devices to execute\n"
"JavaScript and HTML5. WebView (called various terms for differing\n"
"platforms) helps bridge the gap between web and mobile, and various\n"
"plugins help make an application more robust and native-feeling.\n"
"\n"
"Communicating with each OS, PhoneGap uses different APIs (built by\n"
"PhoneGap) and plugins (both native and custom), which act as the bridge\n"
"between each platform's native language and the PhoneGap script. Out of\n"
"the box, PhoneGap comes with APIs for Camera, Contacts, Compass, Media,\n"
"FileSystem and more. Plugins extend those functionalities not accessible\n"
"with the available APIs.\n"
msgstr ""
"\n"
"<p> PhoneGap はWeb テクノロジーによってモバイルとWeb 間のギャップの橋渡しをす"
"るために使用します。</p><p>PhoneGap のために作られたアプリケーションはハイブ"
"リッドアプリであり、完全に自然のものやウェブベースでもなく、その間のどこかに"
"位置します。モバイル OS は HTML5 と JavaScript、 PhoneGap アプリをサポートし"
"ないので、モバイルデバイスに JavaScript と HTML5 の実行を許可するウェブコンテ"
"ナである、WebViewを使用してください。 WebView (異なるプラットフォームの様々な"
"タームと呼ばれる) はモバイルとWeb 間のギャップの橋渡しをし、様々な plugins は"
"アプリをより強固で直感的にするのを助けます。</p><p>それぞれの OS との通信のた"
"め、 PhoneGap は異なる API (PhoneGap によって作られた) を使用し、 plugins (ネ"
"イティブ と カスタム 両方で)それぞれのプラットフォームのネイティブ言語と"
"PhoneGap スクリプト間の橋渡しのように振舞います。 box から、 PhoneGap は "
"Camera, Contacts, Compass, Media, FileSystem などのためにAPI と一緒に来ます。"
"Plugins はこれらの利用可能なAPIにアクセスできない機能を拡張します。 </p>\n"

#: vulnerabilities.py:1906
msgid ""
"\n"
"Application using older version of Phonegap has Javascript Injection\n"
"Vulnerability\n"
msgstr ""
"\n"
"古いバージョンの PhoneGap を使用しているアプリケーションは Javascript イン"
"ジェクションの脆弱性を持っています。\n"

#: vulnerabilities.py:1910 vulnerabilities.py:1948 vulnerabilities.py:1986
msgid ""
"\n"
"With the presence of this vulnerability, attackers may:\n"
"\n"
"- Open and send data to arbitrary applications.\n"
"- Bypass the HTTP whitelist and connect to arbitrary servers.\n"
"- Change the start page via a crafted intent URL.\n"
"\n"
msgstr ""
"\n"
"<p>この脆弱性が存在すると、攻撃者は次のようなことが出来る可能性があります。</"
"p> \n"
"<ul>\n"
"<li>アプリケーションにデータを送信</li>\n"
"<li>HTTPホワイトリストをバイパスし、任意のサーバーに接続 </li>\n"
"<li>細工したインテントURLを使用して開始ページを変更</li>\n"
"</ul>\n"

#: vulnerabilities.py:1918 vulnerabilities.py:1994 vulnerabilities.py:2036
msgid ""
"\n"
"Upgrade Phonegap or Apache Cordova to the latest version.\n"
msgstr ""
"\n"
"<p>     Phonegap あるいは Apache Cordova を最新バージョンにアップグレードして"
"ください。</p>\n"

#: vulnerabilities.py:1931
msgid "Remote URL Redirection Vulnerability"
msgstr "リモートURLリダイレクトの脆弱性"

#: vulnerabilities.py:1932
msgid ""
"Does the application use an older version of PhoneGap that allows remote "
"attackers to perform URL redirection?"
msgstr ""
"リモート攻撃者がURLリダイレクトを実行可能な、古いバージョンのPhoneGapをアプリ"
"ケーションで使用していますか？"

#: vulnerabilities.py:1933
msgid ""
"The application is not vulnerable to URL redirection vulnerability, or is "
"not using PhoneGap."
msgstr ""
"このアプリケーションは、URLリダイレクトの脆弱性に対して脆弱ではないか、"
"PhoneGapを使用していません。"

#: vulnerabilities.py:1934
msgid ""
"\n"
"Android applications built with the Cordova framework can be launched\n"
"through a special intent URL. A specially-crafted URL could cause the\n"
"Cordova-based application to start up with a different start page than\n"
"the developer intended, including other HTML content stored on the\n"
"Android device. This has been the case in all released versions of\n"
"Cordova up to 3.5.0, and has been fixed in the latest release (3.5.1).\n"
"We recommend affected projects to update their applications to the\n"
"latest release.\n"
msgstr ""
"\n"
"<p>   Cordova framework でビルドされた Android アプリは特殊なインテント URL "
"を通して起動される可能性があります。特殊に細工された URL は Cordova ベースの"
"アプリを他の Android デバイスに保存された HTML コンテントを含む、開発者が意図"
"したものと異なるスタートページでスタートアップさせる可能性があります。これは "
"3.5.0 までの Cordova のすべてのリリースされたバージョンの場合で、最新リリー"
"ス (3.5.1) では修正されました。影響を受けたプロジェクトはそれらのアプリを最新"
"リリースへアップデートすることを推奨します。 </p>\n"

#: vulnerabilities.py:1944
msgid ""
"\n"
"Android application which uses older version of PhoneGap is vulnerable\n"
"to URL redirection to arbitary website as defined by CVE-3500\n"
msgstr ""
"\n"
"古いバージョンの PhoneGap を使用している Android アプリケーションは、"
"CVE-3500 で定義されている恣意的なWebサイトへのURLリダイレクトに対して脆弱で"
"す。\n"

#: vulnerabilities.py:1956
msgid ""
"\n"
"Upgrade your Phonegap or Apache Cordova application to the latest\n"
"Version\n"
msgstr ""
"\n"
"PhonegapまたはApache Cordovaアプリケーションを最新バージョンにアップグレード"
"してください。\n"

#: vulnerabilities.py:1970
msgid "PhoneGap Error URL Redirection Vulnerability"
msgstr "PhoneGap エラー URLリダイレクトの脆弱性"

#: vulnerabilities.py:1971
msgid ""
"Can the application allow remote attackers to perform Error URL redirection?"
msgstr ""
"アプリケーションは、リモートの攻撃者にエラーURLのリダイレクトを実行させること"
"はできますか？"

#: vulnerabilities.py:1972
msgid ""
"The application is not vulnerable to error URL redirection vulnerability, or "
"is not using PhoneGap."
msgstr ""
"アプリケーションは、エラーURLリダイレクトの脆弱性に対して脆弱ではないか、"
"PhoneGap を使用していません。"

#: vulnerabilities.py:1973
msgid ""
"\n"
"Cordova-based applications make use of a WebView in order to interact\n"
"with the user. This vulnerability uses the errorurl parameter which can\n"
"be passed via Intent extras (in CordovaActivity) by a malicious caller,\n"
"but it is not automatically loaded into a WebView on application load.\n"
"The errorurl will only be rendered by the WebView when a network request\n"
"fails. This presents a vulnerability which can be exploited whereby a\n"
"malicious caller could launch the Activity.\n"
msgstr ""
"\n"
"<p>     Cordova ベースのアプリはユーザーとの対話のために WebView を利用しま"
"す。この脆弱性は悪意のある発信者によってインテント extras (CordovaActivity "
"内) を介してパスされる可能性があるエラー URL パラメーターを利用しますが、それ"
"はアプリロードで自動的に WebView へロードされません。エラー URL はネットワー"
"クリクエスト失敗時に WebView によって表示のみされます。これは脆弱性を利用され"
"ることによって、悪意のある発信者がアクティビティを起動する可能性があることを"
"示しています。 </p>\n"

#: vulnerabilities.py:1982
msgid ""
"\n"
"Android application which uses older version of PhoneGap is vulnerable\n"
"to Error URL redirection to arbitary website as defined by CVE-3500\n"
msgstr ""
"\n"
"古いバージョンのPhoneGapを使用しているAndroidアプリケーションは、CVE-3500で定"
"義されている恣意的な Web サイトへのエラー URL リダイレクトに対して脆弱で"
"す。\n"

#: vulnerabilities.py:2007
msgid "PhoneGap HTTPS Bypass Vulnerability"
msgstr "PhoneGap HTTPSバイパスの脆弱性"

#: vulnerabilities.py:2008
msgid ""
"Is the application using deprecated version of PhonGap which is susceptible "
"to HTTPS Bypass?"
msgstr ""
"アプリケーションは、HTTPS バイパスの影響を受けやすい PhonGap の非推奨バージョ"
"ンを使用していますか？"

#: vulnerabilities.py:2009
msgid ""
"The application does not use a vulnerable version of PhoneGap, or is not "
"using PhoneGap."
msgstr ""
"アプリケーションは PhoneGap の脆弱なバージョンを使用していないか、PhoneGap を"
"使用していません。"

#: vulnerabilities.py:2010
msgid ""
"\n"
"Android applications built with the Cordova framework use a WebView\n"
"component to display content. Cordova applications can specify a\n"
"whitelist of URLs which the application will be allowed to display, or\n"
"to communicate with via XMLHttpRequest. This whitelist, however, is not\n"
"used by the WebView component when it is directed via JavaScript to\n"
"communicate over non-http channels.\n"
"\n"
"Specifically, it can be possible to open a WebSocket connection from the\n"
"application JavaScript which will connect to any reachable server on the\n"
"Internet. If an attacker is able to execute arbitrary JavaScript within\n"
"the application, then that attacker can cause a connection to be opened\n"
"to any server, bypassing the HTTP whitelist.\n"
"\n"
"This is a limitation of the hybrid app architecture on Android in\n"
"general, and not specific to Apache Cordova.\n"
msgstr ""
"\n"
"<p>      Cordova framework でビルドされた Android アプリは、コンテンツを表示"
"するために WebView コンポーネントを使用します。Cordova アプリは表示、あるい"
"は XMLHttpRequest 経由での通信を許可される URL ホワイトリストを特殊化する可能"
"性があります。しかし、このホワイトリストは非 http チャネルで通信するために "
"JavaScript 経由で指示された時、 WebView コンポーネントによって使用されませ"
"ん。  </p> <p>   具体的に、インターネット上の届きうるサーバーに接続するアプリ"
"ケーション JavaScript  からWebSocket 接続を開くことが可能です。もし攻撃者がア"
"プリ内の任意の JavaScript を実行することが可能なら、攻撃者は HTTP ホワイトリ"
"ストを回避して接続をどんなサーバーにも開くことが可能になります。</p> <p>    "
"これは一般的な Android 上のハイブリッドアプリ構造の制限事項であり、 Apache "
"Cordova に限ったことではありません。</p>\n"

#: vulnerabilities.py:2027
msgid ""
"\n"
"Deprecated Android PhoneGap application is affected with CVE-3501 via\n"
"which attackers can downgrade HTTPS connection to HTTP\n"
msgstr ""
"\n"
"推奨されない AndroidのPhoneGap アプリケーションは、攻撃者が HTTPS 接続を "
"HTTP にダウングレードできるCVE-3501の影響を受けます。\n"

#: vulnerabilities.py:2031
msgid ""
"\n"
"The attacker can open a WebSocket connection from the application\n"
"JavaScript which will connect to any remote server bypassing the HTTP\n"
"whitelist.\n"
msgstr ""
"\n"
"<p>     攻撃者はHTTPホワイトリストを回避する任意のリモートサーバへ接続する "
"JavaScript アプリからの WebSocket 接続を開く可能性があります。 </p>\n"

#: vulnerabilities.py:2049
msgid "PhoneGap HTTPS Whitelist Bypass"
msgstr "PhoneGap HTTPS ホワイトリストのバイパス"

#: vulnerabilities.py:2050
msgid "Does the PhoneGap application use vulnerable regex for whitelisting?"
msgstr ""
"アプリケーションは phonegap でのホワイトリスト化に誤った regex を使用していま"
"せんか？"

#: vulnerabilities.py:2051
msgid ""
"The PhoneGap application seems to be using proper regex check, or is not "
"using PhoneGap."
msgstr ""
"phonegap アプリケーションは適切な regex チェックを使用、あるいは適切に "
"phonegapを使用していないようです。"

#: vulnerabilities.py:2052
msgid ""
"\n"
"In order to ensure that a Cordova WebView only allows requests to URLs\n"
"in the configured whitelist, the framework overrides Android's\n"
"`shouldInterceptRequest()`\n"
"\n"
"The use of `shouldInterceptRequest()` to provide the whitelisting\n"
"mechanism is problematic in that it is used to intercept only certain\n"
"requests (such as those serviced over HTTP/S or through the file URI).\n"
"There may be protocols for which this function is not called by the\n"
"Android framework. As of Android 4.4 KitKat, the WebView is rendered by\n"
"Chromium and supports Web Sockets which one such protocol. An attacker\n"
"can therefore make use of a WebSocket connection to bypass the Cordova's\n"
"white-listing mechanism.\n"
msgstr ""
"\n"
"Cordova WebView が設定されたホワイトリストのURLへのリクエストのみを許可するた"
"めに、フレームワーク は Android の shouldInterceptRequest（）をオーバーライド"
"します。\n"
"\n"
"ホワイトリスト作成メカニズムを提供するために shouldInterceptRequest（）を使用"
"することは、特定の要求（HTTP / HTTPSを介して処理されるものやファイルURIを介し"
"て処理されるものなど）のみを傍受するために使用される点で問題があります。\n"
"Android フレームワークがこの関数を呼び出せないプロトコルがあります。 Android "
"4.4 KitKatでは、WebView は Chromium によってレンダリングされ、そのようなプロ"
"トコルの1つである Web Sockets をサポートしています。 したがって、攻撃者は "
"WebSocket 接続を利用して、Cordova のホワイトリストメカニズムをバイパスするこ"
"とができます。\n"

#: vulnerabilities.py:2066
msgid ""
"\n"
"In PhoneGap if regex is used to whitelist, this checks if HTTPS can be\n"
"bypassed from that regex\n"
msgstr ""
"\n"
"PhoneGapでは、正規表現がホワイトリストに使用されている場合、その正規表現から"
"HTTPSをバイパスできるかチェックします。\n"

#: vulnerabilities.py:2070
msgid ""
"\n"
"An attacker can bypass the Cordova's white-listing mechanism and\n"
"initiate connections to unauthorized remote servers. This may aid in\n"
"further attacks.\n"
msgstr ""
"\n"
"<p>    攻撃者は Cordova の ホワイトリスト化メカニズムを回避し、権利化されてい"
"ないリモートサーバへの接続を初期化する可能性があります。 これは更なる攻撃を助"
"長する可能性があります。</p>\n"

#: vulnerabilities.py:2075
msgid ""
"\n"
"Domain whitelisting is a security model that controls access to external\n"
"domains over which you application has no control. Cordova's default\n"
"security policy allows access to any site. Before moving your\n"
"application to production, you should formulate a whitelist and allow\n"
"access to specific network domains and subdomains.\n"
"\n"
"Cordova adheres to the W3C Widget Access specification, which relies on\n"
"the `<access>` element within the app's `config.xml` file to enable\n"
"network access to specific domains. For projects that rely on the CLI\n"
"workflow described in The Command-Line Interface, this file is located\n"
"in the project's top-level directory. Otherwise for platform-specific\n"
"development paths, locations are listed in the sections below:\n"
"\n"
"The following examples demonstrate whitelist syntax:\n"
"\n"
"Access to google.com\n"
"\n"
"    <access origin=\"http://google.com\" />\n"
"\n"
"Access to the secure google.com:\n"
"\n"
"    <access origin=\"https://google.com\" />\n"
"\n"
"Access to the subdomain maps.google.com:\n"
"\n"
"    <access origin=\"http://maps.google.com\" />\n"
"\n"
"Access to all the subdomains on google.com, for example, mail.google.com and "
"docs.google.com:\n"
"\n"
"    <access origin=\"http://*.google.com\" />\n"
"\n"
"Access to all domains, for example, google.com and developer.mozilla.org:\n"
"\n"
"    <access origin=\"*\" />\n"
"\n"
"This is the default value for newly created CLI projects which not secured.\n"
"\n"
"Also upgrade your PhoneGap or Apache Cordova application to the latest "
"version\n"
msgstr ""
"\n"
"ドメインホワイトリストは、アプリケーションが制御できない外部ドメインへのアク"
"セスを制御するセキュリティモデルです。 Cordovaのデフォルトのセキュリティポリ"
"シーでは、どのサイトにもアクセスできます。 アプリケーションを本番環境に移行す"
"る前に、ホワイトリストを作成し、特定のネットワークドメインとサブドメインにア"
"クセスできるようにする必要があります。\n"
"Cordovaは、特定のドメインへのネットワークアクセスを可能にするために、アプリ"
"ケーションの `config.xml`ファイル内の `<access>` 要素に依存するW3C Widget "
"Access仕様に準拠しています。 コマンドラインインターフェイスで説明されている"
"CLIワークフローに依存するプロジェクトの場合、このファイルはプロジェクトの最上"
"位ディレクトリにあります。 それ以外のプラットフォーム固有の開発パスの場合は、"
"次のセクションで場所を示します。：\n"
"次の例はホワイトリストの構文を例示しています：\n"
"\n"
"Access to google.com\n"
"\n"
"    <access origin=\"http://google.com\" />\n"
"\n"
"Access to the secure google.com:\n"
"\n"
"    <access origin=\"https://google.com\" />\n"
"\n"
"Access to the subdomain maps.google.com:\n"
"\n"
"    <access origin=\"http://maps.google.com\" />\n"
"\n"
"Access to all the subdomains on google.com, for example, mail.google.com and "
"docs.google.com:\n"
"\n"
"    <access origin=\"http://*.google.com\" />\n"
"\n"
"Access to all domains, for example, google.com and developer.mozilla.org:\n"
"\n"
"    <access origin=\"*\" />\n"
"\n"
"これは、保護されていない新しく作成されたCLIプロジェクトのデフォルト値です。\n"
"\n"
"また、PhoneGapまたはApache Cordovaアプリケーションを最新バージョンにアップグ"
"レードしてください。\n"

#: vulnerabilities.py:2125
msgid "Cordova Remote Start Page Manipulation Vulnerability"
msgstr "Cordovaのリモートスタートページ操作の脆弱性"

#: vulnerabilities.py:2126
msgid ""
"Is the application affected by CVE-3500 that allows remote attackers to "
"change the start page?"
msgstr ""
"アプリケーションは、リモートの攻撃者によるスタートページ変更の CVE-3500 に影"
"響されますか？"

#: vulnerabilities.py:2127
msgid ""
"The application is not affected by CVE-3500, or Apache Cordova is not being "
"used."
msgstr ""
"アプリケーションはCVE-3500の影響を受けません。または、Apache Cordovaは使用さ"
"れていません。"

#: vulnerabilities.py:2128
msgid ""
"\n"
"Apache Cordova for Android version 3.5.0 and prior are vulnerable.\n"
"Attackers can exploit these issues to bypass security restrictions to\n"
"perform unauthorized actions. This may aid in further attacks.\n"
msgstr ""
"\n"
"Android 版3.5.0以前の Apache Cordova は脆弱です。\n"
"攻撃者は、これらの問題を悪用して、セキュリティ制限をバイパスして不正な操作を"
"実行することができます。 これによりさらなる攻撃の可能性があります。\n"

#: vulnerabilities.py:2133
msgid ""
"\n"
"According to CVE-3500 Apache Cordova had a vulnerability to change the\n"
"start page\n"
msgstr ""
"\n"
"CVE-3500 によると、Apache Cordovaはスタートページを変更する脆弱性を持っていま"
"した。\n"

#: vulnerabilities.py:2137
msgid ""
"\n"
"With Cordova 3.5.0 or prior, attackers may:\n"
"\n"
"- Open and send data to arbitrary applications.\n"
"- Bypass the HTTP whitelist and connect to arbitrary servers.\n"
"- Change the start page via a crafted intent URL.\n"
"\n"
msgstr ""
"\n"
"<p>     Cordova 3.5.0 未満では、攻撃者は:     <ul>         <li>データを開き、"
"任意のアプリケーションに送ります</li>         <li> HTTP ホワイトリストを回避"
"し、任意のサーバに接続します</li>         <li>細工されたインテント URL でス"
"タートページを変更します</li>     </ul> </p>\n"

#: vulnerabilities.py:2145
msgid ""
"\n"
"Upgrade PhoneGap or Apache Cordova to the latest version.\n"
msgstr ""
"\n"
"<p>     Phonegap あるいは Apache Cordova を最新バージョンにアップグレードして"
"ください。</p>\n"

#: vulnerabilities.py:2158 vulnerabilities.py:3916
msgid "PhoneGap Debug Logging"
msgstr "PhoneGapのデバッグログの出力"

#: vulnerabilities.py:2159
msgid "Are PhoneGap application debug logs enabled?"
msgstr "PhoneGapアプリケーションのデバッグログは有効になっていますか？"

#: vulnerabilities.py:2160
msgid "PhoneGap debug logs are not enabled, or PhoneGap is not being used."
msgstr ""
"PhoneGapデバッグログが有効になっていないか、PhoneGapが使用されていません。"

#: vulnerabilities.py:2161
msgid ""
"\n"
"Once a PhoneGap app gets shipped with debug mode switched \"on\" then\n"
"anyone can attach a debugger and change the logical flow of the\n"
"application. Also, sensitive logs get leaked which can be used to\n"
"determine the URL endpoints of the application.\n"
msgstr ""
"\n"
"<p>   PhoneGap アプリがデバッグモードのスイッチがONの状態で出荷されると、誰で"
"もデバッガーをアタッチしてアプリの論理フローを変更することが可能です。 また、"
"重要なログが流出し、アプリの URL エンドポイントを決定するために使用される可能"
"性があります。　</p>\n"

#: vulnerabilities.py:2167
msgid ""
"\n"
"While using PhoneGap to develop application, always stop debugging logs\n"
"via PhoneGap\n"
msgstr ""
"\n"
"アプリケーション開発のためにPhoneGapを使用している間は、常にPhoneGap経由でデ"
"バッグログを停止してください。\n"

#: vulnerabilities.py:2171
msgid ""
"\n"
"An attacker can attach a debugger and change the logical flow of the\n"
"application. Additionally, sensitive logs can get leaked which can be\n"
"used to determine the URL endpoints of the application.\n"
msgstr ""
"\n"
"<p>    攻撃者はデバッガーをアタッチし、アプリの論理フローを変える可能性があり"
"ます。さらに、アプリの URL エンドポイントを決定するために利用される重要なログ"
"は漏洩する可能性があります。</p>\n"

#: vulnerabilities.py:2176
msgid ""
"\n"
"If using Cordova, please publish the plugin using\n"
"\n"
"    cordova build android --release\n"
"\n"
"If using PhoneGap, please turn of all console.logs() and other logging\n"
"codes before publishing\n"
"\n"
"Also, Loglevel should be set to \"**INFO**\" in \"*config.xml*\"\n"
"\n"
"`<preference name=\"loglevel\" value=\"INFO\" />`\n"
"\n"
msgstr ""
"\n"
"Cordovaを使用している場合は、使用しているプラグインを公開してください。\n"
"    cordova build android --release\n"
"\n"
"PhoneGapを使用している場合は、公開前にすべてのconsole.logs（）とその他のログ"
"コードをオフにしてください。\n"
"\n"
"また、ログレベルは以下のように設定してください。\n"
" \"**INFO**\" in \"*config.xml*\"\n"
"\n"
"`<preference name=\"loglevel\" value=\"INFO\" />`\n"

#: vulnerabilities.py:2199
msgid "PhoneGap Whitelisted URLs"
msgstr "PhoneGap ホワイトリストに登録されたURL"

#: vulnerabilities.py:2200
msgid "Does the PhoneGap application properly whitelist URLs"
msgstr ""
"PhoneGap アプリケーションは URL を適切にホワイトリストを適用していますか？"

#: vulnerabilities.py:2201
msgid "Application has proper whitelisted URLs, or does not use PhoneGap."
msgstr ""
"アプリケーションに適切なホワイトリストのURLがあるか、PhoneGapを使用していませ"
"ん。"

#: vulnerabilities.py:2202
msgid ""
"\n"
"Domain whitelisting is a security model that controls access to external\n"
"domains over which your application has no control. Cordova provides a\n"
"configurable security policy to define which external sites may be\n"
"accessed. By default, new apps are configured to allow access to any\n"
"site. Before moving your application to production, you should formulate\n"
"a whitelist and allow access to specific network domains and subdomains.\n"
msgstr ""
"\n"
"<p>   ドメインのホワイトリストは、あなたのアプリが制御できない外部のドメイン"
"へのアクセスを制御するセキュリティモデルです。 Cordova はどの外部サイトがアク"
"セス可能か定義するために、構成可能なセキュリティポリシーを付与します。デフォ"
"ルトでは、新しいアプリはどんなサイトへのアクセスも許可するよう構成されていま"
"す。　アプリを実稼動に移行する前に、ホワイトリストを生成し、特定のネットワー"
"クドメインとサブドメインへのアクセスを許可するべきです。</p>\n"

#: vulnerabilities.py:2210
msgid ""
"\n"
"While using PhoneGap to develop application, always try to whitelist the\n"
"URL via which it connects\n"
msgstr ""
"\n"
"アプリケーション開発のためにPhoneGapを使用している間は、常に接続するURLをホワ"
"イトリストに登録してください。\n"

#: vulnerabilities.py:2214
msgid ""
"\n"
"Without Domain Whitelisting, an attacker can load any domain in an\n"
"iframe and any script on that page within the iframe can directly access\n"
"Cordova JavaScript objects and the corresponding native Java objects.\n"
msgstr ""
"\n"
"<p>     ドメインホワイトリスト無しでは、攻撃者が iframe のドメインをロードす"
"る可能性があり、iframe 内のそのページのスクリプトは直接 Cordova JavaScript オ"
"ブジェクトと corresponding native Java objects にアクセスする可能性がありま"
"す。</p>\n"

#: vulnerabilities.py:2219
msgid ""
"\n"
"Cordova adheres to the W3C Widget Access specification, which relies on\n"
"the `<access>` element within the app's `config.xml` file to enable\n"
"network access to specific domains. For projects that rely on the CLI\n"
"workflow described in The Command-Line Interface, this file is located\n"
"in the project's top-level directory. Otherwise for platform-specific\n"
"development paths, locations are listed in the sections below:\n"
"\n"
"The following examples demonstrate whitelist syntax:\n"
"\n"
"Access to google.com:\n"
"\n"
"    <access origin=\"http://google.com\" />\n"
"\n"
"Access to the secure google.com:\n"
"\n"
"    <access origin=\"https://google.com\" />\n"
"\n"
"Access to the subdomain maps.google.com:\n"
"\n"
"    <access origin=\"http://maps.google.com\" />\n"
"\n"
"Access to all the subdomains on google.com, for example, mail.google.com and "
"docs.google.com:\n"
"\n"
"    <access origin=\"http://*.google.com\" />\n"
"\n"
"Access to all domains, for example, google.com and developer.mozilla.org:\n"
"\n"
"    <access origin=\"*\" />\n"
"\n"
"This is the default value for newly created CLI projects which not secured.\n"
msgstr ""
"\n"
"Cordova が付随しているのは W3C Widget Access 仕様であり、それは特定のドメイ"
"ン\n"
"へのネットワークアクセスを有効にする、アプリの config.xml file 内の "
"<access>\n"
"要素に依存しています。 Command-Line インターフェースに記述されたCLI "
"workflow \n"
"に依存しているプロジェクトのため、このファイルはプロジェクトのトップレベル\n"
"ディレクトリに配置されています。他方でプラットフォーム固有の開発パスでは、"
"場\n"
"所は次のセクションにリストされています：\n"
"\n"
"次の例はホワイトリストの構文を例示しています：\n"
"\n"
"Access to google.com:\n"
"\n"
"    <access origin=\"http://google.com\" />\n"
"\n"
"Access to the secure google.com:\n"
"\n"
"    <access origin=\"https://google.com\" />\n"
"\n"
"Access to the subdomain maps.google.com:\n"
"\n"
"    <access origin=\"http://maps.google.com\" />\n"
"\n"
"Access to all the subdomains on google.com, for example, mail.google.com and "
"docs.google.com:\n"
"\n"
"    <access origin=\"http://*.google.com\" />\n"
"\n"
"Access to all domains, for example, google.com and developer.mozilla.org:\n"
"\n"
"    <access origin=\"*\" />\n"
"\n"
"これは、保護されていない新しく作成されたCLIプロジェクトのデフォルト値です。\n"

#: vulnerabilities.py:2261
msgid "Connection to External Redis Server"
msgstr "Redis Server への外部接続"

#: vulnerabilities.py:2262
msgid "Does the application communicate with an external Redis server?"
msgstr "アプリケーションは外部の Redis サーバーと通信しますか？"

#: vulnerabilities.py:2263
msgid "The application does not communicate with an external Redis server."
msgstr "アプリケーションは外部の Redis サーバーと通信しません。"

#: vulnerabilities.py:2264
msgid ""
"\n"
"Redis framework should be used strictly in server to server\n"
"communication. Using Redis in the client side compromises security\n"
"because the credentials can be read in plain text.\n"
msgstr ""
"\n"
"<p>     Redis framework はサーバー間の通信において厳密に使用されるべきです。"
"クライアントサイドでの Redis の使用は、資格情報が平文で読まれる可能性があるた"
"め、セキュリティを侵害します。</p>\n"

#: vulnerabilities.py:2269
msgid ""
"\n"
"Android applications which use Redis to communicate are vulnerable\n"
msgstr ""
"\n"
"Redisを使用して通信するAndroidアプリケーションには脆弱性があります。\n"

#: vulnerabilities.py:2272
msgid ""
"\n"
"The database and associated data including user credentials may get\n"
"compromised.\n"
msgstr ""
"\n"
"<p>    ユーザ資格情報を含むデータベースと関連するデータは侵害される可能性があ"
"ります。 </p>\n"

#: vulnerabilities.py:2276
msgid ""
"\n"
"Remove Redis client completely. If any SDK uses this component, then\n"
"please remove the SDK itself\n"
msgstr ""
"\n"
"<p>Redis client を完全に削除してください。 もし何らかの SDK がこのコンポーネ"
"ントを使用していたら、SDK 自体を削除してください。 </p>\n"

#: vulnerabilities.py:2290
msgid "Unprotected Exported Activities"
msgstr "保護されていないエクスポートされたアクティビティ"

#: vulnerabilities.py:2291
msgid "Are any activities exported insecurely?"
msgstr "アクティビティが安全でない状態でエクスポートされていますか？"

#: vulnerabilities.py:2292
msgid "The application does not insecurely export any activities."
msgstr "アプリケーションは、アクティビティを安全にエクスポートしていません。"

#: vulnerabilities.py:2293
msgid ""
"\n"
"Activities provide user interfaces. Activities are started with Intents,\n"
"and they can return data to their invoking components upon completion.\n"
"All visible portions of applications are Activities.\n"
"\n"
"Exported Activities can be called by any other application installed in\n"
"the phone leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"<p> アクティビティーはユーザーインターフェースを提供します。アクティビティー"
"はインテントと開始され、それらはデータを完了時に呼び出しているコンポーネント"
"へ戻す可能性があります。すべてのアプリの可視部分はアクティビティーです。</p> "
"<p> エクスポートされた保護されていないアクティビティーは、電話にインストール"
"された他のアプリによって呼び出される可能性があります。それは XAS (Cross "
"Application Scripting) につながる可能性があります。</p>\n"

#: vulnerabilities.py:2301
msgid ""
"\n"
"The Android application exports Activity for use by other applications,\n"
"but does not properly restrict which applications can launch the\n"
"component or access the data it contains.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにアクティビ"
"ティをエクスポートしますが、どのアプリケーションがコンポーネントを起動した"
"り、そのコンポーネントに含まれているデータにアクセスできるかは適切に制限され"
"ません。\n"

#: vulnerabilities.py:2306 vulnerabilities.py:2358 vulnerabilities.py:2404
#: vulnerabilities.py:2447 vulnerabilities.py:2490 vulnerabilities.py:2540
#: vulnerabilities.py:2584 vulnerabilities.py:2625
msgid ""
"\n"
"Attackers may use non-privileged services to intercept and track the\n"
"user's activity. Furthermore, it may be possible to insert data that may\n"
"maliciously modify the behaviour of the application.\n"
msgstr ""
"\n"
"<p>   攻撃者は intercept とユーザの行動追跡のために、特権の無いサービスを利用"
"する可能性があります。さらに、アプリの挙動を変更する可能性があるデータの挿入"
"の可能性があります。  </p>\n"

#: vulnerabilities.py:2311
msgid ""
"\n"
"If you are using a Activity for sharing between only your own apps, it\n"
"is preferable to use the android:protectionLevel attribute set to\n"
"\"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the application when the apps accessing the\n"
"Activity are signed with the same key\n"
"\n"
"If the activity is called within itself, then don't export it or use\n"
"Intent-Filter for custom permissions\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみデータを共有するアクティビティを使用してい"
"る場合、「android：protectionLevel」属性を使用し、「署名」を保護に設定するこ"
"とをお勧めします。  署名 のパーミッションはユーザー確認を必要としないため、ア"
"クティビティにアクセスするアプリが同じ鍵で署名されている場合、より優れたユー"
"ザエクスペリエンスとサービスへのより制御されたアクセスを提供します。</p>\n"
" <p>   もしアクティビティがそれ自体の中で呼び出された時は、それをエクスポー"
"ト、あるいはカスタム権限のインテントフィルタを使用しないでください。 </p>\n"

#: vulnerabilities.py:2332
msgid "Unprotected Exported Receivers"
msgstr "保護されていないエクスポートされたレシーバ"

#: vulnerabilities.py:2333
msgid "Does the application export Broadcast Receivers?"
msgstr "アプリケーションはブロードキャストレシーバをエクスポートしますか？"

#: vulnerabilities.py:2334
msgid "The application does not export Broadcast Receivers."
msgstr "アプリケーションはブロードキャストレシーバをエクスポートしません。"

#: vulnerabilities.py:2335
msgid ""
"\n"
"Broadcast Receivers receive Intents sent to multiple applications.\n"
"Receivers are triggered by the receipt of an appropriate Intent and then\n"
"run in the background to handle the event. Receivers are typically\n"
"short-lived; they often relay messages to Activities or Services. There\n"
"are three types of broadcast Intents: normal, sticky, and ordered.\n"
"Normal broadcasts are sent to all registered Receivers at once, and then\n"
"they disappear. Ordered broadcasts are delivered to one Receiver at a\n"
"time; also, any Receiver in the delivery chain of an ordered broadcast\n"
"can stop its propagation. Broadcast Receivers have the ability to set\n"
"their priority level for receiving ordered broadcasts. Sticky broadcasts\n"
"remain accessible after they have been delivered and are re-broadcast to\n"
"future Receivers.\n"
"\n"
"Exported Broadcast Receiver can be called by any other malicious\n"
"application installed in the phone to invoke the Broadcast Receiver\n"
"leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"<p> ブロードキャストレシーバは複数のアプリへ送られたインテントを受け取りま"
"す。レシーバは適切なインテントの受取によってトリガーされ、バックグラウンドで"
"実行され、イベントをハンドルします。レシーバは通常 short-lived で、それらはし"
"ばしばメッセージをアクティビティあるいはサービスに中継します。 ブロードキャス"
"トインテントは三種類あります：normal 、sticky 、そして ordered です。 Normal "
"ブロードキャストは即時にすべての登録済み レシーバに送られ、それらは消滅しま"
"す。Ordered ブロードキャストは一度に一つのレシーバへ運ばれ、また、 ordered ブ"
"ロードキャストのデリバリーチェーン内のレシーバ はその伝達を停止する可能性があ"
"ります。ブロードキャストレシーバは ordered ブロードキャストを受け取るための優"
"先レベルの設定が可能です。 Sticky ブロードキャストはそれらが将来のレシーバ に"
"運ばれ、 再ブロードキャストされた後もアクセス可能なままです。</p> <p>エクス"
"ポートされたブロードキャストレシーバは電話内にインストールされた他の複数のア"
"プリによってブロードキャストレシーバを呼び出すために呼び出され、 XAS (Cross "
"Application Scripting) につながる可能性があります。  </p>\n"

#: vulnerabilities.py:2353
msgid ""
"\n"
"The Android application exports Receiver for use by other applications,\n"
"but does not properly restrict which applications can launch the\n"
"component or access the data it contains.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにレシーバーを"
"エクスポートしますが、どのアプリケーションがコンポーネントを起動したり、その"
"コンポーネントに含まれているデータにアクセスできるかは適切に制限されませ"
"ん。\n"

#: vulnerabilities.py:2363
msgid ""
"\n"
"If you are using a Broadcast Receiver for sharing data between only your\n"
"own apps, it is preferable to use the `android:protectionLevel` attribute\n"
"set to \"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the Broadcast Receiver when the apps accessing the\n"
"data are signed with the same key\n"
"\n"
"If the Broadcast Receiver is called within itself, then don't export it\n"
"or use Intent-Filter for custom permissions\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみデータを共有するブロードキャストレシーバを"
"使用している場合、「android：protectionLevel」属性を使用し、「署名」を保護に"
"設定することをお勧めします。  署名 のパーミッションはユーザー確認を必要としな"
"いため、データにアクセスするアプリが同じ鍵で署名されている場合、より優れた"
"ユーザエクスペリエンスとサービスへのより制御されたアクセスを提供します。</"
"p>\n"
" <p>   もしブロードキャストレシーバがそれ自体の中で呼び出された時は、それをエ"
"クスポート、あるいはカスタム権限のインテントフィルタを使用しないでください。 "
"</p>\n"

#: vulnerabilities.py:2384
msgid "Unprotected Exported Service"
msgstr "保護されていないエクスポートされたサービス"

#: vulnerabilities.py:2385
msgid "Are any services insecurely exported?"
msgstr "サービスが安全でない状態でエクスポートされていますか？"

#: vulnerabilities.py:2386
msgid "The application does not export any services insecurely."
msgstr "アプリケーションは、安全でない状態でサービスをエクスポートしません。"

#: vulnerabilities.py:2387
msgid ""
"\n"
"Services run in the background and do not interact with the user.\n"
"Downloading a file or decompressing an archive are examples of\n"
"operations that may take place in a Service. Other components can bind\n"
"to a Service, which lets the binder invoke methods that are declared in\n"
"the target Service's interface. Intents are used to start and bind to\n"
"Services\n"
"\n"
"Exported Services can be called by any other application installed in\n"
"the phone to bind into the service leading to XAS (Cross Application\n"
"Scripting)\n"
msgstr ""
"\n"
"<p> サービスはバックグラウンドで実行され、ユーザーとの対話をしません。ファイ"
"ルのダウンロードあるいはアーカイブの展開は、サービス内で起きる可能性のある操"
"作の例です。別のコンポーネントはサービスにバインドする可能性があり、それに"
"よって、ターゲットサービスインターフェース内で宣言されたメソッドをバインダー"
"に呼び出させます。 インテントはサービスをスタートとバインドするために使用され"
"ます。</p> <p> エクスポートされたサービスは、サービスにバインドするために電話"
"内にインストールされた他のアプリによって呼び出される可能性があり、それは XAS "
"(Cross Application Scripting) につながります。 </p>\n"

#: vulnerabilities.py:2399
msgid ""
"\n"
"The Android application exports Service for use by other applications,\n"
"but does not properly restrict which applications can launch the\n"
"component or access the data it contains.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにサービス\n"
"をエクスポートしますが、どのアプリケーションがコンポーネントを起動したり、そ"
"のコンポーネントに含まれているデータにアクセスできるかは適切に制限されませ"
"ん。\n"

#: vulnerabilities.py:2409
msgid ""
"\n"
"If you are using a Service for sharing data between only your own apps,\n"
"it is preferable to use the `android:protectionLevel` attribute set to\n"
"\"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the Service when the apps accessing the data are\n"
"signed with the same key\n"
"\n"
"If the Service is called within itself, then don't export it or use\n"
"Intent-Filter for custom permissions\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみデータを共有するサービスを使用している場"
"合、「android：protectionLevel」属性を使用し、「署名」を保護に設定することを"
"お勧めします。  署名 のパーミッションはユーザー確認を必要としないため、データ"
"にアクセスするアプリが同じ鍵で署名されている場合、より優れたユーザエクスペリ"
"エンスとサービスへのより制御されたアクセスを提供します。</p>\n"
" <p>   もしブロードキャストレシーバがそれ自体の中で呼び出された時は、それをエ"
"クスポート、あるいはカスタム権限のインテントフィルタを使用しないでください。 "
"</p>\n"

#: vulnerabilities.py:2430
msgid "Unprotected Exported Provider"
msgstr "保護されていないエクスポートされたプロバイダ"

#: vulnerabilities.py:2431
msgid "Are any providers insecurely exported?"
msgstr "プロバイダが安全でない状態でエクスポートされていますか？"

#: vulnerabilities.py:2432
msgid "The application does not export any providers insecurely."
msgstr "アプリケーションは、安全でない状態でプロバイダをエクスポートしません。"

#: vulnerabilities.py:2433
msgid ""
"\n"
"Content Providers are databases addressable by their application-defined\n"
"URIs. They are used for both persistent internal data storage and as a\n"
"mechanism for sharing information between applications.\n"
"\n"
"Exported Content Provider can be called by any other malicious\n"
"application installed in the phone to get the data via Content Provider\n"
"leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"<p>    コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータ"
"ベースです。 それらは持続的内部データストレージと、アプリ間情報の共有のメカニ"
"ズムとしての両方のために使用されます。 </p> <p> エクスポートされたコンテント"
"プロバイダは、コンテントプロバイダ経由でデータを取得するために、電話にインス"
"トールされた他の悪意のあるアプリによって呼び出される可能性があります。それは "
"XAS (Cross Application Scripting) につながる可能性があります。</p>\n"

#: vulnerabilities.py:2442
msgid ""
"\n"
"The Android application exports a Content Provider for use by other\n"
"applications, but does not properly restrict which applications can\n"
"launch the component or access the data it contains.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにコンテンツプ"
"ロバイダをエクスポートしますが、どのアプリケーションがコンポーネントを起動し"
"たり、そのコンポーネントに含まれているデータにアクセスできるかは適切に制限さ"
"れません。\n"

#: vulnerabilities.py:2452
msgid ""
"\n"
"If you are using a Content Provider for sharing data between only your\n"
"own apps, it is preferable to use the `android:protectionLevel` attribute\n"
"set to \"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the content provider data when the apps accessing\n"
"the data are signed with the same key\n"
"\n"
"If the Content Provider is called within itself, then don't export it or\n"
"use Intent-Filter for custom permissions\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみデータを共有するコンテントプロバイダを使用"
"している場合、「android：protectionLevel」属性を使用し、「署名」を保護に設定"
"することをお勧めします。  署名 のパーミッションはユーザー確認を必要としないた"
"め、データにアクセスするアプリが同じ鍵で署名されている場合、より優れたユーザ"
"エクスペリエンスとサービスへのより制御されたアクセスを提供します。</p>\n"
" <p>   もしコンテントプロバイダがそれ自体の中で呼び出された時は、それをエクス"
"ポート、あるいはカスタム権限のインテントフィルタを使用しないでください。 </"
"p>\n"

#: vulnerabilities.py:2473
msgid "Non-signature Protected Exported Activities"
msgstr "無署名の保護されエクスポートされたアクティビティ"

#: vulnerabilities.py:2474
msgid "Are any activities exported without a ProtectionLevel?"
msgstr "ProtectionLevelなしでエクスポートされたアクティビティはありますか？"

#: vulnerabilities.py:2475
msgid "The application does not export any activity without a ProtectionLevel."
msgstr ""
"アプリケーションはProtectionLevelなしでアクティビティをエクスポートしません。"

#: vulnerabilities.py:2476
msgid ""
"\n"
"Activities provide user interfaces. Activities are started with Intents,\n"
"and they can return data to their invoking components upon completion.\n"
"All visible portions of applications are Activities.\n"
"\n"
"Exported Unprotected Activities can be called by any other application\n"
"installed in the phone leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"アクティビティはユーザーインターフェイスを提供します。 アクティビティはインテ"
"ントで開始され、完了時に呼び出し元のコンポーネントにデータを返すことができま"
"す。アプリケーションのすべての可視部分はアクティビティです。\n"
"\n"
"エクスポートされた保護されていないアクティビティは、電話機にインストールされ"
"ている他のアプリケーションから呼び出すことができるため、XAS（クロスアプリケー"
"ションスクリプティング）を引き起こす可能性があります。\n"

#: vulnerabilities.py:2484
msgid ""
"\n"
"The Android application exports Activity for use by other applications,\n"
"but does not properly restrict which applications can launch the\n"
"component or access the data it contains via custom signature defined by\n"
"`android:protectionLevel`.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにアクティビ"
"ティをエクスポートしますが、どのアプリケーションがコンポーネントを起動した"
"り、そのコンポーネントに含まれているデータに `android：protectionLevel`で定義"
"されたカスタムシグネチャでアクセスできるかを適切に制限しません。\n"

#: vulnerabilities.py:2495
msgid ""
"\n"
"If you are using a Activity for sharing between only your own apps, it\n"
"is preferable to use the `android:protectionLevel` attribute set to\n"
"\"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the application when the apps accessing the\n"
"Activity are signed with the same key\n"
msgstr ""
"\n"
"<p>  もし自分のアプリ間のみで共有のためにアクティビティを使用しているな"
"ら、\"signature\" 保護にセットされた android: 保護レベル属性の使用が好ましい"
"です。  Signature アクセス許可はユーザー確認を要求しないため、それらはより良"
"いユーザー体験と、アクティビティにアクセスするアプリが同じキーでサインされた"
"時にさらに制御されたアプリへのアクセスを提供します。</p> \n"

#: vulnerabilities.py:2513
msgid "Non-signature Protected Exported Receivers"
msgstr "無署名の保護されたエクスポートレシーバ"

#: vulnerabilities.py:2514
msgid "Are any Broadcast Receivers exported without a ProtectionLevel?"
msgstr ""
"ProtectionLevel なしでブロードキャストレシーバがエクスポートされていますか？"

#: vulnerabilities.py:2515
msgid ""
"The application does not export any Broadcast Receivers without a "
"ProtectionLevel."
msgstr ""
"アプリケーションは ProtectionLevel なしでブロードキャストレシーバーをエクス"
"ポートしません。"

#: vulnerabilities.py:2516
msgid ""
"\n"
"Broadcast Receivers receive Intents sent to multiple applications.\n"
"Receivers are triggered by the receipt of an appropriate Intent and then\n"
"run in the background to handle the event. Receivers are typically\n"
"short-lived; they often relay messages to Activities or Services. There\n"
"are three types of broadcast Intents: normal, sticky, and ordered.\n"
"Normal broadcasts are sent to all registered Receivers at once, and then\n"
"they disappear. Ordered broadcasts are delivered to one Receiver at a\n"
"time; also, any Receiver in the delivery chain of an ordered broadcast\n"
"can stop its propagation. Broadcast Receivers have the ability to set\n"
"their priority level for receiving ordered broadcasts. Sticky broadcasts\n"
"remain accessible after they have been delivered and are re-broadcast to\n"
"future Receivers.\n"
"\n"
"Exported Unprotected Broadcast Receiver can be called by any other\n"
"malicious application installed in the phone to invoke the Broadcast\n"
"Receiver leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"<p> ブロードキャストレシーバは複数のアプリに送られたインテントを受け取りま"
"す。 レシーバは適切なインテントの受取がトリガーとなり、イベントのハンドルのた"
"めにバックグラウンドで実行されます。レシーバは一般的に short-lived であり、そ"
"れらは頻繁にメッセージをアクティビティあるいはサービスに伝えます。 ブロード"
"キャストインテントには normal、 sticky、 ordered の３種類があります。 Normal "
"ブロードキャストはすべての登録済みレシーバへ一度に送られ、それから消滅しま"
"す。Ordered ブロードキャストは一度に一つのレシーバへ運ばれ、また、 ordered ブ"
"ロードキャストのデリバリーチェーン内のレシーバ はその伝達を停止する可能性があ"
"ります。ブロードキャストレシーバは ordered ブロードキャストを受け取るための優"
"先レベルの設定が可能です。 Sticky ブロードキャストはそれらが将来のレシーバ に"
"運ばれ、 再ブロードキャストされた後もアクセス可能なままです。</p> <p>エクス"
"ポートされたブロードキャストレシーバは電話内にインストールされた他の複数の悪"
"意のあるアプリによってブロードキャストレシーバを呼び出すために呼び出され、 "
"XAS (Cross Application Scripting) につながる可能性があります。 </p>\n"

#: vulnerabilities.py:2534
msgid ""
"\n"
"The Android application exports Broadcast Receiver for use by other\n"
"applications, but does not properly restrict which applications can\n"
"launch the component or access the data it containscustom signature\n"
"defined by `android:protectionLevel`.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにブロードキャ"
"ストレシーバーをエクスポートしますが、どのアプリケーションがコンポーネントを"
"起動したり、そのコンポーネントに含まれているデータに `android："
"protectionLevel`で定義されたカスタムシグネチャでアクセスできるかを適切に制限"
"しません。\n"

#: vulnerabilities.py:2545
msgid ""
"\n"
"If you are using a Broadcast Receiver for sharing data between only your\n"
"own apps, it is preferable to use the `android:protectionLevel` attribute\n"
"set to \"signature\" protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the Broadcast Receiver when the apps accessing the\n"
"data are signed with the same key\n"
msgstr ""
"\n"
"自分のアプリケーション間だけでデータを共有するためにブロードキャストレシーバ"
"を使用している場合は、「android：protectionLevel」属性を使用することをお勧め"
"します。\n"
"署名のパーミッションはユーザの確認を必要としないため、データにアクセスするア"
"プリケーションが同じ鍵で署名されている場合、より良いユーザエクスペリエンスと"
"ブロードキャストレシーバへのアクセスがより制御されたものになります。\n"

#: vulnerabilities.py:2563
msgid "Non-signature Protected Exported Services"
msgstr "署名されていない保護されたエクスポートされたサービス"

#: vulnerabilities.py:2564
msgid "Are any services exported without a ProtectionLevel?"
msgstr "ProtectionLevelなしでエクスポートされるサービスはありますか？"

#: vulnerabilities.py:2565
msgid "The application does not export any service without a ProtectionLevel."
msgstr ""
"アプリケーションはProtectionLevelなしではサービスをエクスポートしません。"

#: vulnerabilities.py:2566
msgid ""
"\n"
"Services run in the background and do not interact with the user.\n"
"Downloading a file or decompressing an archive are examples of\n"
"operations that may take place in a Service. Other components can bind\n"
"to a Service, which lets the binder invoke methods that are declared in\n"
"the target Service's interface. Intents are used to start and bind to\n"
"Services\n"
"\n"
"Exported Unprotected Services can be called by any other application\n"
"installed in the phone to bind into the service leading to XAS (Cross\n"
"Application Scripting)\n"
msgstr ""
"\n"
"<p> サービスはバックグラウンドで実行され、ユーザーとの対話をしません。ファイ"
"ルのダウンロードあるいはアーカイブの展開は、サービス内で起きる可能性のある操"
"作の例です。 別のコンポーネントはサービスにバインドする可能性があり、それに"
"よって、ターゲットサービスインターフェース内で宣言されたメソッドをバインダー"
"に呼び出させます。 インテントはサービスをスタートとバインドするために使用され"
"ます。 </p> <p> エクスポートされた保護されていないサービスは、サービスにバイ"
"ンドするために電話内にインストールされた他のアプリによって呼び出される可能性"
"があり、それは XAS (Cross Application Scripting) につながります。  </p>\n"

#: vulnerabilities.py:2578
msgid ""
"\n"
"The Android application exports Service for use by other applications,\n"
"but does not properly restrict which applications can launch the\n"
"component or access the data it containscustom signature defined by\n"
"`android:protectionLevel`.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにサービスをエ"
"クスポートしますが、どのアプリケーションがコンポーネントを起動したり、そのコ"
"ンポーネントに含まれているデータに `android：protectionLevel`で定義されたカス"
"タムシグネチャでアクセスできるかを適切に制限しません。\n"

#: vulnerabilities.py:2589
msgid ""
"\n"
"If you are using a Service for sharing data between only your own apps,\n"
"it is preferable to use the `android:protectionLevel` attribute set to\n"
"`signature` protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the Service when the apps accessing the data are\n"
"signed with the same key\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみデータを共有するサービスを使用している場"
"合、「android：protectionLevel」属性を使用し、「署名」を保護に設定することを"
"お勧めします。  署名 のパーミッションはユーザー確認を必要としないため、データ"
"にアクセスするアプリが同じ鍵で署名されている場合、より優れたユーザエクスペリ"
"エンスとサービスへのより制御されたアクセスを提供します。</p>\n"
" <p>   もしブロードキャストレシーバがそれ自体の中で呼び出された時は、それをエ"
"クスポート、あるいはカスタム権限のインテントフィルタを使用しないでください。 "
"</p> \n"

#: vulnerabilities.py:2607
msgid "Non-signature Protected Exported Providers"
msgstr "無署名の保護されエクスポートされたプロバイダ"

#: vulnerabilities.py:2608
msgid "Are any providers exported without a ProtectionLevel?"
msgstr "ProtectionLevelなしで輸出されたプロバイダはありますか？"

#: vulnerabilities.py:2609
msgid "The application does not export any provider without a ProtectionLevel."
msgstr ""
"アプリケーションはProtectionLevelなしでプロバイダをエクスポートしません。"

#: vulnerabilities.py:2610
msgid ""
"\n"
"Content Providers are databases addressable by their application-defined\n"
"URIs. They are used for both persistent internal data storage and as a\n"
"mechanism for sharing information between applications.\n"
"\n"
"Exported and Unprotected Content Provider can be called by any other\n"
"malicious application installed in the phone to get the data via Content\n"
"Provider leading to XAS (Cross Application Scripting)\n"
msgstr ""
"\n"
"<p>     コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータ"
"ベースです。それらは持続的内部データストレージと、アプリ間情報の共有のメカニ"
"ズムとしての両方のために使用されます。</p> <p>  エクスポートされた保護されて"
"いないコンテントプロバイダは、コンテントプロバイダ経由でデータを取得するため"
"に、電話にインストールされた他の悪意のあるアプリによって呼び出される可能性が"
"あります。それは XAS (Cross Application Scripting) につながる可能性がありま"
"す。 </p>\n"

#: vulnerabilities.py:2619
msgid ""
"\n"
"The Android application exports Content Provider for use by other\n"
"applications, but does not properly restrict which applications can\n"
"launch the component or access the data it containscustom signature\n"
"defined by `android:protectionLevel`.\n"
msgstr ""
"\n"
"Android アプリケーションは、他のアプリケーションで使用するためにコンテンツプ"
"ロバイダをエクスポートしますが、どのアプリケーションがコンポーネントを起動し"
"たり、そのコンポーネントに含まれているデータに `android：protectionLevel`で定"
"義されたカスタムシグネチャでアクセスできるかを適切に制限しません。\n"

#: vulnerabilities.py:2630
msgid ""
"\n"
"If you are using a Content Provider for sharing data between only your\n"
"own apps, it is preferable to use the `android:protectionLevel` attribute\n"
"set to `signature` protection. Signature permissions do not require user\n"
"confirmation, so they provide a better user experience and more\n"
"controlled access to the content provider data when the apps accessing\n"
"the data are signed with the same key\n"
msgstr ""
"\n"
"<p> 自分のアプリケーション間でのみコンテントプロバイダを共有するサービスを使"
"用している場合、「android：protectionLevel」属性を使用し、「署名」を保護に設"
"定することをお勧めします。  署名 のパーミッションはユーザー確認を必要としない"
"ため、データにアクセスするアプリが同じ鍵で署名されている場合、より優れたユー"
"ザエクスペリエンスとサービスへのより制御されたアクセスを提供します。</p>\n"
" <p>   もしコンテントプロバイダがそれ自体の中で呼び出された時は、それをエクス"
"ポート、あるいはカスタム権限のインテントフィルタを使用しないでください。 </"
"p>\n"

#: vulnerabilities.py:2648
msgid "Content Provider File Traversal Vulnerability"
msgstr "コンテンツプロバイダーのファイルトラバーサルの脆弱性"

#: vulnerabilities.py:2649
msgid ""
"Is the application vulnerable to content provider directory traversal "
"attacks?"
msgstr ""
"アプリケーションはコンテンツプロバイダのディレクトリトラバーサル攻撃に対して"
"脆弱ですか？"

#: vulnerabilities.py:2650
msgid ""
"Application does not seem to be vulnerable to content provider directory "
"traversal attacks."
msgstr ""
"アプリケーションは、コンテンツプロバイダのディレクトリトラバーサル攻撃に対し"
"て脆弱ではないようです。"

#: vulnerabilities.py:2651
msgid ""
"\n"
"Content Providers are databases addressable by their application-defined\n"
"URIs. They are used for both persistent internal data storage and as a\n"
"mechanism for sharing information between applications.\n"
"\n"
"By using the `ContentProvider.openFile()` method, you can provide a\n"
"facility for another application to access your application data (file).\n"
"Depending on the implementation of ContentProvider, use of the method\n"
"can lead to a directory traversal vulnerability. Hence, when exchanging\n"
"a file through a content provider, the path should be canonicalized\n"
"before it is used.\n"
msgstr ""
"\n"
"<p>コンテントプロバイダは、アプリ定義の URI によるアドレス可能なデータベース"
"です。それらは持続的内部データストレージと、アプリ間情報の共有のメカニズムと"
"しての両方のために使用されます。</p> <p> \t ContentProvider.openFile() メソッ"
"ドを使用することによって、あなたのアプリのデータ(ファイル)にアクセスする、あ"
"る別のアプリのためのファシリティを提供します。コンテントプロバイダの実装に"
"よって、メソッドの利用がディレクトリトラバーサルの脆弱性につながる可能性があ"
"ります。従って、　コンテントプロバイダを通してのファイルを交換する時、パスは"
"使用前に正規化されるべきです。 </p>\n"

#: vulnerabilities.py:2663
msgid ""
"\n"
"Depending on the implementation of `ContentProvider`, use of the method\n"
"can lead to a directory traversal vulnerability.\n"
msgstr ""
"\n"
"コンテンツプロバイダの実装に応じて、このメソッドの使用がディレクトリトラバー"
"サルの脆弱性につながる可能性があります。\n"

#: vulnerabilities.py:2667
msgid ""
"\n"
"Directory Traversal exploits allow attackers to escape the context of\n"
"the sandboxed application and read/write local files compromising the\n"
"application/device.\n"
msgstr ""
"\n"
"<p>ディレクトリトラバーサル脆弱性は攻撃者にサンドボックスアプリのコンテキスト"
"のエスケープを許し、アプリ·デバイスを構成するローカルファイルの読み書きを許す"
"可能性があります。</p>\n"

#: vulnerabilities.py:2672
msgid ""
"\n"
"By using the canonicalized path, directory traversal will be mitigated\n"
"even when a doubly-encoded path is supplied.\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        String decodedUriString = Uri.decode(paramUri.toString());\n"
"        File file = new File(IMAGE_DIRECTORY, Uri.parse(decodedUriString)."
"getLastPathSegment());\n"
"        if (file.getCanonicalPath().indexOf(localFile.getCanonicalPath()) != "
"0) {\n"
"            throw new IllegalArgumentException();\n"
"        }\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"
"For example, the following double encoded string will circumvent the fix.\n"
"\n"
"    %252E%252E%252F%252E%252E%252F%252E%252E%252Fdata%252Fdata%252Fcom."
"example.android.app%252Fshared_prefs%252FExample.xml\n"
"\n"
"The first call of `Uri.getLastPathSegment()` will decode \"%25\" to \"%\"\n"
"and return the string:\n"
"\n"
"    %2E%2E%2F%2E%2E%2F%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app"
"%2Fshared_prefs%2FExample.xml\n"
"\n"
"When this string is passed to the second `Uri.getLastPathSegment()`, \"%2E"
"\"\n"
"and \"%2F\" will be decoded and the result will be:\n"
"\n"
"    ../../../data/data/com.example.android.app/shared_prefs/Example.xml\n"
"\n"
msgstr ""
"\n"
"\"正規化されたパスの使用によって、二重エンコードされたパスが与えられたときで"
"さえ、ディレクトリトラバーサルは軽減されるでしょう。\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        String decodedUriString = Uri.decode(paramUri.toString());\n"
"        File file = new File(IMAGE_DIRECTORY, Uri.parse(decodedUriString)."
"getLastPathSegment());\n"
"        if (file.getCanonicalPath().indexOf(localFile.getCanonicalPath()) != "
"0) {\n"
"            throw new IllegalArgumentException();\n"
"        }\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"
"For example, the following double encoded string will circumvent the fix.\n"
"\n"
"    %252E%252E%252F%252E%252E%252F%252E%252E%252Fdata%252Fdata%252Fcom."
"example.android.app%252Fshared_prefs%252FExample.xml\n"
"\n"
"The first call of `Uri.getLastPathSegment()` will decode \"%25\" to \"%\"\n"
"and return the string:\n"
"\n"
"    %2E%2E%2F%2E%2E%2F%2E%2E%2Fdata%2Fdata%2Fcom.example.android.app"
"%2Fshared_prefs%2FExample.xml\n"
"\n"
"When this string is passed to the second `Uri.getLastPathSegment()`, \"%2E"
"\"\n"
"and \"%2F\" will be decoded and the result will be:\n"
"\n"
"    ../../../data/data/com.example.android.app/shared_prefs/Example.xml\n"
"\n"

#: vulnerabilities.py:2701
msgid ""
"\n"
"This non-compliant code example tries to retrieve the last segment from\n"
"the path paramUri, which is supposed to denote a file name, by calling\n"
"`android.net.Uri.getLastPathSegment()`. The file is accessed in the\n"
"pre-configured parent directory IMAGE\\_DIRECTORY.\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        File file = new File(IMAGE_DIRECTORY, paramUri."
"getLastPathSegment());\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"
"This non-compliant code example attempts to fix the first non-compliant\n"
"code example by calling `Uri.getLastPathSegment()` twice. The first call\n"
"is intended for URL decoding and the second call is to obtain the string\n"
"the developer wanted.\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        File file = new File(IMAGE_DIRECTORY, Uri.parse(paramUri."
"getLastPathSegment()).getLastPathSegment());\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"
msgstr ""
"\n"
"この非順守コード例は最後のセグメントを、 android.net.Uri."
"getLastPathSegment() を呼び出すことによって、ファイル名を示すことになってい"
"る paramUri パスから取り戻そうとしています。そのファイルは事前構成済みの親"
"ディレクトリ IMAGE_DIRECTORY 内でアクセスされます。\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        File file = new File(IMAGE_DIRECTORY, paramUri."
"getLastPathSegment());\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"
"この規格に準拠していないコード例は、 `Uri.getLastPathSegment（）`を2回呼び出"
"すことで、最初の非準拠のコード例を修正しようとしています。最初の呼び出しはURL"
"デコードを意図しており、2番目の呼び出しは開発者が望む文字列を取得することで"
"す。\n"
"\n"
"    private static String IMAGE_DIRECTORY = localFile.getAbsolutePath();\n"
"    public ParcelFileDescriptor openFile(Uri paramUri, String paramString) "
"throws FileNotFoundException {\n"
"        File file = new File(IMAGE_DIRECTORY, Uri.parse(paramUri."
"getLastPathSegment()).getLastPathSegment());\n"
"        return ParcelFileDescriptor.open(file, ParcelFileDescriptor."
"MODE_READ_ONLY);\n"
"    }\n"
"\n"

#: vulnerabilities.py:2725
msgid ""
"\n"
"- [JVN\\#78601526 GREE for Android vulnerable to directory traversal]"
"(https://www.securecoding.cert.org/confluence/display/android/DRD08-J.+Always"
"+canonicalize+a+URL+received+by+a+content+provider)\n"
"\n"
msgstr ""
"\n"
"- [JVN\\#78601526](https://www.securecoding.cert.org/confluence/display/"
"android/DRD08-J.+Always+canonicalize+a+URL+received+by+a+content+provider) "
"GREE for Android ディレクトリトラバーサルに対する脆弱性\n"

#: vulnerabilities.py:2737
msgid "Insecure Cryptographic Keys"
msgstr "安全でない暗号鍵"

#: vulnerabilities.py:2738
msgid ""
"Does the application use insecure encryption algorithms or configurations?"
msgstr ""
"アプリケーションは安全ではない暗号化アルゴリズムあるいは構成を使用していませ"
"んか？"

#: vulnerabilities.py:2739
msgid ""
"The application does not use insecure encryption algorithms or "
"configurations."
msgstr ""
"アプリケーションは、安全ではない暗号化アルゴリズムまたは構成を使用しません。"

#: vulnerabilities.py:2740
msgid ""
"\n"
"Using the CCCryptor, one can use common sounding functions such as\n"
"`CCCryptorCreate`, `CCCryptorUpdate`, `CCCryptorFinal` (or simply "
"`CCCrypt()`\n"
"one-shot function) to perform symmetric encryption using different\n"
"algorithms like AES, 3DES and hardcore security ciphers like RC4, DES,\n"
"etc.\n"
"\n"
"Apple supports ECB and CBC mode for their ciphers, and fortunately a\n"
"developer really needs to explicitly prove stupidity by using ECB since\n"
"APIs default to CBC, the Cipher Block Chaining mode. What could possibly\n"
"go wrong? Right, there is some minor thing that is called the \"IV\".\n"
"Apple supposedly translated the acronym IV to \"Ignorance Vector\" when\n"
"writing their Common Crypto API man-pages, but we should read\n"
"\"Initialization Vector\" - used to initialize the very first block of\n"
"cipher text.\n"
msgstr ""
"\n"
"<p>   CCCryptor の使用で、 AES, 3DES のような異なるアルゴリズムと RC4, DES な"
"どのようなハードコアセキュリティサイファーを使用して対称的な暗号化を実行する"
"ための CCCryptorCreate, CCCryptorUpdate, CCCryptorFinal (あるいは単に "
"CCCrypt() one-shot 機能) のような共通範囲の機能を使用することが出来ます。    "
"</p><p>Appleは暗号をECBとCBCモードでサポートしています。幸運にも、開発者はAPI"
"がCBC（Cipher Block Chainingモード）にデフォルト設定されているので、ECBを使っ"
"て明白に間違いを証明する必要があります。\n"
"おそらく「IV」と呼ばれるものがうまくいかないでしょう。\n"
"AppleはCommon Crypto APIのマニュアルページを書くときに頭字語「IV」を "
"\"Ignorance Vector\"に翻訳したと思われますが、実際には最初の暗号テキストブ"
"ロックの初期化に使用する \"Initialization Vector\"を読むべきです。 </p>\n"

#: vulnerabilities.py:2756
msgid ""
"\n"
"Application seems to be using the correct cryptographic encryption\n"
"method, or is not using it.\n"
msgstr ""
"\n"
"アプリケーションは正しい暗号化メソッドを使用しているか、あるいはまったく使用"
"していないようです。\n"

#: vulnerabilities.py:2760
msgid ""
"\n"
"Using an insecure initialization vector allows the attacker to perform\n"
"frequency analysis on the ciphertext. An all-zero IV would mean that the\n"
"initial portion of ciphertext is effectively just substition.\n"
msgstr ""
"\n"
"<p>    セキュリティで保護されていない初期化ベクターの利用は、攻撃者に "
"ciphertext 上で周波数分析の実行を許す可能性があります。 all-zero IV は "
"ciphertext の initial portion が効果的な代用であることを意味しています。 </"
"p>\n"

#: vulnerabilities.py:2765
msgid ""
"\n"
"The mystical initialization vector (IV) is confusing. In CBC-mode, each\n"
"16-byte encryption influences the next 16-byte encryption. It's also the\n"
"default. The problem is about block 0. It is a random block -1 which is\n"
"the IV.\n"
"\n"
"This is listed as optional in `CCCrypt()` which is confusing because it\n"
"isn't really optional in CBC mode. If it is not provided, then it'll\n"
"automatically generate an all-0 IV. That throws away significant\n"
"protection on the first block. IV is just 16 random bytes.\n"
"\n"
"The method returns the encrypted data (nil for error), and returns the\n"
"IV, salt and error by reference.\n"
"\n"
"    NSData *iv;\n"
"    NSData *salt;\n"
"    NSError *error;\n"
"    NSData *encryptedData = [RNCryptManager encryptedDataForData:"
"plaintextData\n"
"                                                        password:password\n"
"                                                              iv:&iv\n"
"                                                            salt:&salt\n"
"                                                           error:&error];\n"
"\n"
"Example implementation\n"
"\n"
"    #import <CommonCrypto/CommonCryptor.h>\n"
"    #import <CommonCrypto/CommonKeyDerivation.h>\n"
"\n"
"    NSString * const\n"
"    kRNCryptManagerErrorDomain = @\"net.robnapier.RNCryptManager\";\n"
"\n"
"    const CCAlgorithm kAlgorithm = kCCAlgorithmAES128;\n"
"    const NSUInteger kAlgorithmKeySize = kCCKeySizeAES128;\n"
"    const NSUInteger kAlgorithmBlockSize = kCCBlockSizeAES128;\n"
"    const NSUInteger kAlgorithmIVSize = kCCBlockSizeAES128;\n"
"    const NSUInteger kPBKDFSaltSize = 8;\n"
"    const NSUInteger kPBKDFRounds = 10000;  // ~80ms on an iPhone 4\n"
"\n"
"    + (NSData *)encryptedDataForData:(NSData *)data\n"
"                            password:(NSString *)password\n"
"                                  iv:(NSData )iv\n"
"                                salt:(NSData )salt\n"
"                               error:(NSError )error {\n"
"      NSAssert(iv, @\"IV must not be NULL\");\n"
"      NSAssert(salt, @\"salt must not be NULL\");\n"
"\n"
"      *iv = [self randomDataOfLength:kAlgorithmIVSize];\n"
"      *salt = [self randomDataOfLength:kPBKDFSaltSize];\n"
"\n"
"      NSData *key = [self AESKeyForPassword:password salt:*salt];\n"
"\n"
"      size_t outLength;\n"
"      NSMutableData *\n"
"      cipherData = [NSMutableData dataWithLength:data.length +\n"
"                    kAlgorithmBlockSize];\n"
"\n"
"      CCCryptorStatus\n"
"      result = CCCrypt(kCCEncrypt, // operation\n"
"                       kAlgorithm, // Algorithm\n"
"                       kCCOptionPKCS7Padding, // options\n"
"                       key.bytes, // key\n"
"                       key.length, // keylength\n"
"                       (*iv).bytes,// iv\n"
"                       data.bytes, // dataIn\n"
"                       data.length, // dataInLength,\n"
"                       cipherData.mutableBytes, // dataOut\n"
"                       cipherData.length, // dataOutAvailable\n"
"                       &outLength); // dataOutMoved\n"
"\n"
"      if (result == kCCSuccess) {\n"
"        cipherData.length = outLength;\n"
"      }\n"
"      else {\n"
"        if (error) {\n"
"          *error = [NSError errorWithDomain:kRNCryptManagerErrorDomain\n"
"                                       code:result\n"
"                                   userInfo:nil];\n"
"        }\n"
"        return nil;\n"
"      }\n"
"\n"
"      return cipherData;\n"
"    }\n"
"\n"
"    + (NSData *)randomDataOfLength:(size_t)length {\n"
"      NSMutableData *data = [NSMutableData dataWithLength:length];\n"
"\n"
"      int result = SecRandomCopyBytes(kSecRandomDefault,\n"
"                                      length,\n"
"                                      data.mutableBytes);\n"
"      NSAssert(result == 0, @\"Unable to generate random bytes: %\n"
"                d\", errno);\n"
"\n"
"      return data;\n"
"    }\n"
"\n"
"    // Replace this with a 10,000 hash calls if you don't have "
"CCKeyDerivationPBKDF\n"
"    + (NSData *)AESKeyForPassword:(NSString *)password\n"
"                             salt:(NSData *)salt {\n"
"      NSMutableData *\n"
"      derivedKey = [NSMutableData dataWithLength:kAlgorithmKeySize];\n"
"\n"
"      int\n"
"      result = CCKeyDerivationPBKDF(kCCPBKDF2,            // algorithm\n"
"                                    password.UTF8String,  // password\n"
"                                    [password lengthOfBytesUsingEncoding:"
"NSUTF8StringEncoding],  // passwordLength\n"
"                                    salt.bytes,           // salt\n"
"                                    salt.length,          // saltLen\n"
"                                    kCCPRFHmacAlgSHA1,    // PRF\n"
"                                    kPBKDFRounds,         // rounds\n"
"                                    derivedKey.mutableBytes, // derivedKey\n"
"                                    derivedKey.length); // derivedKeyLen\n"
"\n"
"      // Do not log password here\n"
"      NSAssert(result == kCCSuccess, @\"Unable to create AES key for "
"password: %\n"
"               d\", result);\n"
"\n"
"      return derivedKey;\n"
"    }\n"
"\n"
msgstr ""
"\n"
"initialization vector (IV) は紛らわしい存在です。\n"
"CBCモードでは、各16バイトの暗号化が次の16バイト暗号化に影響し、 これもデフォ"
"ルトです。\n"
"問題はブロック0についてです。これはIVであるランダムブロック-1です。\n"
"これは `CCCrypt（）`にオプションとしてリストされていますが、CBCモードでは実際"
"にはオプションではないので混乱が生じます。\n"
"提供されていない場合、自動的にall-0 IVが生成されます。 それは最初のブロックに"
"大きな保護を捨てます。 IVはちょうど16のランダムバイトです。\n"
"このメソッドは、暗号化されたデータ（エラーの場合はnil）を返し、参照によって"
"IV、ソルト、およびエラーを返します。\n"
"\n"
"    NSData *iv;\n"
"    NSData *salt;\n"
"    NSError *error;\n"
"    NSData *encryptedData = [RNCryptManager encryptedDataForData:"
"plaintextData\n"
"                                                        password:password\n"
"                                                              iv:&iv\n"
"                                                            salt:&salt\n"
"                                                           error:&error];\n"
"\n"
"Example implementation\n"
"\n"
"    #import <CommonCrypto/CommonCryptor.h>\n"
"    #import <CommonCrypto/CommonKeyDerivation.h>\n"
"\n"
"    NSString * const\n"
"    kRNCryptManagerErrorDomain = @\"net.robnapier.RNCryptManager\";\n"
"\n"
"    const CCAlgorithm kAlgorithm = kCCAlgorithmAES128;\n"
"    const NSUInteger kAlgorithmKeySize = kCCKeySizeAES128;\n"
"    const NSUInteger kAlgorithmBlockSize = kCCBlockSizeAES128;\n"
"    const NSUInteger kAlgorithmIVSize = kCCBlockSizeAES128;\n"
"    const NSUInteger kPBKDFSaltSize = 8;\n"
"    const NSUInteger kPBKDFRounds = 10000;  // ~80ms on an iPhone 4\n"
"\n"
"    + (NSData *)encryptedDataForData:(NSData *)data\n"
"                            password:(NSString *)password\n"
"                                  iv:(NSData )iv\n"
"                                salt:(NSData )salt\n"
"                               error:(NSError )error {\n"
"      NSAssert(iv, @\"IV must not be NULL\");\n"
"      NSAssert(salt, @\"salt must not be NULL\");\n"
"\n"
"      *iv = [self randomDataOfLength:kAlgorithmIVSize];\n"
"      *salt = [self randomDataOfLength:kPBKDFSaltSize];\n"
"\n"
"      NSData *key = [self AESKeyForPassword:password salt:*salt];\n"
"\n"
"      size_t outLength;\n"
"      NSMutableData *\n"
"      cipherData = [NSMutableData dataWithLength:data.length +\n"
"                    kAlgorithmBlockSize];\n"
"\n"
"      CCCryptorStatus\n"
"      result = CCCrypt(kCCEncrypt, // operation\n"
"                       kAlgorithm, // Algorithm\n"
"                       kCCOptionPKCS7Padding, // options\n"
"                       key.bytes, // key\n"
"                       key.length, // keylength\n"
"                       (*iv).bytes,// iv\n"
"                       data.bytes, // dataIn\n"
"                       data.length, // dataInLength,\n"
"                       cipherData.mutableBytes, // dataOut\n"
"                       cipherData.length, // dataOutAvailable\n"
"                       &outLength); // dataOutMoved\n"
"\n"
"      if (result == kCCSuccess) {\n"
"        cipherData.length = outLength;\n"
"      }\n"
"      else {\n"
"        if (error) {\n"
"          *error = [NSError errorWithDomain:kRNCryptManagerErrorDomain\n"
"                                       code:result\n"
"                                   userInfo:nil];\n"
"        }\n"
"        return nil;\n"
"      }\n"
"\n"
"      return cipherData;\n"
"    }\n"
"\n"
"    + (NSData *)randomDataOfLength:(size_t)length {\n"
"      NSMutableData *data = [NSMutableData dataWithLength:length];\n"
"\n"
"      int result = SecRandomCopyBytes(kSecRandomDefault,\n"
"                                      length,\n"
"                                      data.mutableBytes);\n"
"      NSAssert(result == 0, @\"Unable to generate random bytes: %d\",\n"
"               errno);\n"
"\n"
"      return data;\n"
"    }\n"
"\n"
"    // Replace this with a 10,000 hash calls if you don't have "
"CCKeyDerivationPBKDF\n"
"    + (NSData *)AESKeyForPassword:(NSString *)password\n"
"                             salt:(NSData *)salt {\n"
"      NSMutableData *\n"
"      derivedKey = [NSMutableData dataWithLength:kAlgorithmKeySize];\n"
"\n"
"      int\n"
"      result = CCKeyDerivationPBKDF(kCCPBKDF2,            // algorithm\n"
"                                    password.UTF8String,  // password\n"
"                                    [password lengthOfBytesUsingEncoding:"
"NSUTF8StringEncoding],  // passwordLength\n"
"                                    salt.bytes,           // salt\n"
"                                    salt.length,          // saltLen\n"
"                                    kCCPRFHmacAlgSHA1,    // PRF\n"
"                                    kPBKDFRounds,         // rounds\n"
"                                    derivedKey.mutableBytes, // derivedKey\n"
"                                    derivedKey.length); // derivedKeyLen\n"
"\n"
"      // Do not log password here\n"
"      NSAssert(result == kCCSuccess,\n"
"               @\"Unable to create AES key for password: %d\", result);\n"
"\n"
"      return derivedKey;\n"
"    }\n"
"\n"

#: vulnerabilities.py:2896
msgid "iOS SecKeyEncrypt implementation"
msgstr "iOS SecKeyEncryptの実装"

#: vulnerabilities.py:2897
msgid "Does the application use proper SecKeyEncrypt implementation?"
msgstr "アプリケーションは適切な SecKeyEncrypt 実装を使用していますか？"

#: vulnerabilities.py:2898
msgid ""
"The application uses proper SecKeyEncrypt, or SecKeyEncrypt is not "
"implemented."
msgstr ""
"アプリケーションが適切なSecKeyEncryptを使用するか、SecKeyEncryptが実装されて"
"いません。"

#: vulnerabilities.py:2899
msgid ""
"\n"
"Most of the time iOS handles all the encryption. It automatically\n"
"encrypts and decrypts HTTPS for network traffic and manages encrypted\n"
"files using file protection.\n"
"\n"
"But in case of custom implementation `SecKeyEncrypt` and `SecKeyDecrypt` is\n"
"called\n"
msgstr ""
"\n"
"ほとんどの場合、iOSはすべての暗号化を処理します。ネットワークトラフィックのた"
"めに自動的にHTTPSを暗号化および復号化し、ファイル保護を使用して暗号化された"
"ファイルを管理します。しかし、カスタム実装の場合、 `SecKeyEncrypt`と` "
"SecKeyDecrypt`が呼び出されます。\n"

#: vulnerabilities.py:2907
msgid ""
"\n"
"`SecKeyEncrypt` determines how to encrypt data from a PUBLIC KEY in iOS\n"
msgstr ""
"\n"
"SecKeyEncryptは、iOSの公開鍵からデータを暗号化する方法を決定します。\n"

#: vulnerabilities.py:2922
msgid "Insecure Peer Connections"
msgstr "安全でないピア接続"

#: vulnerabilities.py:2923
msgid ""
"Does the application securely communicate with other devices over MultiPeer "
"Framework?"
msgstr ""
"アプリケーションは他のデバイスと MultiPeer Framework で安全に通信しています"
"か？"

#: vulnerabilities.py:2924
msgid ""
"The application uses MultiPeer Framework properly, or MultiPeer Framework is "
"not being used."
msgstr ""
"アプリケーションでMultiPeer Frameworkが正しく使用されているか、MultiPeer "
"Frameworkが使用されていません。"

#: vulnerabilities.py:2925
msgid ""
"\n"
"Multi-peer Connectivity Framework makes the task of exchanging data or\n"
"other resources with the nearby devices easy. The framework provides a\n"
"provision where the connection with the peers can be created in an\n"
"encrypted manner. Applications should enable the encryption feature\n"
"while exchanging data with the peers which ensures the confidentiality\n"
"of data.\n"
msgstr ""
"\n"
"<p> \tMulti-peer Connectivity Framework はデータあるいは他のリソースと近くの"
"デバイスの交換のタスクを容易にします。  framework はどこでピアとの接続を暗号"
"化された方法で作成することが出来るかの規定を提供します。アプリは、データの機"
"密性を保証するピアとのデータ交換の間に暗号化の特徴を有効にするべきです。</"
"p>\n"

#: vulnerabilities.py:2933
msgid ""
"\n"
"MultiPeer Connectivity Framework is used for establishing connection\n"
"with the devices in close proximity\n"
msgstr ""
"\n"
"Multipeer Connectivity Frameworkは、近くにあるデバイスとの接続を確立するため"
"に使用されます。\n"

#: vulnerabilities.py:2937
msgid ""
"\n"
"Failing to use encrypted channels may undermine the confidentiality of\n"
"the transmitted data.\n"
msgstr ""
"\n"
"Failing to use encrypted channels may undermine the confidentiality of\n"
"the transmitted data.\n"

#: vulnerabilities.py:2941
msgid ""
"\n"
"While establishing a connection with the peer always initialize the\n"
"session with encryption preference set as `MCEncryptionRequired` to\n"
"ensure that complete data is shared on an encrypted channel.\n"
msgstr ""
"\n"
"<p> ピアとの接続を構成する間に、完全なデータが暗号化チャネルで確実に共有され"
"るように、常に暗号化選択が 'MCEncryptionRequired' として設定されたセッション"
"を初期化してください。</p>\n"

#: vulnerabilities.py:2956
msgid "Unsecured Keychain Data"
msgstr "セキュリティで保護されていないキーチェーンデータ"

#: vulnerabilities.py:2957
msgid "Does the application insecurely store data in Keychain?"
msgstr ""
"アプリケーションはキーチェーンでセキュリティで保護されずにデータを保存してい"
"ませんか？"

#: vulnerabilities.py:2958
msgid "The application does not store sensitive data in Keychain."
msgstr "アプリケーションは重要なデータをキーチェーンに保存しません。"

#: vulnerabilities.py:2959
msgid ""
"\n"
"iOS provides the Keychain for secure data storage. However, in several\n"
"scenarios, the Keychain can be compromised and subsequently decrypted.\n"
"\n"
"In all versions of iOS up to and including iOS 11, Keychain can be\n"
"partially compromised if attacker has access to the encrypted iTunes\n"
"backup. Due to the way iOS re-encrypts Keychain entries when creating\n"
"iTunes backups, it is possible to partially decrypt Keychain when iTunes\n"
"backup is available and password for backup encryption is known (note\n"
"that iTunes backups that are not encrypted do not allow decryption of\n"
"Keychain items).\n"
"\n"
"Keychain access controls are rendered ineffective if a jailbreak has\n"
"been applied to the device. In this case any application running on the\n"
"device can potentially read every other application's Keychain items.\n"
"\n"
"Lastly, for older devices, such as the iPhone 4, for which so-called\n"
"\"bootrom exploits\" exist, the Keychain can be compromised by an attacker\n"
"with physical access to the device.\n"
msgstr ""
"\n"
"<p>iOS はセキュリティで保護されたデータストレージのためのキーチェーンを提供し"
"ます。　しかし、いくつかのシナリオでは、キーチェーンは侵害され、その後複号化"
"される可能性があります。</p><p>  iOS 7 までの iOS のすべてのバージョンにおい"
"て、もし攻撃者が暗号化された iTunes バックアップにアクセスすれば、キーチェー"
"ンは部分的に侵害される可能性があります。 iTunes バックアップ作成時に iOS が"
"キーチェーンエントリーを再暗号化する方法によって、iTunes バックアップが利用可"
"能で、バックアップ暗号化のためのパスワードが知られている時（暗号化されていな"
"い iTunes バックアップはキーチェーンアイテムの復号化を許可しないことに注"
"意）、キーチェーンを部分的に復号化することが可能です。 </p><p>  もし "
"\"jailbreak\" がデバイスに適用されたら、キーチェーンアクセスコントロールは無"
"効にされます。この場合、デバイス上で実行しているどんなアプリも他のすべてのア"
"プリのキーチェーンアイテムを読み取る可能性があります。</p><p> 最後に、iPhone "
"4 のような古いデバイスにとって、そのために \"bootrom exploits\" が存在し、"
"キーチェーンが、攻撃者によるデバイスへの物理的なアクセスによって侵害される可"
"能性があります。 </p>\n"

#: vulnerabilities.py:2979
msgid ""
"\n"
"Insecured data kept in iOS Keychain\n"
msgstr ""
"\n"
"iOSのキーチェーンに安全でないデータが保存されています。\n"

#: vulnerabilities.py:2982
msgid ""
"\n"
"Failing to take proper precautions may result in loss of login\n"
"credentials, passwords and other highly sensitive data stored in the\n"
"keychain.\n"
msgstr ""
"\n"
"適切な注意を怠ると、ログイン資格情報、パスワード、およびキーチェーンに保存さ"
"れているその他の機密性の高いデータが失われる可能性があります。\n"

#: vulnerabilities.py:2987
msgid ""
"\n"
"Store the sensitive data such as passwords in an encrypted form on the\n"
"device keychain so that even if the device is compromised no one can\n"
"infer correct passwords.\n"
"\n"
"When storing data in the Keychain, use the most restrictive protection\n"
"class (as defined by `kSecAttrAccessible` attribute) that still allows\n"
"your application to function properly. For example, if your application\n"
"is not designed to be running in the background, use\n"
"`kSecAttrAccessibleWhenUnlocked` or "
"`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`\n"
"\n"
"To prevent Keychain item exposure via iTunes backup, use one of\n"
"`...ThisDeviceOnly` protection classes if practical.\n"
"\n"
"Finally, for highly sensitive data, consider augmenting protections\n"
"offered by the Keychain with application-level encryption. For example,\n"
"rely upon the user to enter a passphrase to authenticate within the\n"
"application and use that passphrase to encrypt data before storing it\n"
"into the Keychain.\n"
"\n"
"    #define SALT_HASH @"
"\"FvTivqTqZXsgLLx1v3P8TGRyVHaSOB1pvfm02wvGadj7RLHV8GrfxaZ84oGA8RsKdNRpxdAojXYg9iAj"
"\"\n"
"\n"
"    + (NSString *)securedSHA256DigestHashForPIN:(NSUInteger)pinHash\n"
"    {\n"
"        // 1\n"
"        NSString *name = [[NSUserDefaults standardUserDefaults] stringForKey:"
"USERNAME];\n"
"        name = [name stringByAddingPercentEscapesUsingEncoding:"
"NSUTF8StringEncoding];\n"
"        // 2\n"
"        NSString *computedHashString = [NSString stringWithFormat:@\"%@%i%@"
"\", name, pinHash, SALT_HASH];\n"
"        // 3\n"
"        NSString *finalHash = [self computeSHA256DigestForString:"
"computedHashString];\n"
"        NSLog(@\" Computed hash: %@ for SHA256 Digest: %@\", "
"computedHashString, finalHash);\n"
"        return finalHash;\n"
"    }\n"
"    NSLog(@\"User entered PIN\");\n"
"    if ([textField.text length] > 0) {\n"
"        NSUInteger fieldHash = [textField.text hash];\n"
"        // 4\n"
"        NSString *fieldString = [KeychainWrapper "
"securedSHA256DigestHashForPIN:fieldHash];\n"
"        NSLog(@\" Password Hash - %@\", fieldString);\n"
"        // Save PIN hash to the keychain (NEVER store the direct PIN)\n"
"        if ([KeychainWrapper createKeychainValue:fieldString forIdentifier:"
"PIN_SAVED]) {\n"
"            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:"
"PIN_SAVED];\n"
"            [[NSUserDefaults standardUserDefaults] synchronize];\n"
"            NSLog(@\" Key saved successfully to Keychain!!\");\n"
"        }\n"
"    }\n"
"\n"
msgstr ""
"\n"
"たとえデバイスが侵害されても、誰も正しいパスワードを察知できないように、パス"
"ワードのような重要データは暗号化されたフォームでデバイスキーチェーン上に保存"
"してください。\n"
"データをキーチェーンに保存するときは、あなたのアプリが正常に機能することを許"
"可する、最も厳しい保護クラスを使用してください（kSecAttrAccessible attribute "
"によって定義されたように）。例えば、もしあなたのアプリがバックグラウンドで実"
"行するよう設計されていないなら、 kSecAttrAccessibleWhenUnlocked または "
"kSecAttrAccessibleWhenUnlockedThisDeviceOnly を使用してください。\n"
"キーチェーンアイテムの iTunes バックアップ経由での露出を防ぐために、もし実用"
"的なら...ThisDeviceOnly 保護クラスの一つを使用してください。\n"
"最後に、高度に重要なデータのためにキーチェーンによって提供されるアプリレベル"
"の暗号化での保護の増量を考えてください。例えば、ユーザーをアプリ内での認証の"
"ためのパスフレーズに入るようにし、キーチェーンにそれを保存する前にパスフレー"
"ズを使いデータを暗号化してください。\n"
"\n"
"    #define SALT_HASH @"
"\"FvTivqTqZXsgLLx1v3P8TGRyVHaSOB1pvfm02wvGadj7RLHV8GrfxaZ84oGA8RsKdNRpxdAojXYg9iAj"
"\"\n"
"\n"
"    + (NSString *)securedSHA256DigestHashForPIN:(NSUInteger)pinHash\n"
"    {\n"
"        // 1\n"
"        NSString *name = [[NSUserDefaults standardUserDefaults] stringForKey:"
"USERNAME];\n"
"        name = [name stringByAddingPercentEscapesUsingEncoding:"
"NSUTF8StringEncoding];\n"
"        // 2\n"
"        NSString *computedHashString = [NSString stringWithFormat:@\"%@%i%@"
"\", name, pinHash, SALT_HASH];\n"
"        // 3\n"
"        NSString *finalHash = [self computeSHA256DigestForString:"
"computedHashString];\n"
"        NSLog(@\" Computed hash: %@ for SHA256 Digest: %@\", "
"computedHashString, finalHash);\n"
"        return finalHash;\n"
"    }\n"
"    NSLog(@\"User entered PIN\");\n"
"    if ([textField.text length] > 0) {\n"
"        NSUInteger fieldHash = [textField.text hash];\n"
"        // 4\n"
"        NSString *fieldString = [KeychainWrapper "
"securedSHA256DigestHashForPIN:fieldHash];\n"
"        NSLog(@\" Password Hash - %@\", fieldString);\n"
"        // Save PIN hash to the keychain (NEVER store the direct PIN)\n"
"        if ([KeychainWrapper createKeychainValue:fieldString forIdentifier:"
"PIN_SAVED]) {\n"
"            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:"
"PIN_SAVED];\n"
"            [[NSUserDefaults standardUserDefaults] synchronize];\n"
"            NSLog(@\" Key saved successfully to Keychain!!\");\n"
"        }\n"
"    }\n"
"\n"

#: vulnerabilities.py:3036
msgid ""
"\n"
"Not in compliance with OWASP Mobile Top 10 for M8 - Side Channel Data\n"
"Leakage Example keychain implementation where the pincode is stored\n"
"insecurely:\n"
"\n"
"    NSLog(@\"User entered PIN\");\n"
"    if ([textField.text length] > 0) {\n"
"        NSUInteger fieldHash = [textField.text hash];\n"
"\n"
"        NSLog(@\" Password Is - %@\", fieldString);\n"
"\n"
"        // Save PIN  to the keychain (NEVER store the direct PIN)\n"
"        if ([KeychainWrapper createKeychainValue:fieldString forIdentifier:"
"PIN_SAVED]) {\n"
"            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:"
"PIN_SAVED];\n"
"            [[NSUserDefaults standardUserDefaults] synchronize];\n"
"            NSLog(@\" Key saved successfully to Keychain!!\");\n"
"        }\n"
"    }\n"
"\n"
msgstr ""
"\n"
"OWASP Mobile Top 10 の M8 に非準拠  - Side Channel Data Leakage\n"
"ピンコードがセキュリティで保護されずに保存されるキーチェーンの実装例：\n"
"    NSLog(@\"User entered PIN\");\n"
"    if ([textField.text length] > 0) {\n"
"        NSUInteger fieldHash = [textField.text hash];\n"
"\n"
"        NSLog(@\" Password Is - %@\", fieldString);\n"
"\n"
"        // Save PIN  to the keychain (NEVER store the direct PIN)\n"
"        if ([KeychainWrapper createKeychainValue:fieldString forIdentifier:"
"PIN_SAVED]) {\n"
"            [[NSUserDefaults standardUserDefaults] setBool:YES forKey:"
"PIN_SAVED];\n"
"            [[NSUserDefaults standardUserDefaults] synchronize];\n"
"            NSLog(@\" Key saved successfully to Keychain!!\");\n"
"        }\n"
"    }\n"
"\n"

#: vulnerabilities.py:3056
msgid ""
"\n"
"- [Keychain Services Programming Guide](https://developer.apple.com/library/"
"ios/documentation/security/Conceptual/keychainServConcepts/01introduction/"
"introduction.html#//apple_ref/doc/uid/TP30000897)\n"
"- [M2 - Insecure Data Storage](https://www.owasp.org/index.php/"
"Mobile_Top_10_2014-M2)\n"
"- [M5 - Poor Authorization and Authentication](https://www.owasp.org/index."
"php/Mobile_Top_10_2014-M5)\n"
"\n"
msgstr ""
"\n"
"- [Keychain Services Programming Guide](https://developer.apple.com/library/"
"ios/documentation/security/Conceptual/keychainServConcepts/01introduction/"
"introduction.html#//apple_ref/doc/uid/TP30000897)\n"
"- [M2 - 安全でないデータストレージ](https://www.owasp.org/index.php/"
"Mobile_Top_10_2014-M2)\n"
"- [M5 -　不充分な認可と認証](https://www.owasp.org/index.php/"
"Mobile_Top_10_2014-M5)\n"

#: vulnerabilities.py:3070
msgid "Exposed Pasteboard Data"
msgstr "公開されたペーストボードデータ"

#: vulnerabilities.py:3071
msgid ""
"Does the application allow copy/paste functionalities in sensitive fields?"
msgstr ""
"アプリケーションは重要なフィールドでコピー·ペースト機能を許可していますか？"

#: vulnerabilities.py:3072
msgid "The application has proper protection from general pasteboard."
msgstr "アプリケーションは一般的なペーストボードから適切な保護を持っています。"

#: vulnerabilities.py:3073
msgid ""
"\n"
"Both iOS and Android support copy/paste. Sensitive data may be stored,\n"
"recoverable, or could be modified from the clipboard in clear text,\n"
"regardless of whether the source of the data was initially encrypted. If\n"
"it is in plaintext at the moment the user copies it, it will be in\n"
"plaintext when other applications access the clipboard.\n"
msgstr ""
"\n"
"<p> iOS と Android の両方がコピー·ペーストをサポートしています。データのソー"
"スが最初に暗号化されているかどうかに関わらず、重要なデータは保存され、回復可"
"能、あるいは平文でクリップボードから修正が可能かもしれません。もしユーザーが"
"それをコピーする時にそれがプレーンテキストなら、それは他のアプリがクリップ"
"ボードにアクセスする時、プレーンテキストになるでしょう。 </p>\n"

#: vulnerabilities.py:3080
msgid ""
"\n"
"Exposing sensitive data like passwords in pasteboard/clipboard which can\n"
"be used by other applications\n"
msgstr ""
"\n"
"パスワードのような重要なデータを他のアプリケーションが使用できるペーストボー"
"ド/クリップボード内に公開。\n"

#: vulnerabilities.py:3084
msgid ""
"\n"
"Failing to take proper precautions may result in loss of login\n"
"credentials, passwords and other sensitive data stored in the clipboard.\n"
msgstr ""
"\n"
"適切な注意を怠ると、ログイン情報、パスワード、その他の機密データがクリップ"
"ボードに保存されなくなる可能性があります。\n"

#: vulnerabilities.py:3088
msgid ""
"\n"
"Use application specific pasteboard. Also mark fields like passwords as\n"
"secure so that their data can never be copied\n"
"\n"
"Pasteboards may be public or private. Public pasteboards are called\n"
"system pasteboards; private pasteboards are created by apps, and hence\n"
"are called app pasteboards. Pasteboards must have unique names.\n"
"UIPasteboard defines two system pasteboards, each with its own name and\n"
"purpose:\n"
"\n"
"- `UIPasteboardNameGeneral` is for cut, copy, and paste operations\n"
"  involving a wide range of data types. You can obtain a singleton\n"
"  object representing the General pasteboard by invoking the\n"
"  generalPasteboard class method.\n"
"- `UIPasteboardNameFind` is for search operations. The string currently\n"
"  typed by the user in the search bar (`UISearchBar`) is written to this\n"
"  pasteboard, and thus can be shared between apps. You can obtain an\n"
"  object representing the Find pasteboard by calling the\n"
"  pasteboardWithName:create: class method, passing in\n"
"  UIPasteboardNameFind for the name.\n"
"\n"
"Typically you use one of the system-defined pasteboards, but if\n"
"necessary you can create your own app pasteboard using\n"
"pasteboardWithName:create: If you invoke pasteboardWithUniqueName,\n"
"UIPasteboard gives you a uniquely-named app pasteboard. You can discover\n"
"the name of a pasteboard through its name property\n"
"\n"
"Clear the Pasteboard once the application enters background. You can do\n"
"this by adding the following line in the method\n"
"\n"
"`- (void)applicationDidEnterBackground:(UIApplication \\*)` application in "
"AppDelegate.\n"
"\n"
"If you are using a custom Pasteboard, replace `[UIPasteboard "
"generalPasteboard]` with your custom pasteboard.\n"
"\n"
"    - (void)applicationDidEnterBackground:(UIApplication *)application\n"
"    {\n"
"        // Use this method to release shared resources, save user data, "
"invalidate\n"
"        timers, and store enough application state information to restore "
"your application\n"
"        to its current state in case it is terminated later.\n"
"\n"
"        // If your application supports background execution, this method is "
"called\n"
"        instead of applicationWillTerminate: when the user quits.\n"
"\n"
"        [UIPasteboard generalPasteboard].items = nil;\n"
"    }\n"
"\n"
msgstr ""
"\n"
"<p>特定のペーストボードアプリを使用してください。また、データが絶対にコピーさ"
"れないよう保護されたパスワードのようなフィールドをマークしてください。 </p> "
"<p>ペーストボードはパブリックあるいはプライベートになり得ます。 パブリック"
"ペーストボードはシステムペーストボードと呼ばれます。 プライベートペーストボー"
"ドはアプリによって作成され、そのためアプリペーストボードと呼ばれます。ペース"
"トボードはユニークな名前を持つ必要があります。\n"
"\n"
"- `UIPasteboardNameGeneral`は、広範囲のデータ型を含むカット、コピー、ペースト"
"の操作用です。汎用ペーストボードを表すシングルトンオブジェクトを取得するに"
"は、generalPasteboardクラスメソッドを呼び出します。\n"
"\n"
"- `UIPasteboardNameFind`は検索操作のためのものです。\n"
"検索バーのユーザーが現在入力した文字列（ `UISearchBar`）はこのペーストボード"
"に書き込まれ、アプリ間で共有できます。 FindPasteboardを表すオブジェクトを取得"
"するには、pasteboardWithName：create：classメソッドを呼び出し、"
"UIPasteboardNameFindで名前を渡します。\n"
"\n"
"通常、システム定義のペーストボードの1つを使用しますが、必要に応じて"
"pasteboardWithNameを使用して独自のアプリペーストボードを作成できます。"
"create：pasteboardWithUniqueNameを呼び出すと、UIPasteboardは固有の名前のアプ"
"リペーストボードを提供します。ペーストボードの名前は、そのnameプロパティで検"
"出できます。\n"
"\n"
"アプリケーションがバックグラウンドになると、ペーストボードをクリアします。\n"
"これを行うには、メソッドに次の行を追加します。\n"
"`- (void)applicationDidEnterBackground:(UIApplication \\*)` application in "
"AppDelegate.\n"
"\n"
"If you are using a custom Pasteboard, replace `[UIPasteboard "
"generalPasteboard]` with your custom pasteboard.\n"
"\n"
"    - (void)applicationDidEnterBackground:(UIApplication *)application\n"
"    {\n"
"        // Use this method to release shared resources, save user data, "
"invalidate\n"
"        timers, and store enough application state information to restore "
"your application\n"
"        to its current state in case it is terminated later.\n"
"\n"
"        // If your application supports background execution, this method is "
"called\n"
"        instead of applicationWillTerminate: when the user quits.\n"
"\n"
"        [UIPasteboard generalPasteboard].items = nil;\n"
"    }\n"
"\n"

#: vulnerabilities.py:3135
msgid ""
"\n"
"Not in compliance with OWASP Mobile Top 10 for M8 - Side Channel Data\n"
"Leakage A general Pasteboard implementation looks like the following\n"
"\n"
"    // setup: let's put some stuff in the UIPasteboard\n"
"\n"
"    let pasteboard = UIPasteboard.general()\n"
"    pasteboard.string = \"andy\"\n"
"    pasteboard.url = URL(string: \"http://cleanswifter.com\")\n"
"    pasteboard.image = UIImage()\n"
"    pasteboard.color = UIColor.red()\n"
"\n"
"    // understanding the UIPasteboard contents\n"
"\n"
"    if pasteboard.hasStrings {\n"
"        print(\"The pasteboard has Strings!\")\n"
"    }\n"
"    if pasteboard.hasURLs {\n"
"        print(\"The pasteboard has URLs!\")\n"
"    }\n"
"    if pasteboard.hasImages {\n"
"        print(\"The pasteboard has images!\")\n"
"    }\n"
"    if pasteboard.hasColors {\n"
"        print(\"The pasteboard has colors!\")\n"
"    }\n"
"\n"
msgstr ""
"\n"
"OWASP Mobile Top 10 の M8 に非準拠 - Side Channel Data Leakage  一般的なペー"
"ストボード実装は次のとおりです。\n"
"    // setup: let's put some stuff in the UIPasteboard\n"
"\n"
"    let pasteboard = UIPasteboard.general()\n"
"    pasteboard.string = \"andy\"\n"
"    pasteboard.url = URL(string: \"http://cleanswifter.com\")\n"
"    pasteboard.image = UIImage()\n"
"    pasteboard.color = UIColor.red()\n"
"\n"
"    // understanding the UIPasteboard contents\n"
"\n"
"    if pasteboard.hasStrings {\n"
"        print(\"The pasteboard has Strings!\")\n"
"    }\n"
"    if pasteboard.hasURLs {\n"
"        print(\"The pasteboard has URLs!\")\n"
"    }\n"
"    if pasteboard.hasImages {\n"
"        print(\"The pasteboard has images!\")\n"
"    }\n"
"    if pasteboard.hasColors {\n"
"        print(\"The pasteboard has colors!\")\n"
"    }\n"
"\n"

#: vulnerabilities.py:3163
msgid ""
"\n"
"- [JVN\\#76662040](https://jvn.jp/en/jp/JVN76662040/) Clipboard\n"
"  contents alteration vulnerability in Grani\n"
"- [JVN\\#64764004](http://jvn.jp/en/jp/JVN64764004/index.html) Clipboard\n"
"  contents alteration vulnerability in Sleipnir\n"
msgstr ""
"\n"
"- [JVN\\#76662040](https://jvn.jp/en/jp/JVN76662040/) Grani クリップボードの"
"内容変更に関する脆弱性\n"
"- [JVN\\#64764004](http://jvn.jp/en/jp/JVN64764004/index.html) Sleipnir ク"
"リップボードの内容変更に関する脆弱性\n"

#: vulnerabilities.py:3177
msgid "Buffer Overflows and Underflows"
msgstr "バッファのオーバーフローとアンダーフロー"

#: vulnerabilities.py:3178
msgid "Does the application have buffer overflow or underflow vulnerabilities?"
msgstr ""
"アプリケーションに脆弱性関連のバッファオーバーフローあるいはアンダーフローが"
"ありませんか？"

#: vulnerabilities.py:3179
msgid ""
"The application does not seem have buffer overflow or underflow "
"vulnerabilities."
msgstr ""
"アプリケーションにバッファオーバーフローやアンダーフローの脆弱性がないようで"
"す。"

#: vulnerabilities.py:3180
msgid ""
"\n"
"iOS has several mechanisms which prevent the application from being\n"
"compromised at runtime. In order to understand the security issues that\n"
"affect iOS applications, it is important to understand and to known the\n"
"security features of the platform. The main [security features of iOS]"
"(http://www.apple.com/ipad/business/docs/iOS_Security_Feb14.pdf) are:\n"
"\n"
"- Code signing: ensures that all applications come from a approved source "
"(using\n"
"  Apple-issued certificates)\n"
"- Generic exploit mitigations\n"
"    - Address Space Layout Randomization (ASLR): Usually compiled using `-"
"fPIE -pie`\n"
"    - Non Executable Memory (ARM's Execute Never feature)\n"
"    - Stack Smashing Protections (SSP): Usually compiled with `-fstack-"
"protector-all` flag\n"
"- Sandboxing\n"
"    - run applications as non-privileged user\n"
"    - 3rd-party apps are restricted in accessing files stored by other\n"
"      apps\n"
"- Memory Management\n"
"    - Automatic Reference Counting (ARC) protects applications\n"
"      from memory coruption issues by letting the compiler do the\n"
"      memory management stuff\n"
"\n"
msgstr ""
"\n"
"<p>iOS はアプリがランタイムで危害を受けることを防ぐ、いくつかのメカニズムを"
"持っています。 iOS アプリに影響を与えるセキュリティ問題を理解するために、プ"
"ラットフォームのセキュリティの特徴を理解することが重要です。 iOS の主なセキュ"
"リティの特徴は、 こちらを参照してください。 (<a href=\"http://www.apple.com/"
"ipad/business/docs/iOS_Security_Feb14.pdf\">http://www.apple.com/ipad/"
"business/docs/iOS_Security_Feb14.pdf</a>) </p> <ul>     <li>         "
"<p><strong>コードサイニング</strong></p>         <ul>             <li>すべて"
"のアプリケーションが承認されたソースからのものであることを確認します。（ アッ"
"プル発行の証明書）</li>         </ul>     </li>     <li>         <p><strong>"
"ジェネリックエクスプロイト緩和</strong></p>         <ul>             <li>アド"
"レス空間レイアウトランダム化（ASLR）(<a href=\"\" http://en.wikipedia.org/"
"wiki/Address_space_layout_randomization \"\">ASLR</a>)                 "
"<ul>                     <li>通常は、 <code>-fPIE -pie</code>を使用してコンパ"
"イルされます。</li>                 </ul>             </li>             <li>"
"非実行メモリ(<a href=\"\" http://en.wikipedia.org/wiki/"
"Address_space_layout_randomization \"\">（ARMのExecute Never機能）</a> </"
"li>             <li>Stack Smashing Protections (<a href=\"\" http://wiki."
"osdev.org/Stack_Smashing_Protector \"\">SSP</a>)                 "
"<ul>                     <li>通常は、<code>-fstack-protector-all</code> フラ"
"グでコンパイルされます。</li>                 </ul>             </"
"li>         </ul>     </li>     <li>         <p><strong>サンドボックス</"
"strong></p>         <ul>             <li>非特権ユーザーとしてアプリケーション"
"を実行します。</li>             <li>サードパーティのアプリケーションは他のア"
"プリケーションに保存されているファイルへのアクセスが制限されています。</"
"li>         </ul>     </li>     <li>         <p><strong>メモリ管理</strong></"
"p>         <ul>             <li>自動参照カウント（ARC） (<a href=\"\" "
"https://developer.apple.com/library/ios/releasenotes/objectivec/rn-"
"transitioningtoarc/Introduction/Introduction.html \"\">ARC</a>) は、コンパイ"
"ラにメモリ管理の処理をさせることで、メモリの脆弱性の問題からアプリケーション"
"を保護します。</li>         </ul>     </li> </ul> \n"

#: vulnerabilities.py:3202 vulnerabilities.py:4867
msgid ""
"\n"
"Buffer overflows, both on the stack and on the heap, are a major source\n"
"of security vulnerabilities in C, Objective-C, and C++ code.\n"
msgstr ""
"\n"
"スタック上およびヒープ上のバッファオーバーフローは、C、Objective-C、およびC+"
"+のコードのセキュリティ脆弱性の主要な原因です。\n"

#: vulnerabilities.py:3207
msgid ""
"\n"
"Usually the ipa file will be decrypted at runtime by the kernel's mach\n"
"loader. If the binary is encrypted or not is easily found using otool\n"
"\n"
"An example where the binary is encrypted:\n"
"\n"
"    # otool -l OTHER_BINARY | grep -A 4 LC_ENCRYPTION_INFO\n"
"           cmd LC_ENCRYPTION_INFO\n"
"       cmdsize 20\n"
"      cryptoff 16384\n"
"     cryptsize 10502144\n"
"     cryptid   1\n"
"\n"
"- ASLR\n"
"    - Usually the binary is compiled using the `PIE` flag\n"
"- Stack Smashing Protection\n"
"    - iOS applications usually use `[stack canaries]()`\n"
"    - therefore you should find certain symbols inside the binary\n"
"        (like `_stack_chk_guard` and `_stack_chk_fail`)\n"
"- Automatic Reference Couting\n"
"    - this option can be enabled by activating the compiler option\n"
"      `Objective-C Automatic Reference Counting`\n"
"    - binaries built with this option should include symbols called\n"
"      `_objc_release`, `_obj_autorelease`, `_obj_storeStrong`,\n"
"      `_obj_retain`\n"
"\n"
msgstr ""
"\n"
"通常、 <code>ipa</code> ファイルはランタイム時にカーネルの mach loader によっ"
"て復号化されます。\n"
"もしバイナリが暗号化あるいは otool を使用しているのが容易に分からない場合\n"
"バイナリが暗号化されている場所の一例：\n"
"\n"
"    # otool -l OTHER_BINARY | grep -A 4 LC_ENCRYPTION_INFO\n"
"           cmd LC_ENCRYPTION_INFO\n"
"       cmdsize 20\n"
"      cryptoff 16384\n"
"     cryptsize 10502144\n"
"     cryptid   1\n"
"\n"
"- ASLR\n"
"    - Usually the binary is compiled using the `PIE` flag\n"
"- Stack Smashing Protection\n"
"    - iOS applications usually use `[stack canaries]()`\n"
"    - therefore you should find certain symbols inside the binary\n"
"        (like `_stack_chk_guard` and `_stack_chk_fail`)\n"
"- Automatic Reference Couting\n"
"    - this option can be enabled by activating the compiler option\n"
"      `Objective-C Automatic Reference Counting`\n"
"    - binaries built with this option should include symbols called\n"
"      `_objc_release`, `_obj_autorelease`, `_obj_storeStrong`,\n"
"      `_obj_retain`\n"
"\n"

#: vulnerabilities.py:3235 vulnerabilities.py:4877
msgid ""
"\n"
"- [Avoiding Buffer Overflows and Underflows by\n"
"  Apple](https://developer.apple.com/library/ios/documentation/Security/"
"Conceptual/SecureCodingGuide/Articles/BufferOverflows.html)\n"
"- [Hacking and Securing iOS\n"
"  Applications](http://books.google.de/books?"
"id=huy8AwAAQBAJ&printsec=frontcover#v=onepage&q&f=false)\n"
"\n"
msgstr ""
"\n"
"- [Appleによるバッファオーバーフローとアンダーフローの回避](https://"
"developer.apple.com/library/ios/documentation/Security/Conceptual/"
"SecureCodingGuide/Articles/BufferOverflows.html)\n"
"- [[iOSアプリケーションのハッキングとセキュリティ保護](http://books.google."
"de/books?id=huy8AwAAQBAJ&printsec=frontcover#v=onepage&q&f=false)\n"

#: vulnerabilities.py:3249
msgid "Jailbreak Detection"
msgstr "脱獄検出"

#: vulnerabilities.py:3250
msgid "Does the app implement any form of jailbreak detection?"
msgstr "アプリケーションはなんらかの脱獄検出を実装していますか？"

#: vulnerabilities.py:3251
msgid ""
"The app seems to implement routines that check if device has been jailbroken."
msgstr ""
"アプリケーションはデバイスが脱獄されているかどうかをチェックするルーチンを実"
"装しているようです。"

#: vulnerabilities.py:3252
msgid ""
"\n"
"Jailbreaking is the removing of software restrictions imposed by Apple.\n"
"Jailbreaking permits root access to the iOS file system and manager,\n"
"allowing the download of additional applications and extensions that are\n"
"unavailable through the official Apple App Store. Attackers often target\n"
"jailbroken iPhones on which malware can be installed more easily.\n"
msgstr ""
"\n"
"ジェイルブレイクとは、Appleが課したソフトウェアの制限を解除することです。ジェ"
"イルブレイキングは、iOSファイルシステムとマネージャへのルートアクセスを許可"
"し、正式なApple App Storeで利用できない追加のアプリケーションや拡張機能のダウ"
"ンロードを可能にします。マルウェアをより簡単にインストールできるため、攻撃者"
"はジェイルブレイクされたiPhoneをターゲットにしていることがよくあります。\n"

#: vulnerabilities.py:3259
msgid ""
"\n"
"Jailbroken devices may make it easier for attackers to break into the\n"
"application. Employing jailbreak detection and limiting functionality of\n"
"application on jailbroken devices is recommended.\n"
msgstr ""
"\n"
"脱獄されたデバイスは、攻撃者がアプリケーションに侵入するのを容易にする可能性"
"があります。脱獄検出の使用と脱獄されたデバイス上でのアプリケーションの機能制"
"限が推奨されます。\n"

#: vulnerabilities.py:3264
msgid ""
"\n"
"Attackers can run tools like Cycript, GDB, Snoop-it etc. to perform\n"
"runtime analysis and steal sensitive data from within applications. To\n"
"add an extra layer of security for your application, you should not\n"
"allow your application to be run on a jailbroken device. Note that there\n"
"are millions of jailbroken devices, so preventing your app from running\n"
"on a jailbroken device could lead to a limited userbase and/or bad App\n"
"Store reviews. An alternative option is to block some features in your\n"
"application rather than disabling the functionality entirely.\n"
msgstr ""
"\n"
"<p>攻撃者は、Cycript、GDB、Snoop-itなどのツールを実行して、ランタイム解析を実"
"行し、アプリケーション内の機密データを盗むことができます。アプリケーションに"
"特別なセキュリティ層を追加するためには、脱獄デバイス上でアプリケーションを実"
"行するのを許可しないようにするべきです。数百万もの脱獄デバイスがあるので、脱"
"獄デバイス上でアプリケーションが実行されないようにすることでユーザベースの限"
"定やAppStoreの悪いレビューが発生する可能性があることに注意してください。代替"
"オプションは、機能を完全に無効にするのではなく、アプリケーションの一部の機能"
"をブロックすることです。</p>\n"

#: vulnerabilities.py:3274
msgid ""
"\n"
"Consider using jailbreak detection SDKs or libraries. Note that by\n"
"nature, jailbroken devices may prevent these methods from being 100%\n"
"accurate.\n"
msgstr ""
"\n"
"ジェイルブレイク検出SDKやライブラリの使用を検討してください。ただしその方法も"
"ジェイルブレイクされたデバイスにとっては100％の正確性とはいえない可能性がある"
"ことに注意してください。\n"

#: vulnerabilities.py:3288
msgid "UIWebView Exploits"
msgstr "UIWebViewの悪用"

#: vulnerabilities.py:3289
msgid "Are there instances of UIWebView used in the app?"
msgstr "アプリケーション内でUIWebViewのインスタンスは使用されていますか？"

#: vulnerabilities.py:3290
msgid "UIWebView is not used in the app."
msgstr "アプリケーション内でUIWebViewは使用されていません。"

#: vulnerabilities.py:3291
msgid ""
"\n"
"iOS offers the UIWebView class to embed web content in the app. This is\n"
"often used when a web application needs to be quickly ported to multiple\n"
"mobile platforms without having to create a specific UI for each.\n"
msgstr ""
"\n"
"OSは、Webコンテンツをアプリに埋め込むためのUIWebViewクラスを提供します。これ"
"は、Webアプリケーションを複数のモバイルプラットフォームにすばやく移植する必要"
"があり、それぞれに固有のUIを作成する必要がない場合によく使用されます。\n"

#: vulnerabilities.py:3296
msgid ""
"\n"
"UIWebView can be susceptible to client side Javascript injection. It can\n"
"also retain sensitive content in the memory as cache\n"
msgstr ""
"\n"
"UIWebViewはクライアントサイドのJavascriptインジェクションの影響を受けやすい可"
"能性あります。メモリ内の機密コンテンツをキャッシュとして保持することもできま"
"す。\n"

#: vulnerabilities.py:3300
msgid ""
"\n"
"UIWebView can be susceptible to client side Javascript injection if\n"
"inputs are not properly validated. Since the code is injected on the\n"
"client side, it is possible to call native functions in the device and\n"
"perform malicious actions. Currently there are no public APIs to disable\n"
"Javascript in UIWebView.\n"
"\n"
"Furthermore, UIWebView may cache loaded data into the internal database.\n"
"This means that sensitive content remains in the memory even after it\n"
"has been closed.\n"
msgstr ""
"\n"
"<p>UIWebViewは、もし入力が適切に検証されていないなら、クライアントサイドの"
"Javascriptインジェクションの影響が受けやすい可能性があります。クライアント側"
"でコードを注入されるため、デバイス内でネイティブ関数を呼び出し、悪意のある操"
"作を実行することが可能です。現在、UIWebViewにJavascriptを無効にするパブリック"
"APIはありません。</p>\n"
"<p>さらに、UIWebViewはロードされたデータを内部データベースにキャッシュする可"
"能性があります。これは、機密コンテンツが閉じられた後でもメモリに残っているこ"
"とを意味します。</p>\n"

#: vulnerabilities.py:3311
msgid ""
"\n"
"When using UIWebView, make sure the data is loaded over HTTPS. Avoid\n"
"using it to load content that depends on user input. Validate the\n"
"contents of the URL by using `dataWithContentsOfURL` from NSData. Never\n"
"use loadRequest to render local file resource as this causes a universal\n"
"Cross-Site Scripting vulnerability. Instead, use `loadHTMLString:baseURL:`.\n"
"Finally, disable caching when sensitive content is loaded.\n"
msgstr ""
"\n"
"UIWebView を使用する場合は、HTTPS 経由でデータがロードされていることを確認し"
"てください。ユーザーの入力に依存するコンテンツを読み込むのに使用しないでくだ"
"さい。NSData の `dataWithContentsOfURL`を使用してURLの内容を検証します。ロー"
"カルファイルリソースをレンダリングするために loadRequest を使用しないでくださ"
"い。これにより、普遍的なクロスサイトスクリプティングの脆弱性が生じます。代わ"
"りに、 `loadHTMLString：baseURL：`を使用してください。重要なコンテンツが読み"
"込まれたときにキャッシュを無効にします。\n"

#: vulnerabilities.py:3328
msgid "WebView Exploits"
msgstr "WebViewの悪用"

#: vulnerabilities.py:3329
msgid "Are there instances of WebView used insecurely in the app?"
msgstr ""
"アプリケーション内でWebViewのインスタンスが不適切に使用されていませんか？"

#: vulnerabilities.py:3330
msgid "WebViews, if any, are properly implemented."
msgstr "WebViewが設定されているならば、適切に実装されています。"

#: vulnerabilities.py:3331
msgid ""
"\n"
"Android API offers WebView to deliver a web application (or just a web\n"
"page) as a part of a client app. A common scenario in which using\n"
"WebView is helpful is when you want to provide information in your\n"
"application that you might need to update, such as an end-user agreement\n"
"or a user guide. Another scenario is if your application provides data\n"
"to the user that always requires an Internet connection to retrieve\n"
"data, such as email. In this case, you might find that it's easier to\n"
"build a WebView in your Android application that shows a web page with\n"
"all the user data, rather than performing a network request, then\n"
"parsing the data and rendering it in an Android layout.\n"
msgstr ""
"\n"
"Android APIは、WebアプリケーションをWebアプリケーション（または単にWebペー"
"ジ）をクライアントアプリケーションの一部として提供するWebViewを提供します。\n"
"WebViewを使用する一般的なシナリオは、エンドユーザー契約やユーザーガイドなど、"
"更新が必要な情報をアプリケーションに提供する場合です。\n"
"もう1つのシナリオは、電子メールなどのデータを取得するためにインターネット接続"
"が常に必要なデータをユーザーに提供するアプリケーションです。 この場合、"
"Androidアプリケーションで、Webリクエストを実行してからデータを解析してAndroid"
"レイアウトでレンダリングするのではなく、すべてのユーザーデータを含むWebページ"
"を簡単に作成できることがわかります。\n"

#: vulnerabilities.py:3343
msgid ""
"\n"
"WebView can be susceptible to various exploits including client side\n"
"Javascript injection and network sniffing if improperly implemented.\n"
msgstr ""
"\n"
"WebViewは、もし不適切に実装されている場合、クライアントサイドのJavascriptイン"
"ジェクションやネットワークスニッフィングを含む様々な悪用の影響を受けやすい可"
"能性があります。\n"

#: vulnerabilities.py:3347
msgid ""
"\n"
"An improperly implemented WebView instance may be vulnerable to XSS can\n"
"be used to gain access to shared preference files using `file:///`. When\n"
"Javascript is enabled, it may allow adversaries to perform XSS attacks.\n"
"Furthermore, not loading WebView over HTTPS may allow attackers to sniff\n"
"data from network transmissions and perform Man-in-the-Middle attack by\n"
"injecting arbitrary JavaScript into the WebView.\n"
msgstr ""
"\n"
"不適切に実装されたWebViewインスタンスは、XSS が `file：///`を使って共有の設定"
"ファイルにアクセスするのに脆弱である可能性があります。Javascript を有効にする"
"と、敵対者が XSS 攻撃を実行する可能性があります。さらに、WebView を HTTPS 経"
"由でロードしないと、攻撃者はネットワーク送信からのデータを盗聴し、任意の"
"JavaScript を WebView に注入することで中間者攻撃を実行できます。\n"

#: vulnerabilities.py:3355
msgid ""
"\n"
"When using WebView, ensure the following:\n"
"\n"
"- Use WebView to load only trusted content\n"
"- Always load resources over HTTPS\n"
"- Avoid using Javascript within WebView. If Javascript is absolutely\n"
"  required, be sure that each context is escaped properly by using an\n"
"  XSS filter component such as the OWASP Java Encoder Project\n"
"- Accept only plain-text user input and sanitize it before displaying\n"
"  in WebView\n"
"\n"
msgstr ""
"\n"
"WebViewを使用する場合は、次の点を確認してください。\n"
"-  WebView を使用して信頼できるコンテンツのみを読み込む \n"
"- 常に HTTPS 経由でリソースを読み込む \n"
"-  WebView でJavascrip を使用しない。 Javascriptが絶対に必要な場合は、OWASP "
"Java エンコーダプロジェクトなどの XSS フィルタコンポーネントを使用して各コン"
"テキストを適切にエスケープする必要があります。プレーンテキストのユーザー入力"
"のみを受け入れ、WebView に表示する前にサニタイズします。\n"

#: vulnerabilities.py:3376
msgid "App Transport Security"
msgstr "App Transport Security (ATS) の設定"

#: vulnerabilities.py:3377
msgid "Is App Transport Security (ATS) properly configured?"
msgstr "App Transport Security (ATS)は正しく設定されていますか?"

#: vulnerabilities.py:3378
msgid "App Transport Security (ATS) is properly configured."
msgstr "App Transport Security (ATS)は正しく設定されています。"

#: vulnerabilities.py:3379
msgid ""
"\n"
"On Apple platforms, a networking security feature called App Transport\n"
"Security (ATS) is available to apps and app extensions, and is enabled\n"
"by default. It improves privacy and data integrity by ensuring your\n"
"app's network connections employ only industry-standard protocols and\n"
"ciphers without known weaknesses. This helps instill user trust that\n"
"your app does not accidentally leak transmitted data to malicious\n"
"parties.\n"
"\n"
"By configuring this key's value in your app's `Info.plist` file, you can\n"
"customize the security of your network connections in a variety of ways.\n"
"You can:\n"
"\n"
"- Allow insecure communication with particular servers\n"
"- Allow insecure loads for web views or for media, while maintaining ATS "
"protections elsewhere in your app\n"
"- Enable new security features such as Certificate Transparency\n"
"\n"
msgstr ""
"\n"
"Appleプラットフォームでは、App Transport Security（ATS）と呼ばれるネットワー"
"キングセキュリティ機能が、アプリやアプリの拡張機能で利用でき、デフォルトで有"
"効になっています。アプリのネットワーク接続で、業界標準のプロトコルと暗号のみ"
"を採用して、弱点を知らずにプライバシーとデータの整合性を向上させます。これ"
"は、あなたのアプリが悪意のある者に誤って送信されたデータを漏洩させないという"
"ユーザの信頼を高めるのに役立ちます。\n"
"\n"
"アプリの `Info.plist`ファイルにこのキーの値を設定することで、ネットワーク接続"
"のセキュリティをさまざまな方法でカスタマイズすることができます。 \n"
"\n"
"- 特定のサーバーとの安全でない通信を可能にする \n"
"-  Webビューやメディアのための安全なロードを許可し、アプリケーション内の他の"
"場所ではATS保護を維持する\n"
"- 証明書の透過性\n"

#: vulnerabilities.py:3397
msgid ""
"\n"
"App Transport Security (ATS), which is a networking security feature\n"
"that ensures network connections employ the most secure protocols and\n"
"ciphers, was found to be misconfigured.\n"
msgstr ""
"\n"
"ネットワーク接続がもっとも安全なプロトコルと暗号を使用することを確実にする"
"ネットワークセキュリティ機能であるApp Transport Security (ATS)が正しく設定さ"
"れていないことが判明しました。\n"

#: vulnerabilities.py:3402
msgid ""
"\n"
"Misconfiguring App Transport Security (ATS) may lead to:\n"
"\n"
"- Triggering App Store review and requiring justification\n"
"- Data getting accidentally leaked to malicious parties during transmission\n"
"- Loss of user trust\n"
"\n"
msgstr ""
"\n"
"<p>App Transport Security (ATS)が誤って設定されていると、次のような結果につな"
"がる可能性があります:</p>\n"
"<ul>\n"
"<li>App Storeのレビューを引き起こし、正当な理由を要求</li>\n"
"<li>送信中にデータが誤って悪意のある人に漏えい</li>\n"
"<li>ユーザの信頼の喪失</li>\n"
"</ul>\n"

#: vulnerabilities.py:3410
msgid ""
"\n"
"App Transport Security (ATS) is enabled by default for apps linked\n"
"against the iOS 9.0 or later, as indicated by the default Boolean value\n"
"of NO for the NSAllowsArbitraryLoads key. This key is at the root level\n"
"of the NSAppTransportSecurity dictionary. With ATS enabled, HTTP\n"
"connections must use HTTPS. Attempts to connect using insecure HTTP\n"
"fail. ATS employs the Transport Layer Security (TLS) protocol version\n"
"1.2.\n"
"\n"
"The `NSAppTransportSecurity` key is available in both apps and app\n"
"extensions. Starting in iOS 10.0 and later, the following subkeys are\n"
"supported:\n"
"\n"
"- `NSAllowsArbitraryLoadsInMedia`\n"
"- `NSAllowsArbitraryLoadsInWebContent`\n"
"- `NSRequiresCertificateTransparency`\n"
"- `NSAllowsLocalNetworking`\n"
"\n"
"For detailed documentation on configuring ATS, please read [Information "
"Property List Key\n"
"Reference](https://developer.apple.com/library/content/documentation/General/"
"Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/"
"TP40009251-SW35).\n"
msgstr ""
"\n"
"NSAlowsArbitraryLoads キーのデフォルトのブール値NOで示されるように、iOS 9.0以"
"降にリンクされたアプリケーションの場合、App Transport Security（ATS）はデフォ"
"ルトで有効になっています。このキーは、NSAppTransportSecurity  辞書のルートレ"
"ベルにあります。ATSを有効にすると、HTTP接続でHTTPSを使用する必要があります。"
"安全でないHTTPを使用して接続しようとすると失敗します。ATSはTransport Layer "
"Security（TLS）プロトコルバージョン1.2を採用しています。\n"
"\n"
"NSAppTransportSecurityキーは、アプリとアプリの両方の拡張機能で利用できます。"
"次のサブキーがサポートされています。\n"
"\n"
"- `NSAllowsArbitraryLoadsInMedia`\n"
"- `NSAllowsArbitraryLoadsInWebContent`\n"
"- `NSRequiresCertificateTransparency`\n"
"- `NSAllowsLocalNetworking`\n"
"ATSの設定に関する詳細なドキュメントについては\n"
" [Information Property List Key Reference](https://developer.apple.com/"
"library/content/documentation/General/Reference/InfoPlistKeyReference/"
"Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW35).を参照してくださ"
"い。\n"

#: vulnerabilities.py:3432
msgid ""
"\n"
"For background on secure Internet connections, please read [HTTPS Server "
"Trust\n"
"Evaluation](https://developer.apple.com/library/content/technotes/tn2232/"
"_index.html).\n"
msgstr ""
"\n"
"安全なインターネット接続の背景については、[HTTPS Server Trust\n"
"Evaluation](https://developer.apple.com/library/content/technotes/tn2232/"
"_index.html)を参照してください。\n"

#: vulnerabilities.py:3443
msgid "Insecure Hashing Algorithms"
msgstr "安全でないハッシュアルゴリズム"

#: vulnerabilities.py:3444
msgid "Are any insecure hash functions used?"
msgstr "安全でないハッシュ関数が使用されていませんか？"

#: vulnerabilities.py:3445
msgid "No insecure hash functions are used."
msgstr "安全でないハッシュ関数は使用していません。"

#: vulnerabilities.py:3446 vulnerabilities.py:3623
msgid ""
"\n"
"The MD5 algorithm is commonly used hash function producing a 128-bit hash "
"value.\n"
"MD5 was designed to be used as a cryptographic hash function, but can be "
"used as\n"
"a checksum to verify data integrity against unintentional corruption. "
"However, MD5\n"
"can be reversed by a brute-force attack and suffers from extensive "
"vulnerabilities.\n"
msgstr ""
"\n"
"MD5アルゴリズムは、一般に128ビットのハッシュ値を生成するハッシュ関数で使用さ"
"れます。MD5は暗号化ハッシュ関数として使用するように設計されていますが、意図し"
"ない破損に対するデータの整合性を確認するためのチェックサムとして使用できま"
"す。しかし、MD5はブルートフォース攻撃を受けることもあり、広範な脆弱性に悩まさ"
"れています。\n"

#: vulnerabilities.py:3452
msgid ""
"\n"
"Using cryptographically insecure hash function algorithms may severely "
"compromise\n"
"the integrity of data.\n"
msgstr ""
"\n"
"暗号で安全でないハッシュ関数アルゴリズムを使用すると、データの完全性が著しく"
"損なわれる可能性があります。\n"

#: vulnerabilities.py:3456
msgid ""
"\n"
"Using salted MD5 for passwords is a bad idea. Not because of MD5's "
"cryptographic\n"
"weaknesses, but because it is fast. This means that an attacker can try "
"billions\n"
"of candidate passwords per second on a single GPU. (See [Dangers of Weak "
"Hashes](https://www.sans.org/reading-room/whitepapers/authentication/dangers-"
"weak-hashes-34412))\n"
"\n"
"Using MD5 for file integrity may or may not be a practical problem, "
"depending on\n"
"the exact usage scenario. The attacks against MD5 are collision attacks, "
"not\n"
"pre-image attacks. This means an attacker can produce two files with the "
"same\n"
"hash, if they have control over both of them. But they can't match the hash "
"of\n"
"an existing file they didn't influence.\n"
"\n"
"Although SHA1 remains the world's widely used hashing algorithm, with Git "
"and\n"
"GnuPG relying on it for data integrity, it was recently\n"
"[proven](https://shattered.io/static/shattered.pdf) to be susceptible to "
"collision attacks.\n"
msgstr ""
"\n"
"salted MD5 をパスワードに使用するのは推奨しません。MD5の暗号の脆弱さではな"
"く、問題は速さです。つまり、攻撃者は1つのGPUで毎秒数十億のパスワード候補を試"
"すことができます。（弱いハッシュの危険性 [Dangers of Weak Hashes](https://"
"www.sans.org/reading-room/whitepapers/authentication/dangers-weak-"
"hashes-34412)）を参照してください）\n"
"\n"
"MD5をファイルの完全性のために使用することは、実際の使用のシナリオに応じて、実"
"用的な問題である場合とそうでない場合があります。 MD5に対する攻撃は、原像攻撃"
"ではなく衝突攻撃です。 これは、攻撃者が同じハッシュを持つ2つのファイルを作成"
"できることを意味します。 しかし、影響を与えていない既存のファイルのハッシュと"
"一致することはできません。\n"
"\n"
"Git および GnuPG がデータの整合性に頼っていたりとSHA1は世界的に広く使用されて"
"いるハッシュアルゴリズムでありながら、衝突攻撃の影響を受けやすいことが最近[証"
"明](https://shattered.io/static/shattered.pdf)されています。\n"

#: vulnerabilities.py:3471
msgid ""
"\n"
"**For passwords**, deliberately slow hash constructions, such as scrypt, "
"bcrypt and\n"
"PBKDF2 should be used. Simple salted SHA-2 is not good enough because, like "
"most\n"
"general purpose hashes, it is fast. ([How to securely hash passwords]"
"(https://security.stackexchange.com/questions/211/how-to-securely-hash-"
"passwords))\n"
"\n"
"**For file integrity**, the current best solution is SHA-2 (SHA-256). Once "
"SHA-3 gets\n"
"standardized it will be a good choice too.\n"
msgstr ""
"\n"
"**パスワードの場合**、scrypt、bcrypt、PBKDF2など意図的に遅いハッシュ構造を使"
"用する必要があります。slted SHA-2は、ほとんどの汎用ハッシュのように高速ですの"
"で、十分ではありません。([パスワードを安全にハッシュする方法](https://"
"security.stackexchange.com/questions/211/how-to-securely-hash-passwords))\n"
"\n"
"**ファイルの完全性の場合**、現在の最良のソリューションはSHA-2です"
"（SHA-256）。SHA-3が標準化されると同様に良い選択となります。\n"

#: vulnerabilities.py:3488
msgid "One Time Password Bypass"
msgstr "ワンタイムパスワードのバイパス"

#: vulnerabilities.py:3489
msgid "Is the application vulnerable to One Time Password Bypass?"
msgstr "アプリケーションはワンタイムパスワードのバイパスに対して脆弱ですか?"

#: vulnerabilities.py:3490
msgid "Application is not vulnerable to One Time Password Bypass."
msgstr ""
"アプリケーションはワンタイムパスワードのバイパスに対して脆弱ではありません。"

#: vulnerabilities.py:3491
msgid ""
"\n"
"A one-time password (OTP) is a password that is valid for only one login "
"session or transaction.\n"
"OTPs avoid a number of shortcomings that are associated with traditional "
"(static) password-based authentication;\n"
"a number of implementations also incorporate two factor authentication by "
"ensuring that the one-time password\n"
"requires access to something a person has (such as a small keyring fob "
"device with the OTP calculator built\n"
"into it, or a smartcard or specific cellphone) as well as something a person "
"knows (such as a PIN).\n"
msgstr ""
"\n"
"ワンタイムパスワード（OTP）は、1つのログインセッションまたはトランザクション"
"に対してのみ有効なパスワードです。OTPは、従来の（静的な）パスワードベースの認"
"証に関連する多くの欠点を回避することができます。いくつかの実装例としては、ワ"
"ンタイムパスワードに、その人が持っているものや、（OTP電卓を内蔵した小さなキー"
"リングFOBデバイス、スマートカードまたは特定の携帯電話など）その人が知っている"
"もの（PINなど）へのアクセスが必要であることを保証することで2要素認証を組み込"
"みます。\n"

#: vulnerabilities.py:3498
msgid ""
"\n"
"We used following approaches to check if the OTP could be bypassed:\n"
"\n"
"- Check if the generated OTP can be re-generated by breaking into the logic "
"of how an OTP is generated\n"
"- Check if the OTP challenge is present in the client side, which includes "
"in response body or stored in filesystem layer or in the memory layer\n"
"- Check if an older OTP can be re-used again in the future transaction\n"
"- Check the randomness of the OTP\n"
"- Check if the OTP could be brute-forced by requesting wrong OTP until a "
"correct OTP can be verified\n"
"- Check the expiry time of a generated OTP\n"
"- Check the number of wrong attempts accepted to verify an OTP\n"
"\n"
msgstr ""

#: vulnerabilities.py:3521
msgid "Insecure Direct Object Reference"
msgstr "安全でない直接オブジェクト参照"

#: vulnerabilities.py:3522
msgid "Do Insecure Direct Object References exist within the app?"
msgstr "安全でない直接オブジェクト参照が存在していませんか?"

#: vulnerabilities.py:3523
msgid "No occurences of Insecure Direct Object References were found."
msgstr "安全でない直接オブジェクト参照は見つかりませんでした。"

#: vulnerabilities.py:3524
msgid ""
"\n"
"Insecure Direct Object References occur when an application provides direct "
"access to objects based on user-supplied input.\n"
"As a result of this vulnerability, attackers can bypass authorisation and "
"access resources in the system directly, by modifying\n"
"the value of a parameter used to point to an object. Such resources can be "
"database entries belonging to other users, files in the system, or others.\n"
"This is caused by the fact that the application takes user supplied input "
"and uses it to retrieve an object without performing sufficient "
"authorisation checks.\n"
msgstr ""
"\n"
"安全でないダイレクト·オブジェクト参照は、アプリケーションがユーザー指定の入力"
"に基づいてオブジェクトに直接アクセスできる場合に発生します。この脆弱性の結果"
"として、攻撃者は、オブジェクトを指すために使用されるパラメータの値を変更する"
"ことによって、システム内の承認およびアクセスリソースを直接バイパスすることが"
"できる可能性があります。そのようなリソースは、他のユーザーに属するデータベー"
"スエントリ、システム内のファイル、またはその他のものもあり得ます。これは、ア"
"プリケーションがユーザー指定の入力を受け取り、十分な許可チェックを実行せずに"
"オブジェクトを取得し使用するために発生します。\n"

#: vulnerabilities.py:3530
msgid ""
"\n"
"To test for this vulnerability, all locations in the application need to be "
"mapped where user input is used to reference objects directly.\n"
"For example, locations where user input is used to access a database row, a "
"file or even an application page.\n"
"Next, the value of the parameter used to reference objects is modified and "
"assessed whether it is possible to\n"
"retrieve objects belonging to other users or otherwise bypass "
"authorisation.\n"
msgstr ""

#: vulnerabilities.py:3548
msgid ""
"Does the application use Transport Layer protection? Is HTTPS enabled "
"globally in the application?"
msgstr ""
"アプリケーションはトランスポート層の保護を使用していますか?HTTPSはアプリケー"
"ション内全体で有効になっていますか？"

#: vulnerabilities.py:3549
msgid ""
"Application has SSL enabled and sufficient protection is being used to "
"prevent information leakage."
msgstr ""
"アプリケーションでSSLが有効になっており、情報漏洩を防止するために十分な保護が"
"使用されています。"

#: vulnerabilities.py:3576
msgid ""
"\n"
"When making network transmissions, all connections should strictly use TLS.\n"
"\n"
"Never use just an HTTP connection to upload/download data. Instead, create "
"an HTTPS\n"
"request to perform transmission.\n"
msgstr ""
"\n"
"ネットワーク伝送を行う場合、すべての接続で厳密にTLSを使用する必要があります。"
"データのアップロード/ダウンロードにはHTTP接続を使用しないでください。代わり"
"に、HTTPS要求を作成して送信します。\n"

#: vulnerabilities.py:3591
msgid "Short HMAC Keys"
msgstr "短いHMAC鍵"

#: vulnerabilities.py:3592
msgid "Are keys used to calculate HMAC too short?"
msgstr "HMACの計算に使用される鍵は短すぎていませんか？"

#: vulnerabilities.py:3593
msgid "Keys used to calculate HMAC, if any, are of recommended length."
msgstr "HMACを計算するために使用される鍵がある場合は、推奨される長さです。"

#: vulnerabilities.py:3594
msgid ""
"\n"
"An HMAC (keyed-hash message authentication code) is a type of message "
"authentication\n"
"code used to simultaneously verify both the data integrity and the "
"authentication of a message.\n"
"Any cryptographic hash function, such as MD5 or SHA-1, may be used in the "
"calculation of an HMAC;\n"
"the resulting MAC algorithm is termed HMAC-MD5 or HMAC-SHA-1 accordingly.\n"
"The cryptographic strength of the HMAC depends upon the cryptographic "
"strength of the underlying\n"
"hash function, the size of its hash output, and on the size and quality of "
"the key.\n"
msgstr ""
"\n"
"HMAC（キー付きハッシュ·メッセージ認証コード）は、データの完全性とメッセージの"
"認証の両方を同時に検証するために使用されるメッセージ認証コードの一種です。MD5"
"やSHA-1などの暗号ハッシュ関数は、HMACの計算に使用できます。得られたMACアルゴ"
"リズムは、それに応じてHMAC-MD5またはHMAC-SHA-1と呼ばれます。HMACの暗号強度"
"は、基礎となるハッシュ関数の暗号強度、ハッシュ出力のサイズ、およびキーのサイ"
"ズと品質に依存します。\n"

#: vulnerabilities.py:3602
msgid ""
"\n"
"The key for HMAC can be of any length. However, less than 32 bytes is "
"strongly discouraged\n"
"as it would decrease the security strength of the function. Keys longer than "
"64 bytes are acceptable\n"
"but the extra length would not significantly increase the function "
"strength.\n"
"A longer key may be advisable if the randomness of the key is considered "
"weak.\n"
msgstr ""
"\n"
"HMACの鍵はどの長さにもすることができます。ただし、機能のセキュリティ強度を低"
"下させるので、32バイト未満は強く推奨されていません。64バイトより長い鍵は許容"
"されますが、余分な長さでは機能強度が大幅に向上しません。鍵のランダム性が弱い"
"と考えられる場合は、より長い鍵を使用することをお勧めします。\n"

#: vulnerabilities.py:3608
msgid ""
"Loss of HMAC security may compromise the integrity and authenticity of the "
"data maintained."
msgstr ""
"HMACセキュリティの喪失は、管理されるデータの完全性と信頼性を損なう可能性があ"
"ります。"

#: vulnerabilities.py:3620
msgid "Vulnerable Hash Algorithms"
msgstr "脆弱なハッシュアルゴリズム"

#: vulnerabilities.py:3621
msgid "Are any deprecated or vulnerable hash algorithms used?"
msgstr "非推奨または脆弱なハッシュアルゴリズムが使用されていませんか？"

#: vulnerabilities.py:3622
msgid "No deprecated or vulnerable hash algorithms are being used."
msgstr "非推奨、または脆弱なハッシュアルゴリズムは使用されていません。"

#: vulnerabilities.py:3629
msgid ""
"\n"
"Using salted MD5 for passwords should be avoided, not because of its "
"cryptographic\n"
"weaknesses, but because it is fast. An attacker can try billions of "
"candidate passwords\n"
"per second on a single GPU.\n"
"\n"
"Using MD5 for file integrity may or may not be a practical problem, "
"depending on\n"
"the exact usage scenario. The attacks against MD5 are collision attacks, "
"not\n"
"pre-image attacks which means an attacker can produce two files with the "
"same\n"
"hash, if they have control over both of them. However, they cannot match the "
"hash of\n"
"an existing file they didn't influence.\n"
"\n"
"Although SHA1 remains the world's widely used hashing algorithm with Git "
"and\n"
"GnuPG relying on it for data integrity, it has [also been proven](https://"
"shattered.io/static/shattered.pdf)\n"
"to be susceptible to collision attacks.\n"
msgstr ""
"\n"
"パスワードにソルトしたMD5を使用するのは避けてください。理由としては、暗号化の"
"弱点ではなく速いためです。\n"
"攻撃者はシングルCPU上で毎秒数十億個の候補パスワードを試すことができます。\n"
"\n"
"ファイルの整合性のためにMD5を使用することは、実際の使用シナリオに応じて、実際"
"問題になったり、ならなかったりします。MD5に対する攻撃は、もし攻撃者が両方の攻"
"撃をコントロールしている場合は、攻撃者が同じハッシュを持つ2つのファイルを作成"
"するプリイメージ攻撃ではなく、衝突攻撃になります。\n"
"ただし、影響を受けていない既存のファイルのハッシュと一致することはできませ"
"ん。\n"
"\n"
"SHA1はデータの整合性のためにGitとGnuPGで広く使われているハッシングアルゴリズ"
"ムのままですが、\n"
"衝突攻撃の影響を受けやすいことも [証明](https://shattered.io/static/"
"shattered.pdf)されています。\n"

#: vulnerabilities.py:3644
msgid ""
"\n"
"Using cryptographically weak hash function algorithms may severely "
"compromise the integrity of data.\n"
msgstr ""
"\n"
"暗号で安全でないハッシュ関数アルゴリズムを使用すると、データの完全性が著しく"
"損なわれる可能性があります。\n"

#: vulnerabilities.py:3648
msgid ""
"\n"
"**For passwords**, deliberately slow hash constructions such as scrypt, "
"bcrypt and\n"
"PBKDF2 should be used. Simple salted SHA2 is not good enough because, like "
"most\n"
"general purpose hashes, it is fast.\n"
"\n"
"**For file integrity**, the current best solution is SHA-2 (SHA-256). SHA-3 "
"will also be\n"
"a good choice once it gets standardised.\n"
msgstr ""
"\n"
"**パスワード**では、scrypt、bcrypt、PBKDF2などの意図的に遅いハッシュ構造を使"
"用する必要があります。ソルト付きSHA2は、一般的な目的のハッシュと同様、高速の"
"ため十分ではありません。**ファイルの完全性**の場合、現在の最良のソリューショ"
"ンはSHA-2（SHA-256）です。SHA-3は、標準化されると良い選択になるでしょう。\n"

#: vulnerabilities.py:3665
msgid "General Server Vulnerabilities"
msgstr "一般的なサーバの脆弱性"

#: vulnerabilities.py:3666
msgid "Are any general server vulnerabilities present?"
msgstr "一般的なサーバの脆弱性はありませんか?"

#: vulnerabilities.py:3667
msgid "No general server vulnerabilities were found."
msgstr "一般的なサーバの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3668
msgid ""
"\n"
"This issue is not specific to a certain kind of vulnerabilities. It can be "
"raised as\n"
"a result of many different types of attacks and might indicate some server-"
"side\n"
"fault that may lead to further vulnerabilities\n"
"\n"
"When an attacker explores a web site looking for vulnerabilities, the amount "
"of\n"
"information that the site provides is crucial to the eventual success or "
"failure\n"
"of any attempted attacks. If the application shows the attacker a stack "
"trace,\n"
"it relinquishes information that makes the attacker's job significantly "
"easier.\n"
"For example, a stack trace might show the attacker a malformed SQL query "
"string,\n"
"the type of database being used, and the version of the application "
"container.\n"
"This information enables the attacker to target known vulnerabilities in "
"these components.\n"
"\n"
"The application configuration should specify a default error page in order "
"to\n"
"guarantee that the application will never leak error messages to an "
"attacker.\n"
"Handling standard HTTP error codes is useful and user-friendly in addition "
"to\n"
"being a good security practice, and a good configuration will also define a\n"
"last-chance error handler that catches any exception that could possibly be\n"
"thrown by the application.\n"
msgstr ""
"\n"
"この問題は特定の種類の脆弱性に固有の問題ではありません。多くの異なる種類の攻"
"撃の結果として発生し得る問題であり、さらなる脆弱性を引き起こす可能性のある"
"サーバー側の障害を示しているとも考えられます。\n"
"\n"
"攻撃者が脆弱性を探してWebサイトを調査すると、そのサイトが提供する情報量は、試"
"みられた攻撃の成功または失敗に不可欠です。 アプリケーションがスタックトレース"
"を攻撃者に見せた場合、攻撃者の仕事を著しく容易にする情報を放棄します。\n"
"たとえば、スタックトレースでは、不正な形式のSQLクエリ文字列、使用されている"
"データベースの種類、およびアプリケーションコンテナのバージョンが攻撃者に表示"
"されることがあります。\n"
"この情報により、攻撃者はこれらのコンポーネントの既知の脆弱性を標的にすること"
"ができます。\n"
"\n"
"アプリケーション構成では、アプリケーションがエラーメッセージを攻撃者に漏らさ"
"ないことを保証するために、デフォルトのエラーページを指定する必要があります。"
"標準のHTTPエラーコードを処理することは、セキュリティ上の慣習に加えて、便利で"
"使いやすいです。また、適切な構成では、アプリケーションによってスローされる可"
"能性のある例外をすべて検出するラストチャンスエラーハンドラも定義されます。\n"

#: vulnerabilities.py:3688
msgid ""
"\n"
"The API may be susceptible to general server vulnerabilities, which can lead "
"to\n"
"further attacks\n"
msgstr ""
"\n"
"APIは一般的なサーバの脆弱性の影響を受けやすく、更なる攻撃に繋がる可能性があり"
"ます。\n"

#: vulnerabilities.py:3704
msgid "Buffer Overflow Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおけるバッファオーバーフローの脆弱性"

#: vulnerabilities.py:3705
msgid "Did buffer overflows occur in HTTP requests?"
msgstr "HTTPリクエストでバッファオーバーフローが発生しましたか?"

#: vulnerabilities.py:3706
msgid "Buffer overflow vulnerabilities were not detected in HTTP request."
msgstr ""
"HTTPリクエストにおけるバッファオーバーフローの脆弱性は検出されませんでした。"

#: vulnerabilities.py:3707
msgid ""
"\n"
"A buffer overflow occurs when a program attempts to put more data in a "
"buffer than\n"
"it can hold or when a program attempts to put data in a memory area past a "
"buffer.\n"
"In this case, a buffer is a sequential section of memory allocated to "
"contain anything\n"
"from a character string to an array of integers. Writing outside the bounds "
"of a\n"
"block of allocated memory can corrupt data, crash the program, or cause the "
"execution of malicious code.\n"
"\n"
"Attackers use buffer overflows to corrupt the execution stack of a web "
"application.\n"
"By sending carefully crafted input to a web application, an attacker can "
"cause the\n"
"web application to execute arbitrary code.\n"
"\n"
"Buffer overflow flaws can be present in both the web server or application "
"server\n"
"products that serve the static and dynamic aspects of the site, or the web "
"application itself.\n"
msgstr ""
"\n"
"バッファオーバーフローは、プログラムが保持できる以上のデータをバッファに格納"
"しようとしたとき、またはプログラムがバッファを過ぎたメモリ領域にデータを格納"
"しようとしたときに発生します。\n"
"この場合、バッファは、文字列から整数の配列までを含むように割り当てられたメモ"
"リのシーケンシャルセクションです。\n"
"割り当てられたメモリブロックの範囲外に書き込むと、データが破損したり、プログ"
"ラムがクラッシュしたり、悪意のあるコードが実行されたりする可能性がありま"
"す。\n"
"\n"
"攻撃者はバッファオーバーフローを使用してWebアプリケーションの実行スタックを破"
"損させます。慎重に細工されたインプットをWebアプリケーションに送信することによ"
"り、攻撃者はWebアプリケーションに任意のコードを実行させることができます。\n"
"\n"
"バッファオーバーフローの脆弱性は、サイトの静的および動的な側面、またはWebアプ"
"リケーション自体に役立つWebサーバーまたはアプリケーションサーバー製品の両方に"
"存在する可能性があります。\n"

#: vulnerabilities.py:3721
msgid ""
"\n"
"One or more API requests may be vulnerable to Buffer overflow issues\n"
msgstr ""
"\n"
"1つまたは複数のAPIリクエストがバッファオーバーフローの問題に対して脆弱である"
"可能性があります。\n"

#: vulnerabilities.py:3724
msgid ""
"\n"
"- Buffer overflows generally lead to crashes. Other attacks leading to lack "
"of\n"
"  availability are possible, including putting the program into an infinite "
"loop.\n"
"- Buffer overflows often can be used to execute arbitrary code, which is "
"usually\n"
"  outside the scope of a program’s implicit security policy.\n"
"- When the consequence is arbitrary code execution, this can often be used "
"to\n"
"  subvert any other security service.\n"
msgstr ""
"\n"
"- 一般的には、バッファオーバーフローはクラッシュにつながります。プログラムを"
"無限ループにするなど、可用性の欠如につながる他の攻撃も可能です。 \n"
"- バッファオーバーフローは、通常、プログラムの暗黙のセキュリティポリシーの範"
"囲外にある任意のコードを実行するために使用されます。\n"
"- 任意のコード実行は、他のセキュリティサービスを破壊するために使用されること"
"がよくあります。\n"

#: vulnerabilities.py:3743
msgid "Command Injection Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおけるコマンドインジェクションの脆弱性"

#: vulnerabilities.py:3744
msgid "Are there command injection vulnerabilities in HTTP request?"
msgstr "HTTPリクエストにコマンドインジェクションの脆弱性はありませんか？"

#: vulnerabilities.py:3745
msgid "No command injection vulnerabilities in HTTP request were found."
msgstr ""
"HTTPリクエストにコマンドインジェクションの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3746
msgid ""
"\n"
"Command injection is an attack in which the attacker attempts execution of "
"arbitrary commands\n"
"on the host operating system via a vulnerable application. This attack "
"differs from Code Injection,\n"
"in that code injection allows the attacker to add his own code that is then "
"executed by the application.\n"
"In Code Injection, the attacker extends the default functionality of the "
"application\n"
"without the necessity of executing system commands.\n"
"\n"
"Command injection attacks are possible when an application passes unsafe "
"user supplied data\n"
"(forms, cookies, HTTP headers etc.) to a system shell. The attacker-"
"supplied\n"
"operating system commands are usually executed with the privileges of the "
"vulnerable application.\n"
"Command injection attacks are possible largely due to insufficient input "
"validation.\n"
msgstr ""
"\n"
"コマンドインジェクションは、攻撃者が脆弱なアプリケーションを経由して、ホスト"
"オペレーティングシステム上で任意のコマンドを実行しようとする攻撃です。\n"
"この攻撃はコードインジェクションとは異なります。\n"
"コードインジェクションでは、攻撃者が独自のコードを追加してアプリケーションで"
"実行することができます。攻撃者はシステムコマンドを実行することなく、アプリ"
"ケーションのデフォルト機能を拡張します。\n"
"\n"
"コマンドインジェクション攻撃は、アプリケーションが安全でないユーザー指定の"
"データ（フォーム、Cookie、HTTPヘッダーなど）を system shell に渡すときに可能"
"です。攻撃者指定のオペレーティングシステムコマンドは通常、脆弱なアプリケー"
"ションの特権で実行されます。コマンドインジェクション攻撃は、入力の検証が不十"
"分なことが主な原因です。\n"

#: vulnerabilities.py:3758
msgid ""
"\n"
"One or more API requests were found to be vulnerable to command injection "
"vulnerabilities\n"
msgstr ""
"\n"
"1つまたは複数のAPIリクエストがコマンドインジェクションの脆弱性に対して脆弱で"
"ある可能性があります。\n"

#: vulnerabilities.py:3773
msgid "Integer Overflow Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおける整数オーバーフローの脆弱性"

#: vulnerabilities.py:3774
msgid "Are there integer overflow vulnerabilities in HTTP request?"
msgstr "HTTPリクエストに整数オーバーフローの脆弱性はありませんか？"

#: vulnerabilities.py:3775
msgid "No integer overflow vulnerabilities were found in HTTP request."
msgstr ""
"HTTPリクエストにおける整数オーバーフローの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3776
msgid ""
"\n"
"An integer overflow occurs when the result of an arithmetic operation "
"exceeds the maximum size\n"
"of the integer data type used to store it. When an integer overflow occurs, "
"the calculated value\n"
"will wrapped around the maximum value allowed by the data structure and "
"start from the minimum value.\n"
"\n"
"Attackers use integer overflows to corrupt the data stack of the web "
"application.\n"
"By sending carefully crafted input to the server, an attacker can cause the "
"data corruption.\n"
"Attackers can use these defects to influence the value of variables in ways "
"that the application is not meant\n"
"to.\n"
msgstr ""
"\n"
"整数オーバーフローは、整数演算の結果が整数を格納するために使用される整数デー"
"タ型の最大サイズを超えると発生します。整数のオーバーフローが発生すると、計算"
"された値はデータ構造によって許容される最大値にラップされ、最小値から開始しま"
"す。攻撃者は整数オーバーフローを使用してWebアプリケーションのデータスタックを"
"破損させます。慎重に細工された入力をサーバーに送信することにより、攻撃者は"
"データ破損を引き起こす可能性があります。攻撃者は、これらの欠陥を使用して、ア"
"プリケーションが意図していない方法で変数の値に影響を与えることができます。\n"

#: vulnerabilities.py:3786
msgid ""
"\n"
"The API may be vulnerable to integer overflow issues\n"
msgstr ""
"\n"
"APIは整数オーバーフローの問題に対して脆弱である可能性があります。\n"

#: vulnerabilities.py:3789
msgid ""
"\n"
"- An integer overflow during a buffer length calculation can result in "
"allocating a buffer that\n"
"is too small to hold the data to be copied into it. This in turn can cause a "
"buffer overflow when the data is copied.\n"
"- Withdrawing 1 unit from an account with a balance of 0 could cause an "
"integer underflow and yield\n"
"a new balance of 4,294,967,295.\n"
"- A very large positive number in a transaction could be cast as a signed "
"integer by backend. The interpreted value\n"
"could become a negative number and reverse the direction of the "
"transaction.\n"
msgstr ""
"\n"
"- バッファ長の計算中に整数オーバーフローが発生すると、コピーするデータを保持"
"するには小さすぎるバッファが割り当てられる可能性があります。 \n"
"- これにより、データがコピーされるときにバッファオーバーフローが発生する可能"
"性があります。 \n"
"- 残高が0のアカウントから1単位を引き出した場合、整数アンダーフローが発生し、"
"新しい残高が4,294,967,295になる可能性があります。 \n"
"- トランザクションの非常に大きな正の数は、バックエンドによって符号付き整数と"
"してキャストできます。解釈された値は負の数になり、トランザクションの方向を反"
"転させる可能性があります。\n"

#: vulnerabilities.py:3808
msgid "JSON Depth Overflow in HTTP Requests"
msgstr "HTTPリクエストにおけるJSON深度オーバーフロー"

#: vulnerabilities.py:3809
msgid "Are there JSON depth overflows in HTTP requests?"
msgstr "HTTPリクエストにJSON深度オーバーフローはありませんか？"

#: vulnerabilities.py:3810
msgid "No JSON depth overflows were found in HTTP request."
msgstr "HTTPリクエストにおけるJSON深度オーバーフローは見つかりませんでした。"

#: vulnerabilities.py:3811
msgid ""
"\n"
"Altough JSON is intended as a data serialization format, its design as a\n"
"non-strict subset of the JavaScript scripting language poses several "
"security\n"
"concerns, which are centered on the use of a JavaScript interpreter to "
"execute\n"
"JSON text dynamically as embedded JavaScript. This easy and popular but "
"risky\n"
"technique exploits JSON's compatibility with the JavaScript `eval()` "
"function.\n"
"It is possible that the JSON parser will reach depth limit and crash,\n"
"resulting in a successful overflow of the JSON parsers depth limit, leading\n"
"to a DoS vulnerability.\n"
msgstr ""
"\n"
"JSONはデータのシリアライズフォーマットを意図していますが、JavaScriptスクリプ"
"ト言語の厳密でないサブセットとしてのデザインは、JSON テキストを埋め込み"
"JavaScriptとして動的に実行するための JavaScript インタプリタの使用を中心とす"
"るいくつかのセキュリティ上の問題を提起します。この簡単で一般的ではありながら"
"危険な手法は、JSONとJavaScriptのeval（）関数との互換性を利用しています。JSON"
"パーサが深さ制限とクラッシュに達し、深さ制限がオーバーフローし、DoSの脆弱性が"
"発生する可能性があります。\n"

#: vulnerabilities.py:3821
msgid ""
"\n"
"The JSON parser used by the API may be vulnerable to depth overflow issues\n"
msgstr ""
"\n"
"APIで使用されるJSONパーサは、深度オーバーフローの問題に脆弱である可能性があり"
"ます。\n"

#: vulnerabilities.py:3836
msgid "LDAP Injection Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにLDAPインジェクションの脆弱性"

#: vulnerabilities.py:3837
msgid "Are there LDAP injection vulnerabilities in HTTP request?"
msgstr "HTTPリクエストにLDAPインジェクションの脆弱性はありませんか？"

#: vulnerabilities.py:3838
msgid "No LDAP injection vulnerabilities were found in HTTP request."
msgstr "HTTPリクエストにLDAPインジェクションの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3839
msgid ""
"\n"
"LDAP injection is an attack used to exploit web based applications that "
"construct\n"
"LDAP statements based on user input. When an application fails to properly\n"
"sanitize user input, it is possible to modify LDAP statements using a local "
"proxy.\n"
"This could result in the execution of arbitrary commands such as granting "
"permissions\n"
"to unauthorized queries, and content modification inside the LDAP tree. The "
"same\n"
"advanced exploitation techniques available in SQL injection can be "
"similarly\n"
"applied in LDAP injection.\n"
msgstr ""
"\n"
"LDAPインジェクションは、ユーザーの入力に基づいてLDAPステートメントを構築する"
"Webベースのアプリケーションを悪用するために使用される攻撃です。アプリケーショ"
"ンがユーザー入力を適切にサニタイズできない場合、ローカルプロキシを使用して"
"LDAPステートメントを変更することができます。\n"
"これにより、権限のないクエリへのアクセス許可やLDAPツリー内のコンテンツの変更"
"など、任意のコマンドが実行される可能性があります。SQLインジェクションで利用で"
"きる高度なエクスプロイト手法は、LDAPインジェクションでも同様に適用できま"
"す。\n"

#: vulnerabilities.py:3848
msgid ""
"\n"
"The API may be vulnerable to LDAP injection\n"
msgstr ""
"\n"
"APIはLDAPインジェクションに対して脆弱である可能性があります。\n"

#: vulnerabilities.py:3863
msgid "Regex DoS Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおけるRegex DoSの脆弱性"

#: vulnerabilities.py:3864
msgid "Are there Regex DoS vulnerabilities in HTTP requests?"
msgstr "HTTPリクエストにRegex DoSの脆弱性はありませんか？"

#: vulnerabilities.py:3865
msgid "No Regex DoS vulnerabilities were found in HTTP request."
msgstr "HTTPリクエストにRegex DoSの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3866
msgid ""
"\n"
"The Regular Expression Denial of Service (ReDoS) is a Denial of Service "
"attack,\n"
"that exploits the fact that most Regular Expression implementations may "
"reach\n"
"extreme situations that cause them to work very slowly (exponentially "
"related\n"
"to input size). An attacker can then cause a program using a regular "
"expression\n"
"to enter these extreme situations and then hang for a very long time.\n"
msgstr ""
"\n"
"正規表現を使ったサービス拒否（ReDoS）はサービス拒否攻撃であり、ほとんどの正規"
"表現の実装が非常にゆっくりと動作する（入力サイズに指数関数的に関係する）極端"
"な状況に達する可能性があるという点を利用しています。攻撃者は、正規表現を使用"
"しているプログラムにこれらの極端な状況を入力させ、それにより非常に長い時間ハ"
"ングする可能性があります。\n"

#: vulnerabilities.py:3873
msgid ""
"\n"
"Instances of Regex DoS vulnerabilities were found in API requests\n"
msgstr ""
"\n"
"Regex DoSの脆弱性のインスタンスが、APIリクエストに検出されました。\n"

#: vulnerabilities.py:3888
msgid "SQL Injection Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおけるSQLインジェクションの脆弱性"

#: vulnerabilities.py:3889
msgid "Are there SQL injection vulnerabilities in HTTP request?"
msgstr "HTTPリクエストにSQLインジェクションの脆弱性はありませんか？"

#: vulnerabilities.py:3890
msgid "No SQL injection vulnerabilities were found in HTTP request."
msgstr ""
"HTTPリクエストにおけるSQLインジェクションの脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3891
msgid ""
"\n"
"A SQL injection attack consists of insertion or _injection_ of a SQL query "
"via\n"
"the input data from the client to the application. A successful SQL "
"injection\n"
"exploit can read sensitive data from the database, modify database data\n"
"(Insert/Update/Delete), execute administration operations on the database\n"
"(such as shutdown the DBMS), recover the content of a given file present on "
"the\n"
"DBMS file system and in some cases issue commands to the operating system.\n"
"SQL injection attacks are a type of injection attack, in which SQL commands "
"are\n"
"injected into data-plane input in order to effect the execution of "
"predefined SQL commands.\n"
msgstr ""
"\n"
"SQLインジェクション攻撃は、クライアントからアプリケーションへの入力データを介"
"したSQLクエリの挿入または注入で構成されます。\n"
"成功したSQLインジェクション攻撃は、データベースから機密データを読み込み、デー"
"タベースのデータを変更（挿入/更新/削除）し、データベースの管理操作を実行し"
"（DBMSをシャットダウンするなど）、DBMSファイルに存在する特定のファイルの内容"
"を回復します。\n"
"一部のケースではオペレーティングシステムにコマンドを発行します。SQLインジェク"
"ション攻撃は、事前定義されたSQLコマンドの実行を行うために、SQLコマンドがデー"
"タプレーン入力に注入されるインジェクション攻撃の一種です。\n"

#: vulnerabilities.py:3901
msgid ""
"\n"
"One or more API requests were found to be vulnerable to SQL injection\n"
msgstr ""
"\n"
"1つまたは複数のAPIリクエストがSQLインジェクションに対して脆弱であることが判明"
"しました。\n"

#: vulnerabilities.py:3917
msgid "Is PhoneGap debug logging enabled?"
msgstr "PhoneGapのデバッグログの出力は有効になっていますか？"

#: vulnerabilities.py:3918
msgid ""
"PhoneGap debug logging was found to be disabled or PhoneGap is not being "
"used."
msgstr ""
"PhoneGapのデバッグログの出力は無効になっているか、もしくはPhoneGapは使用され"
"ていません。"

#: vulnerabilities.py:3919
msgid ""
"\n"
"If a PhoneGap app is shipped with debug mode switched on, it can allow "
"anyone to\n"
"attach a debugger and change the logical flow of the app. Sensitive logs "
"get\n"
"leaked which can be used to determine the URL endpoints of the application.\n"
msgstr ""
"\n"
"PhoneGapアプリをデバッグモードをオンにして出荷すると、誰でもデバッガに接続し"
"てアプリの論理フローを変更できるようになります。機密ログが漏洩し、アプリケー"
"ションのURLエンドポイントを特定するために使用できます。\n"

#: vulnerabilities.py:3924
msgid ""
"\n"
"When using PhoneGap, disable debug logs before shipping the app.\n"
msgstr ""
"\n"
"PhoneGapを使用する場合は、アプリを出荷する前にデバッグログを無効にしてくださ"
"い。\n"

#: vulnerabilities.py:3927
msgid ""
"\n"
"If a PhoneGap app is shipped with debug mode switched on, it can allow "
"anyone\n"
"to attach a debugger and change the logical flow of the app. Sensitive logs "
"get\n"
"leaked which can be used to determine the URL endpoints of the application.\n"
msgstr ""
"\n"
"PhoneGapアプリをデバッグモードをオンにして出荷すると、誰でもデバッガに接続し"
"てアプリの論理フローを変更できるようになります。機密ログが漏洩し、アプリケー"
"ションのURLエンドポイントを特定するために使用できます。\n"

#: vulnerabilities.py:3932
msgid ""
"\n"
"If using Cordova, please publish the plugin using\n"
"\n"
"    cordova build ios --release\n"
"\n"
"If using PhoneGap, please turn of all `console.logs()` and other logging\n"
"code before publishing.\n"
msgstr ""
"\n"
"If using Cordova, please publish the plugin using\n"
"\n"
"    cordova build ios --release\n"
"\n"
"PhoneGapを使用している場合は、公開前に `console.logs（）`と他のログコードを有"
"効にしてください。\n"

#: vulnerabilities.py:3950
msgid "String Validation Vulnerabilities in HTTP Requests"
msgstr "HTTPリクエストにおける文字列検証の脆弱性"

#: vulnerabilities.py:3951
msgid "Are there string validation vulnerabilities in HTTP request?"
msgstr "HTTPリクエストに文字列検証の脆弱性はありませんか？"

#: vulnerabilities.py:3952
msgid "No string validation vulnerabilities were found in HTTP requests."
msgstr "HTTPリクエストにおける文字列検証の脆弱性は見つかりませんでした。"

#: vulnerabilities.py:3953
msgid ""
"\n"
"Failure to properly validate input from the client or environment is the "
"most\n"
"common web application security weakness. This leads to almost all of the "
"major\n"
"vulnerabilities in applications, such as Interpreter Injection, locale/"
"Unicode attacks,\n"
"file system attacks and buffer overflows. Data from the client should never "
"be\n"
"trusted for the client has every possibility to tamper with the data.\n"
msgstr ""
"\n"
"クライアントまたは環境からの入力を適切に検証できないことは、Webアプリケーショ"
"ンの最も一般的なセキュリティにおける弱点です。これにより、インタープリタイン"
"ジェクション、ロケール/ Unicode攻撃、ファイルシステム攻撃、バッファオーバーフ"
"ローなど、アプリケーションの主な脆弱性のほとんどすべてが発生します。クライア"
"ントからのデータは、データを改ざんされる可能性があるため、信頼されるべきでは"
"ありません。\n"

#: vulnerabilities.py:3960
msgid ""
"\n"
"Appknox found string validation vulnerabilities in one or more HTTP "
"requests\n"
msgstr ""
"\n"
"1つまたは複数のHTTPリクエストに文字列検証の脆弱性が見つかりました。\n"

#: vulnerabilities.py:3975
msgid "XML-external-entity Injection Vulnerabilities in HTTP Body"
msgstr "HTTPボディにおけるXML外部エンティティ(XXE)インジェクションの脆弱性"

#: vulnerabilities.py:3976
msgid "Are there XML-external-entity injection vulnerabilities in HTTP body?"
msgstr ""
"HTTPボディにXML外部エンティティ(XXE)インジェクションの脆弱性はありませんか？"

#: vulnerabilities.py:3977
msgid ""
"No XML-external-entity injection vulnerabilities were found in HTTP body."
msgstr ""
"HTTPボディにおけるXML外部エンティティ(XXE)インジェクションの脆弱性は見つかり"
"ませんでした。"

#: vulnerabilities.py:3978
msgid ""
"\n"
"An XML External Entity Injection is a type of attack against an application "
"that\n"
"parses XML input. This attack occurs when XML input containing a reference "
"to an\n"
"external entity is processed by a weakly configured XML parser. This attack "
"may\n"
"lead to the disclosure of confidential data, denial of service, server side "
"request\n"
"forgery, port scanning from the perspective of the machine where the parser "
"is\n"
"located, and other system impacts.\n"
msgstr ""
"\n"
"XML外部エンティティインジェクションは、XML入力を解析するアプリケーションに対"
"する攻撃の一種です。この攻撃は、外部エンティティへの参照を含むXML入力が、弱く"
"構成されたXMLパーサーによって処理されるときに発生します。この攻撃は、機密デー"
"タの開示、サービス拒否、サーバー側の要求偽装、パーサーが配置されているマシン"
"の観点からのポートスキャン、およびその他のシステムへの影響につながる可能性が"
"あります。\n"

#: vulnerabilities.py:3986
msgid ""
"\n"
"Our scanner detected occurrences of XML-external-entity injection "
"vulnerabilities\n"
"in HTTP body of API calls\n"
msgstr ""
"\n"
"スキャナはAPI呼び出しのHTTPボディにXML外部エンティティ(XXE)インジェクションの"
"脆弱性の発生を検知しました。\n"

#: vulnerabilities.py:4002
msgid "Cross-site-scripting Vulnerabilities in HTTP Body"
msgstr "クロスサイトトレーシング(XST)の脆弱性"

#: vulnerabilities.py:4003
msgid "Are there cross-site-scripting vulnerabilities in HTTP body?"
msgstr "HTTPボディにクロスサイトスクリプティング(XSS)の脆弱性はありませんか？"

#: vulnerabilities.py:4004
msgid "No Cross-site-scripting vulnerabilities were found in HTTP body."
msgstr ""
"HTTPボディにおけるクロスサイトスクリプティング(XSS)の脆弱性は見つかりませんで"
"した。"

#: vulnerabilities.py:4005
msgid ""
"\n"
"Cross-Site Scripting (XSS) attacks are a type of injection, in which "
"malicious\n"
"scripts are injected into otherwise benign and trusted web sites. XSS "
"attacks\n"
"occur when an attacker uses a web application to send malicious code, "
"generally\n"
"in the form of a browser side script, to a different end user. Flaws that "
"allow\n"
"these attacks to succeed are quite widespread and occur anywhere a web "
"application\n"
"uses input from a user within the output it generates without validating or "
"encoding it.\n"
"\n"
"An attacker can use XSS to send a malicious script to an unsuspecting user. "
"The\n"
"end user's browser has no way to know that the script should not be "
"trusted,\n"
"and will execute the script. Because it thinks the script came from a "
"trusted\n"
"source, the malicious script can access any cookies, session tokens, or "
"other\n"
"sensitive information retained by the browser and used with that site.\n"
"These scripts can even rewrite the content of the HTML page.\n"
"\n"
"The impace of XSS attacks may range from a petty nuisance to a significant\n"
"security risk, depending on the sensitivity of the data handled by the\n"
"vulnerable site and the nature of any security mitigation implemented by "
"the\n"
"site's owner.\n"
msgstr ""
"\n"
"クロスサイトスクリプティング（XSS）攻撃は、悪意のあるスクリプトが他の点では良"
"性で信頼できるWebサイトに注入されるインジェクションの一種です。\n"
"XSS攻撃は攻撃者がWebアプリケーションを使用して、通常はブラウザサイドのスクリ"
"プトの形で、悪質なコードを別のエンドユーザーに送信する場合に発生します。\n"
"これらの攻撃を成功させる脆弱性は非常に広範囲に及んでおり、Webアプリケーション"
"が生成した出力内のユーザーからの入力を検証またはエンコードすることなく使用す"
"る場所で発生します。\n"
"\n"
"攻撃者はXSSを使用して、疑いのないユーザーに悪質なスクリプトを送信することがで"
"きます。 エンドユーザのブラウザはスクリプトを信頼すべきでないことを知る方法が"
"なく、信頼できるソースからのものだと考えているためスクリプトを実行してしまい"
"ます。 悪質なスクリプトは、ブラウザが保持しているCookie、セッショントークン、"
"その他の機密情報にアクセスして、そのサイトで使用されるかのうせいがありま"
"す。\n"
"これらのスクリプトは、HTMLページの内容を書き換えることさえ可能です。\n"
"\n"
"XSS攻撃の脅威は、些細な厄介なものから重大なセキュリティリスクに至るまで多岐に"
"わたりますが、脆弱なサイトが扱うデータの機密性と、サイトの所有者が実装するセ"
"キュリティ対策の性質によって異なります。\n"

#: vulnerabilities.py:4025
msgid ""
"\n"
"One or more API calls were found to be vulnerable to Cross-Site Scripting "
"(XSS) attacks\n"
msgstr ""
"\n"
"1つまたは複数のAPI呼び出しがクロスサイトスクリプティング(XSS)攻撃に対して脆弱"
"であることが判明しました。\n"

#: vulnerabilities.py:4040
msgid "CORS Wild Character Vulnerabilities in HTTP Headers"
msgstr "HTTPヘッダにおけるCORSワイルドカード文字の脆弱性"

#: vulnerabilities.py:4041
msgid "Are there CORS wild character vulnerabilities in HTTP header?"
msgstr "HTTPヘッダにCORSワイルドカード文字の脆弱性はありませんか？"

#: vulnerabilities.py:4042
msgid "No CORS wild character vulnerabilities were found in HTTP headers."
msgstr ""
"HTTPヘッダにおけるCORSワイルドカード文字の脆弱性は見つかりませんでした。"

#: vulnerabilities.py:4043
msgid ""
"\n"
"Cross Origin Resource Sharing (CORS) is a specification that allows cross "
"domain\n"
"communication in a web browser. It works by defining new HTTP headers that "
"describe\n"
"the origins that are allowed cross domain information transmission, thus "
"allowing\n"
"restricted resources (e.g. fonts) on a web page to be requested from "
"another\n"
"domain outside the domain from which the first resource was served.\n"
"\n"
"`Access-Control-Allow-Origin` header should be never set to `*` especially "
"if the resource\n"
"contains sensitive information. It should be set to allow requests only from "
"the\n"
"domains that are trusted.\n"
msgstr ""
"\n"
"Cross Origin Resource Sharing（CORS）は、Webブラウザでドメイン間通信を可能に"
"する仕様です。これは、クロスドメイン情報送信が許可されているオリジンを記述す"
"る新しいHTTPヘッダーを定義することによって機能し、Webページ上の制限されたリ"
"ソース（例えばフォント）を、最初のリソースが提供されたドメイン外の別のドメイ"
"ンから要求できます。\n"
"\n"
"Access-Control-Allow-Origin ヘッダーは、特にリソースに機密情報が含まれている"
"場合、「* （アスタリスク）」で設定しないでください。信頼できるドメインからの"
"要求のみを許可するように設定する必要があります。\n"

#: vulnerabilities.py:4054
msgid ""
"\n"
"One or more API requests were found to have CORS wild character "
"vulnerability within in HTTP headers\n"
msgstr ""
"\n"
"1つまたは複数のAPIリクエストがHTTPヘッダにおけるCORSワイルドカード文字の脆弱"
"性を持っていることが判明しました。\n"

#: vulnerabilities.py:4068
msgid "PhoneGap Whitelist Open Access"
msgstr "PhoneGapのホワイトリストのオープンアクセス"

#: vulnerabilities.py:4069
msgid "Does PhoneGap whitelist allow open access or is missing?"
msgstr ""
"PhoneGapのホワイトリストはオープンアクセスを許可している、もしくは欠落してい"
"ませんか?"

#: vulnerabilities.py:4070
msgid "PhoneGap whitelist does not allow open acces.s or PhoneGap is not used"
msgstr ""
"PhoneGapのホワイトリストはオープンアクセスを許可していないか、もしくは"
"PhoneGapは使用されていません。"

#: vulnerabilities.py:4072
msgid ""
"\n"
"Domain whitelisting is a security model that controls access to external "
"domains\n"
"over which the app has no control. The default security policy allows access "
"to\n"
"any site. Before moving your application to production, you should "
"formulate\n"
"a whitelist and allow access to specific network domains and subdomains.\n"
"\n"
"Application Transport Security (ATS) is a new feature in iOS 9 that acts as\n"
"a whitelist for the app. All the `<access>` and `<allow-navigation>` tags\n"
"automatically get converted to the appropriate ATS directives.\n"
msgstr ""
"\n"
"<p>   ドメインのホワイトリストは、あなたのアプリが制御できない外部のドメイン"
"へのアクセスを制御するセキュリティモデルです。 Cordova はどの外部サイトがアク"
"セス可能か定義するために、構成可能なセキュリティポリシーを付与します。デフォ"
"ルトでは、新しいアプリはどんなサイトへのアクセスも許可するよう構成されていま"
"す。　アプリを実稼動に移行する前に、ホワイトリストを生成し、特定のネットワー"
"クドメインとサブドメインへのアクセスを許可するべきです。</p>\n"

#: vulnerabilities.py:4082
msgid ""
"\n"
"The PhoneGap whitelist was found to be allowing open access to all sites.\n"
"Do not use wildcards (*) alone in whitelists, use fully qualified "
"hostnames.\n"
msgstr ""
"\n"
"PhoneGapのホワイトリストは、すべてのサイトにオープンアクセスを許可しているこ"
"とが判明しました。\n"
"ホワイトリストにワイルドカード（*）を単独で使用せずに、完全修飾ホスト名を使用"
"してください。\n"

#: vulnerabilities.py:4086 vulnerabilities.py:4177
msgid ""
"\n"
"An attacker can bypass the whitelisting mechanism and initiate connections "
"to\n"
"unauthorized remote servers. This could aid in further attacks.\n"
msgstr ""
"\n"
"<p>    攻撃者はホワイトリスト化メカニズムを回避し、権利化されていないリモート"
"サーバへの接続を初期化する可能性があります。 これは更なる攻撃を助長する可能性"
"があります。</p>\n"

#: vulnerabilities.py:4101
msgid "Cross Site Tracing Vulnerabilities"
msgstr "クロスサイトトレーシング(XST)の脆弱性"

#: vulnerabilities.py:4102
msgid "Are there Cross Site Tracing vulnerabilities present?"
msgstr "クロスサイトトレーシング(XST)の脆弱性が存在していませんか？"

#: vulnerabilities.py:4103
msgid "No Cross Site Tracing vulnerabilities were found."
msgstr "クロスサイトトレーシング(XST)の脆弱性は見つかりませんでした。"

#: vulnerabilities.py:4104
msgid ""
"\n"
"A Cross-Site Tracing (XST) attack involves the use of Cross-site Scripting "
"(XSS)\n"
"and the TRACE or TRACK HTTP methods to be successfully leveraged in some\n"
"scenarios to steal legitimate users' credentials. This attack technique was\n"
"discovered by Jeremiah Grossman in 2003, in an attempt to bypass the "
"HttpOnly\n"
"tag that Microsoft introduced in Internet Explorer 6 SP1 to protect cookies "
"from\n"
"being accessed by JavaScript.\n"
msgstr ""
"\n"
"クロスサイトトレーシング（XST）攻撃には、クロスサイトスクリプティング（XSS）"
"とTRACEまたはTRACK HTTPメソッドを使用して、合法的なユーザーの資格情報を盗むた"
"めに悪用されます。\n"
"この攻撃手法は、2003年にJeremiah Grossmanによって発見されました。\n"
"マイクロソフトがInternet Explorer 6 SP1で導入したHttpOnlyタグをバイパスして、"
"JavaScriptによってCookieがアクセスされないようにしています。\n"

#: vulnerabilities.py:4112
msgid ""
"\n"
"One or more API requests were found to be susceptible to Cross Site Tracing "
"vulnerabilies\n"
msgstr ""
"\n"
"1つまたは複数のAPIリクエストがクロスサイトトレーシング(XST)の脆弱性の影響を受"
"けやすいことが判明しました。\n"

#: vulnerabilities.py:4115
msgid ""
"\n"
"The Cross-Site Tracing (XST) attack makes use of Cross-site Scripting (XSS)\n"
"and the TRACE or TRACK HTTP methods. TRACE allows the client to see what is\n"
"being received at the other end of the request chain and use that data for\n"
"testing or diagnostic information. The TRACK method works in the same way "
"but\n"
"is specific to Microsoft's IIS web server. XST could be used as a method to\n"
"steal user's cookies via Cross-site Scripting (XSS) even if the cookie has "
"the\n"
"`HttpOnly` flag set and/or exposes the user's Authorization header.\n"
"\n"
"Modern browsers now prevent TRACE requests being made via JavaScript, "
"however,\n"
"other ways of sending TRACE requests with browsers have been discovered, "
"such as using Java.\n"
msgstr ""
"\n"
"クロスサイトトレース（XST）攻撃では、クロスサイトスクリプティング（XSS）や、"
"TRACEメソッドまたはTRACK HTTPメソッドを使用します。 TRACEを使用すると、クライ"
"アントはリクエストチェーンの相手側で何が受信されているかを確認し、そのデータ"
"をテストまたは診断情報に使用できます。\n"
" TRACKメソッドは同じ方法で動作しますが、MicrosoftのIIS Webサーバー固有です。 "
"XSTは、Cookieに `HttpOnly`フラグが設定されている場合やユーザーの"
"Authorization ヘッダーが公開されている場合でも、クロスサイトスクリプティング"
"（XSS）を介してユーザーのCookieを盗む方法として使用できます。\n"
"\n"
"最新のブラウザでは、JavaScriptを使用してTRACE要求を行うことはできませんが、"
"Javaを使用するなど、ブラウザーでTRACE要求を送信する他の方法が発見されていま"
"す。\n"

#: vulnerabilities.py:4138
msgid "Response Body Contains Non-HTTPS Links"
msgstr "レスポンスボディに含まれている非HTTPSのリンク"

#: vulnerabilities.py:4139
msgid "Does any response body contain non-https links?"
msgstr "レスポンスボディに非HTTPSリンクは含まれていませんか?"

#: vulnerabilities.py:4140
msgid "Response body does not contain non-https links."
msgstr "レスポンスボディには非HTTPSリンクは含まれていません。"

#: vulnerabilities.py:4141
msgid ""
"\n"
"When a response is served over HTTPS, the connection with the web server\n"
"is encrypted with TLS and is therefore safeguarded from sniffers and man-in-"
"the-middle\n"
"attacks. If the HTTPS response includes links to content that is\n"
"retrieved through regular, cleartext HTTP, then the connection is only "
"partially\n"
"encrypted; the unencrypted content is accessible to sniffers and can be "
"modified\n"
"by man-in-the-middle attackers, so the connection is not safeguarded.\n"
msgstr ""
"\n"
"応答がHTTPS経由で提供されると、Webサーバーとの接続はTLSで暗号化されるため、ス"
"ニッファーや中間者攻撃から保護されます。\n"
"HTTPSレスポンスに、通常の平文HTTPで取得されたコンテンツへのリンクが含まれてい"
"る場合、接続は部分的にのみ暗号化されます。暗号化されていないコンテンツはス"
"ニッファーにアクセス可能で、中間者攻撃の攻撃者が変更できるため、接続は保護さ"
"れません。\n"

#: vulnerabilities.py:4149
msgid ""
"\n"
"One or more of the API responses were found to contain URL links that do not "
"employ HTTPS,\n"
"ie. that use regular, cleartext HTTP.\n"
msgstr ""
"\n"
"1つまたは複数のAPIレスポンスにHTTPSを使用しないURLリンクが含まれていることが"
"判明しました。すなわち、通常の平文のHTTPを使用しています。\n"

#: vulnerabilities.py:4164
msgid "PhoneGap Whitelist RegEx Bypass"
msgstr "PhoneGapのホワイトリストのRegExバイパス"

#: vulnerabilities.py:4165
msgid "Can the PhoneGap whitelist be bypassed with a special RegEx"
msgstr ""
"PhoneGapのホワイトリストを特別な正規表現でバイパスすることはできますか？"

#: vulnerabilities.py:4166
msgid ""
"The app does not allow whitelist to be bypassed, or PhoneGap is not used."
msgstr ""
"このアプリケーションはホワイトリストをバイパスすることを許可していないか、も"
"しくはPhoneGapは使用されていません。"

#: vulnerabilities.py:4167
msgid ""
"\n"
"Domain whitelisting is a security model that controls access to external "
"domains\n"
"over which the app has no control. The default security policy allows access "
"to\n"
"any site. Before moving your application to production, you should "
"formulate\n"
"a whitelist and allow access to specific network domains and subdomains.\n"
msgstr ""
"\n"
"<p>   ドメインのホワイトリストは、あなたのアプリケーションが制御できない外部"
"のドメインへのアクセスを制御するセキュリティモデルです。 Cordova はどの外部サ"
"イトがアクセス可能か定義するために、構成可能なセキュリティポリシーを付与しま"
"す。デフォルトでは、新しいアプリはどんなサイトへのアクセスも許可するよう構成"
"されています。　アプリを本番移行する前に、ホワイトリストを生成し、特定のネッ"
"トワークドメインとサブドメインのみアクセスを許可してください。</p>\n"

#: vulnerabilities.py:4173
msgid ""
"\n"
"If a regular expression is used within the whitelist, check if HTTPS can be\n"
"bypassed with the regex.\n"
msgstr ""
"\n"
"正規表現がホワイトリスト内で使用されている場合は、HTTPSを正規表現でバイパスで"
"きるかどうかを確認してください。\n"

#: vulnerabilities.py:4192
msgid "Sending Address Book Data over Unencrypted Insecure Transport Layer"
msgstr ""
"暗号化されていない安全でないトランスポート層を介したアドレス帳データの送信"

#: vulnerabilities.py:4196
msgid ""
"Does the application sends sensitive data and Personal Identifiable "
"Information from address book over the network"
msgstr ""
"アプリケーションはネットワーク経由でアドレス帳から機密データと個人識別情報を"
"送信しますか？"

#: vulnerabilities.py:4200
msgid "The Application doesn't sends Address Book over Insecured Network"
msgstr ""
"アプリケーションは安全でないネットワーク経由でアドレス帳を送信しません。"

#: vulnerabilities.py:4203
msgid ""
"\n"
"Information stored in the Contacts list along with the private notes are\n"
"store in clear text without any encryption. It was found that the "
"application\n"
"sends the data from address book over the network. Lack of encryption might\n"
"result in leakage of information to third parties. Insecure Transport Layer\n"
"Protection might allow Man-In-The-Middle Attack, via which the\n"
"AddressBook data or Personal Identifiable Informations can be stolen\n"
msgstr ""
"\n"
"連絡先リストに格納されている情報はプライベートノートとともに暗号化されずに平"
"文で保存されます。アプリケーションがアドレス帳からネットワーク経由でデータを"
"送信することが判明しました。暗号化が不十分な場合、第三者に情報が漏洩する可能"
"性があります。安全でないトランスポート層の保護により、中間者攻撃が可能になり"
"ます。これにより、アドレス帳のデータや個人情報が盗まれる可能性があります。\n"

#: vulnerabilities.py:4211
msgid ""
"\n"
"If Contact List is sent via Network Layer, ensure that Proper\n"
"Certificate Pinning and encryption is being used.\n"
msgstr ""
"\n"
"連絡先リストがネットワーク層経由で送信されている場合は、適切な証明書のピン設"
"定と暗号化が使用されていることを確認してください。\n"

#: vulnerabilities.py:4215
msgid ""
"\n"
"In the event that a user (anonymous or verified) is able to aceess the\n"
"Address Book of others, the business may experience:\n"
"\n"
"- Reputational Damage\n"
"- Fraud\n"
"- Information Theft\n"
"\n"
msgstr ""
"\n"
"ユーザ（匿名または検証済み）がアドレス帳にアクセスできる場合には、ビジネスに"
"は次のような問題が発生する可能性があります。:  <ul>     <li>風評被害</"
"li>     <li>詐欺</li>     <li>情報盗難</li> </ul>\n"

#: vulnerabilities.py:4234
msgid "Disabled SSL CA Validation and Certificate Pinning"
msgstr "無効なSSL CAの検証と証明書のピン留め"

#: vulnerabilities.py:4235
msgid "Does the application has Certificate Pinning enabled"
msgstr "アプリケーションは証明書のピン留めが有効になっていますか？"

#: vulnerabilities.py:4236
msgid "Application uses Certificate Pinning"
msgstr "アプリケーションは証明書のピン留めを使用しています。"

#: vulnerabilities.py:4237
msgid ""
"\n"
"Certificate Pinning is the process of associating a host with their "
"expected\n"
"X509 certificate or public key. Once a certificate or public key is known "
"or\n"
"seen for a host, the certificate or public key is associated or 'pinned' to\n"
"the host. If more than one certificate or public key is acceptable.\n"
"In this case, the advertised identity must match one of the\n"
"elements in the pinset.\n"
msgstr ""
"\n"
"証明書のピン留めは、X509証明書または公開鍵に関連付けるプロセスです。証明書"
"や、公開鍵がホストに対して既知または認識されると、証明書/公開鍵はホストに関連"
"付けられます。複数の証明書/公開鍵が許容される場合、広告IDはピンセットの要素の"
"1つと一致していなければなりません。\n"

#: vulnerabilities.py:4245
msgid ""
"\n"
"A host or service's certificate or public key can be added to an\n"
"application at development time, or it can be added upon first encountering\n"
"the certificate or public key. The former - adding at development time -\n"
"is preferred since preloading the certificate or public key out of band\n"
"usually means the attacker cannot taint the pin.\n"
msgstr ""
"\n"
"ホストまたはサービスの証明書および公開鍵は、開発時にアプリケーションに追加す"
"ることも、証明書/公開鍵に最初に必要になった時に追加することもできます。開発時"
"に追加する方が推奨されます。証明書や公開鍵を帯域外にプリロードするのは、通"
"常、攻撃者がピンを汚染させるとができないためです。\n"

#: vulnerabilities.py:4261
msgid ""
"\n"
"Certificate Pinning can be done with these two options:\n"
"\n"
"You can\n"
"1. pin the certificate or\n"
"2. pin the public key\n"
"\n"
"If you choose public keys, you have two additional choices:\n"
"- pin the `subjectPublicKeyInfo` or\n"
"- pin one of the concrete types such as `RSAPublicKey` or `DSAPublicKey`.\n"
"\n"
"The three choices are explained below in more detail. I would encourage you\n"
"to pin the subjectPublicKeyInfo because it has the public parameters\n"
"(such as {e,n} for an RSA public key) and contextual information such as\n"
"an algorithm and OID. The context will help you keep your bearings at "
"times,\n"
"and the figure to the right shows the additional information available.\n"
"Certificate\n"
"\n"
"### Certificate\n"
"\n"
"The certificate is easiest to pin. You can fetch the certificate out of "
"band\n"
"for the website, have the IT folks email your company certificate to you,\n"
"use openssl s_client to retrieve the certificate etc. At runtime, you\n"
"retrieve the website or server's certificate in the callback. Within the\n"
"callback, you compare the retrieved certificate with the certificate "
"embedded\n"
"within the program. If the comparison fails, then fail the method or "
"function.\n"
"There is a downside to pinning a certificate. If the site rotates its\n"
"certificate on a regular basis, then your application would need to be "
"updated\n"
"regularly. For example, Google rotates its certificates, so you will need "
"to\n"
"update your application about once a month (if it depended on Google "
"services).\n"
"Even though Google rotates its certificates, the underlying public keys\n"
"(within the certificate) remain static.\n"
"\n"
"#### Public Key\n"
"\n"
"Public key pinning is more flexible but a little trickier due to the extra\n"
"steps necessary to extract the public key from a certificate. As with a\n"
"certificate, the program checks the extracted public key with its embedded\n"
"copy of the public key.\n"
"There are two downsides to public key pinning. First, it's harder to work\n"
"with keys (versus certificates) since you must extract the key from the\n"
"certificate. Extraction is a minor inconvenience in Java and .Net, buts "
"it's\n"
"uncomfortable in Cocoa/CocoaTouch and OpenSSL. Second, the key is static\n"
"and may violate key rotation policies.\n"
"\n"
"#### Hashing\n"
"While the three choices above used DER encoding, its also acceptable to use\n"
"a hash of the information. In fact, the original sample programs were "
"written\n"
"using digested certificates and public keys. The samples were changed to\n"
"allow a programmer to inspect the objects with tools like dumpasn1 and\n"
"other ASN.1 decoders.\n"
"\n"
"Hashing also provides three additional benefits. First, hashing allows you\n"
"to anonymize a certificate or public key. This might be important if you\n"
"application is concerned about leaking information during decompilation and\n"
"re-engineering. Second, a digested certificate fingerprint is often "
"available\n"
"as a native API for many libraries, so its convenient to use.\n"
"\n"
msgstr ""

#: vulnerabilities.py:4321
msgid ""
"\n"
"*   OWASP [Transport Layer Protection Cheat Sheet](/index.php/"
"Transport_Layer_Protection_Cheat_Sheet \"Transport Layer Protection Cheat "
"Sheet\")\n"
"*   IETF [RFC 1421 (PEM Encoding)](http://www.ietf.org/rfc/rfc1421.txt)\n"
"*   IETF [RFC 4648 (Base16, Base32, and Base64 Encodings)](http://www.ietf."
"org/rfc/rfc4648.txt)\n"
"*   IETF [RFC 5280 (Internet X.509, PKIX)](http://www.ietf.org/rfc/rfc5280."
"txt)\n"
"*   IETF [RFC 3279 (PKI, X509 Algorithms and CRL Profiles)](http://www.ietf."
"org/rfc/rfc3279.txt)\n"
"*   IETF [RFC 4055 (PKI, X509 Additional Algorithms and CRL Profiles)]"
"(http://www.ietf.org/rfc/rfc4055.txt)\n"
"*   IETF [RFC 2246 (TLS 1.0)](http://www.ietf.org/rfc/rfc2246.txt)\n"
"*   IETF [RFC 4346 (TLS 1.1)](http://www.ietf.org/rfc/rfc4346.txt)\n"
"*   IETF [RFC 5246 (TLS 1.2)](http://www.ietf.org/rfc/rfc5246.txt)\n"
"*   RSA Laboratories [PKCS#1, RSA Encryption Standard](http://www.rsa.com/"
"rsalabs/node.asp?id=2125)\n"
"*   RSA Laboratories [PKCS#6, Extended-Certificate Syntax Standard](http://"
"www.rsa.com/rsalabs/node.asp?id=2128)\n"
msgstr ""

#: vulnerabilities.py:4341
msgid "Surreptitious Sharing on Android"
msgstr "Android における Surreptitious Sharing"

#: vulnerabilities.py:4342
msgid "Is your application vulnerable to Surreptitious Sharing?"
msgstr "アプリケーションは Surreptitious Sharing に対して脆弱ですか？"

#: vulnerabilities.py:4344
msgid "Surreptitious Sharing might not be in use in this application"
msgstr ""
"このアプリケーションでは、Surreptitious Sharing が使用されていない可能性があ"
"ります。"

#: vulnerabilities.py:4345
msgid ""
"\n"
"Many email and messaging apps on Android utilize the Intent API for sending\n"
"files shared from other apps such as Android’s gallery. These Intents are\n"
"standardized for sending and receiving content. Instead of sending entire\n"
"files, such as videos, via this API, only URIs are exchanged pointing to "
"the\n"
"actual storage position. A vulnerability in this Intent API, which is\n"
"present in many published communication apps allowing privilege escalation\n"
"and data leakage.\n"
"\n"
"The main issue lies in the fact that apps cannot only access their private "
"data\n"
"directories using `Context.openFileOutput(String name, int mode)`, but also\n"
"using _file_ URIs. While these URIs are normally used to access files on "
"the\n"
"SD card, via `file:///sdcard/paper.pdf` for example, they can also point to\n"
"private files, e.g., `file:///data/data/com.example.app/files/paper.pdf`.\n"
"If an app registers Intent Filters to support Android’s sharing API or "
"defines\n"
"custom Intents accepting URIs, they are potentially accepting _file_ URIs "
"that\n"
"could also point to their own private files. For apps facilitating\n"
"communication, like email or messaging apps, this leads to what we call\n"
"_Surreptitious Sharing_. Investigating the AOSP source code reveals that\n"
"support for _file_ URIs using `Context.openFileOutput(String name, int "
"mode)`\n"
"(similar checks are present in `openAssetFileDescriptor`) was planned to be\n"
"removed (see inline comments in `openInputStream` method in\n"
"[ContentResolver]\n"
"(https://goo.gl/Qyx84j)).\n"
"\n"
"\n"
msgstr ""
"\n"
"Androidの多くの電子メールアプリとメッセージングアプリは、Androidのギャラリー"
"などの他のアプリから共有されたファイルを送信するためにIntent APIを利用してい"
"ます。\n"
"これらのインテントは、コンテンツの送受信に標準化されています。\n"
"このAPIを介して動画などのファイル全体を送信する代わりに、実際の保存場所を指す"
"URIだけが交換されます。このIntent APIの脆弱性は、特権の昇格やデータ漏洩を可能"
"にする、公開された多くの通信アプリに存在します。\n"
"\n"
"主な問題は、アプリが自分のプライベートデータにアクセスできるだけでなく\n"
"`Context.openFileOutput（文字列名、intモード）`を使用するディレクトリ、\n"
"_file_ URIも使用します。\n"
"これらのURIは通常、SDカード上のファイルにアクセスするために使用されますが、例"
"えば、file：/// sdcard / paper.pdf を介して、file：/// data / data / com."
"example.app / files / paper.pdf のようなプライベートファイルを指定することも"
"できます。アプリがインテントフィルタを登録してAndroidの共有APIをサポートする"
"か、URIを受け取るカスタムインテントを定義する場合、潜在的に自分自身のプライ"
"ベートファイルを指す可能性のある_file_ URIを許容します。\n"
"電子メールやメッセージングアプリのようなコミュニケーションを容易にするアプリ"
"では、これを「Surreptitious Sharing」と呼びます。\n"
"AOSPのソースコードを調べると、 `OpenOsetFileDescriptor`の中にContext."
"openFileOutput（String name、int mode） `を使った_file_ URIのサポートが削除さ"
"れる予定だったことが明らかになりました。（次の` openInputStream`メソッドのイ"
"ンラインコメントを参照してください。\n"
"[ContentResolver]\n"
"(https://goo.gl/Qyx84j)).\n"

#: vulnerabilities.py:4372
msgid ""
"\n"
"This activity receives `android.intent.action.SEND` or\n"
"`android.intent.action.SEND_MULTIPLE` intents and accepts a file-scheme as "
"data\n"
"URI `(file://...)` as parameter. It may be vulnerable to surreptitious "
"sharing:\n"
"a malicious application may set a URI referencing a private file of this\n"
"application, and if no proper sanity checking is done this might be used\n"
"to obtain the referenced file.\n"
"\n"
msgstr ""
"\n"
"このアクティビティは `android.intent.action.SEND`または\n"
"`android.intent.action.SEND_MULTIPLE`は、ファイルスキームをデータ"
"URI`（file：// ...） `としてパラメータとして受け取ります。 非公開のアプリケー"
"ションのプライベートファイルを参照するURIを設定する可能性があり、適切なサニ"
"ティーチェックが行われない場合、参照されたファイルを取得するために使用される"
"可能性があります。\n"

#: vulnerabilities.py:4390
msgid ""
"\n"
"We provided a fix for app developers that checks with _fstat_ if a file is\n"
"owned by the receiving app only and then prevents the opening of it.\n"
"Due to the requirement of using _fstat_ our Java fix was only available for\n"
"Android >= 5. We strongly recommend to use this library to fix the\n"
"issue in your app:\n"
"\n"
"[https://github.com/appknox/SafeContentResolver](https://goo.gl/Gsz1bh).\n"
msgstr ""
"\n"
"私たちはアプリケーション開発者のために、受信側のアプリケーションだけがファイ"
"ルを所有していて、ファイルを開くことを妨げている場合に「fstat」でチェックをす"
"る修正を提供しています。\n"
"「fstat」を使用する必要があるため、Javaの修正はAndroid> = 5でのみ利用可能で"
"す。\n"
" このライブラリを使用して、アプリケーションの問題を解決することを強くおすすめ"
"します。\n"
"[https://github.com/appknox/SafeContentResolver](https://goo.gl/Gsz1bh)\n"

#: vulnerabilities.py:4399
msgid ""
"\n"
"This example is intended to surreptitiously share IMAP passwords of K-9 "
"Mail\n"
"with an attacker. Please note that K-9 Mail serves only as an example,\n"
"the issue has already been fixed in the current release and was present\n"
"in many more apps\n"
"\n"
"The code required to execute this attack follows:\n"
"\n"
"    Intent i = new Intent();\n"
"    i.setComponent(new ComponentName(\"com.fsck.k9\", \"com.fsck.k9.activity."
"MessageCompose\"));\n"
"    i.setAction(Intent.ACTION_SEND); i.setType(\"text/plain\");\n"
"    Uri uri = Uri.parse(\"file:///data/data/com.fsck.k9/databases/"
"preferences_storage\");\n"
"    i.putExtra(Intent.EXTRA_STREAM, uri);\n"
"    i.putExtra(Intent.EXTRA_TEXT, \"Hello World\");\n"
"    i.putExtra(Intent.EXTRA_EMAIL, new String[]{\"support@company.com\"});\n"
"    i.putExtra(Intent.EXTRA_TEXT, \"Dear support team,...\");\n"
"    i.putExtra(Intent.EXTRA_SUBJECT, \"Bug Report\");\n"
"\n"
"This can be reproduced by connecting to a Android device via `adb shell` "
"and\n"
"then observing the output of `dmesg | grep avc`.\n"
msgstr ""
"\n"
"この例は、K-9 MailのIMAPパスワードを不正に共有することを意図しています。\n"
"攻撃者と K-9メールは例としてのみ提供されていますが、\n"
"この問題は、現在のリリースで修正されており、より多くのアプリケーションに存在"
"しています。\n"
"\n"
"この攻撃を実行するために必要なコードは次のとおりです。\n"
"\n"
"    Intent i = new Intent();\n"
"    i.setComponent(new ComponentName(\"com.fsck.k9\", \"com.fsck.k9.activity."
"MessageCompose\"));\n"
"    i.setAction(Intent.ACTION_SEND); i.setType(\"text/plain\");\n"
"    Uri uri = Uri.parse(\"file:///data/data/com.fsck.k9/databases/"
"preferences_storage\");\n"
"    i.putExtra(Intent.EXTRA_STREAM, uri);\n"
"    i.putExtra(Intent.EXTRA_TEXT, \"Hello World\");\n"
"    i.putExtra(Intent.EXTRA_EMAIL, new String[]{\"support@company.com\"});\n"
"    i.putExtra(Intent.EXTRA_TEXT, \"Dear support team,...\");\n"
"    i.putExtra(Intent.EXTRA_SUBJECT, \"Bug Report\");\n"
"\n"
"これは、 `adbシェル`を介してAndroidデバイスに接続し、 `dmesg | grep avc`を実"
"行します。\n"

#: vulnerabilities.py:4428
msgid "Android Fragment Injection"
msgstr "Android Fragment Injection"

#: vulnerabilities.py:4429
msgid "Is your appl;ication vulnerable to Fragment Injection?"
msgstr "アプリケーションは Fragment Injection に対して脆弱ですか？"

#: vulnerabilities.py:4431
msgid "Application is not vulnerable to Fragment Injection"
msgstr "アプリケーションはFragment Injection に対して脆弱ではありません。"

#: vulnerabilities.py:4432
msgid ""
"\n"
"Android SDK offers a way for developers to present a\n"
"[`Preferences activity`](https://developer.android.com/reference/android/"
"preference/PreferenceActivity.html).\n"
"to users, allowing them to extend this abstract class and adapt it to their "
"needs.\n"
"\n"
"This abstract class will parse the extra data fields received on a Intent,\n"
"in particular the\n"
"`PreferenceActivity.EXTRA_SHOW_FRAGMENT(:android:show_fragment)` and\n"
"`PreferenceActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS(:android:"
"show_fragment_arguments)`\n"
"\n"
"It is expected that the first field contains the `Fragment`\n"
"class name and the second one contains the input bundle passed\n"
"to the `Fragment`.\n"
"\n"
"Due to the fact that the `PreferenceActivity` uses reflection to\n"
"load the fragment, this can lead to load an arbitrary class inside the\n"
"package or the Android SDK. The loaded class runs in the context of the\n"
"application that exports this activity.\n"
"\n"
msgstr ""
"\n"
"Android SDKは、開発者がユーザーに[`Preferences activity`](https://developer."
"android.com/reference/android/preference/PreferenceActivity.html)を提示する方"
"法を提供し、この抽象クラスを拡張してニーズに合わせることができます。\n"
"この抽象クラスは、特に次のふたつのインテントで受け取った余分なデータフィール"
"ドを解析します。\n"
"`PreferenceActivity.EXTRA_SHOW_FRAGMENT(:android:show_fragment)` and\n"
"`PreferenceActivity.EXTRA_SHOW_FRAGMENT_ARGUMENTS(:android:"
"show_fragment_arguments)`\n"
"最初のフィールドには `Fragment`クラス名が含まれ、2番目のフィールドには` "
"Fragment`に渡された入力バンドルが含まれていることが望まれます。\n"
"\n"
"`PreferenceActivity`がフラグメントをロードするためにリフレクションを使用する"
"ことで、パッケージまたはAndroid SDKの中に任意のクラスをロードすることにつなが"
"ります。 ロードされたクラスは、このアクティビティをエクスポートするアプリケー"
"ションのコンテキストで実行されます。\n"

#: vulnerabilities.py:4452
msgid ""
"\n"
"With this vulnerability the attacker will be able to call non exported\n"
"Activities or fragments inside the target application.\n"
msgstr ""
"\n"
"この脆弱性により、攻撃者はエクスポートされていないアクティビティやターゲット"
"アプリケーション内のフラグメントを呼び出すことができます。\n"

#: vulnerabilities.py:4456 vulnerabilities.py:4514
msgid ""
"\n"
"In the event that a user (anonymous or verified) is able to execute\n"
"over-privileged functionality, the business may experience:\n"
"\n"
"- Reputational Damage\n"
"- Fraud\n"
"- Information Theft\n"
msgstr ""
"\n"
"ユーザー（匿名または検証済み）が特権を必要とする機能を実行できる場合、ビジネ"
"スには次のような問題が発生する可能性があります。\n"
"\n"
"- 風評被害\n"
"- 詐欺\n"
"- 情報盗難\n"

#: vulnerabilities.py:4464
msgid ""
"\n"
"To mitigate this vulnerability, a new method called `isValidFragment` was\n"
"added in Android 4.4 KitKat (API Level 19), that allows developers to "
"override\n"
"it and define which fragments are allowed to be used in this context.\n"
"\n"
msgstr ""
"\n"
"この脆弱性を軽減するために、Android 4.4 KitKat（APIレベル19）に"
"isValidFragmentという新しいメソッドが追加されました。これにより、開発者はこの"
"メソッドを使用してこのコンテキストで使用できるフラグメントを定義できます。\n"

#: vulnerabilities.py:4470
msgid ""
"\n"
"- Determine the minSDKVersion and maxSDKVersion to determine what will be "
"the behaviour of the class.\n"
"- Find exported Activities that extends the `PreferenceActivity` class.\n"
"\n"
"The following example shows a Activity that extends this activity :\n"
"\n"
"    public class MyPreferences extends PreferenceActivity {\n"
"        @Override\n"
"        protected void onCreate(Bundle savedInstanceState) {\n"
"            super.onCreate(savedInstanceState);\n"
"\n"
msgstr ""
"\n"
"-  minSDKVersionとmaxSDKVersionを決定し、クラスの動作を決定します。\n"
"-  `PreferenceActivity`クラスを拡張した、エクスポートされたアクティビティを検"
"索します。\n"
"\n"
"次の例は、このアクティビティを拡張するアクティビティを示しています。\n"
"\n"
"    public class MyPreferences extends PreferenceActivity {\n"
"        @Override\n"
"        protected void onCreate(Bundle savedInstanceState) {\n"
"            super.onCreate(savedInstanceState);\n"
"\n"

#: vulnerabilities.py:4490
msgid ""
"Do not allow WebView to access sensitive local resource through file scheme"
msgstr ""
"WebViewが重要なローカルリソースにファイルスキームでアクセスすることを許可しな"
"いでください。"

#: vulnerabilities.py:4491
msgid "Are weak glass containers in use?"
msgstr "weak glass containersを使用していますか？"

#: vulnerabilities.py:4492
msgid "Weak glass containers are not being used"
msgstr "weak glass containersを使用していません。"

#: vulnerabilities.py:4493
msgid ""
"\n"
"The WebView class displays web pages as part of an activity layout.\n"
"The behavior of a WebView  object can be customized using the WebSettings\n"
"object, which can be obtained from WebView.getSettings().\n"
"\n"
"Major security concerns for WebView are about the\n"
"`setJavaScriptEnabled()`, `setPluginState()`,\n"
"and `setAllowFileAccess()` methods.\n"
"\n"
"When an activity has WebView embedded to display web pages, any application\n"
"can create and send an Intent object with a given URI to the activity to\n"
"request that a web page be displayed.\n"
"\n"
"WebView can recognize a variety of schemes, including the `file:scheme`.\n"
"A malicious application may create and store a crafted content on its\n"
"local storage area, make it accessible with MODE_WORLD_READABLE permission,\n"
"and send the URI (using the `file:scheme`) of this content to a target "
"activity.\n"
msgstr ""
"\n"
"WebViewクラスは、Webページをアクティビティレイアウトの一部として表示しま"
"す。\n"
"WebViewオブジェクトの動作は、WebView.getSettings（）から取得できるWebSettings"
"オブジェクトを使用してカスタマイズできます。\n"
"\n"
"WebViewの主なセキュリティ上の懸念は、次のメソッドです。 "
"`setJavaScriptEnabled（）`\n"
" `setPluginState（）`\n"
"`setAllowFileAccess（）`\n"
"\n"
"アクティビティにWebViewを埋め込んでWebページを表示すると、\n"
"どのようなアプリケーションでも、指定されたURIを持つインテントオブジェクトを作"
"成してアクティビティに送信し、Webページの表示を要求することができます。\n"
"\n"
"WebViewはさまざまなスキームを認識できますが、これには `file：scheme`も含まれ"
"ます。\n"
"悪意のあるアプリケーションは、細工されたコンテンツを作成してローカルストレー"
"ジ領域に保存し、MODE_WORLD_READABLE権限でアクセス可能にし、このコンテンツの"
"URIを（target：file：schemeを使用して）ターゲットアクティビティに送信しま"
"す。\n"

#: vulnerabilities.py:4511
msgid ""
"\n"
"Allowing WebView to access sensitive resources may result in information "
"leaks.\n"
msgstr ""
"\n"
"WebViewが機密リソースにアクセスできるようにすると、情報が漏洩する可能性があり"
"ます。\n"

#: vulnerabilities.py:4522
msgid ""
"\n"
"Any URI received via an intent from outside a trust-boundary should be\n"
"validated before rendering it with WebView. For example,\n"
"the following code checks an received URI and uses it only when it\n"
"is not a `file:scheme` URI.\n"
"\n"
"    String intentUrl = getIntent().getStringExtra(\"url\");\n"
"    String localUrl = \"about:blank\";\n"
"    if (!intentUrl.startsWith(\"file:\")) {\n"
"        loadUrl = intentUrl;\n"
"    }\n"
"\n"
msgstr ""
"\n"
"トラストバウンダリ外からインテント経由で受信したURIは、WebViewでレンダリング"
"する前に検証する必要があります。たとえば、次のコードは受信したURIをチェック"
"し、それが `file：scheme` URIでない場合にのみ使用します。\n"
"\n"
"    String intentUrl = getIntent().getStringExtra(\"url\");\n"
"    String localUrl = \"about:blank\";\n"
"    if (!intentUrl.startsWith(\"file:\")) {\n"
"        loadUrl = intentUrl;\n"
"    }\n"
"\n"

#: vulnerabilities.py:4535
msgid ""
"\n"
"The following noncompliant code example uses the WebView component with\n"
"JavaScript enabled and processes any URI passed through\n"
"Intent without any validation:\n"
"\n"
"    public class MyBrowser extends Activity {\n"
"        @override\n"
"        public void onCreate(Bundle savedInstanceState) {\n"
"            super.onCreate(savedInstanceState);\n"
"            setContentView(R.layout.main);\n"
"\n"
"            WebView webView = (WebView) findViewById(R.id.webview);\n"
"\n"
"            // turn on javascript\n"
"            WebSettings settings = webView.getSettings();\n"
"            settings.setJavaScriptEnabled(true);\n"
"\n"
"            String turl = getIntent().getStringExtra(\"URL\");\n"
"            webView.loadUrl(turl);\n"
"        }\n"
"    }\n"
"\n"
"This code shows how the vulnerability can be exploited:\n"
"\n"
"    // Malicious application prepares some crafted HTML file,\n"
"    // places it on a local storage, makes accessible from\n"
"    // other applications. The following code sends an\n"
"    // intent to a target application (jp.vulnerable.android.app)\n"
"    // to make it access and process the malicious HTML file.\n"
"\n"
"    String pkg = \"jp.vulnerable.android.app\";\n"
"    String cls = pkg + \".DummyLauncherActivity\";\n"
"    String uri = \"file:///[crafted HTML file]\";\n"
"    Intent intent = new Intent();\n"
"    intent.setClassName(pkg, cls);\n"
"    intent.putExtra(\"url\", uri);\n"
"    this.startActivity(intent);\n"
"\n"
msgstr ""
"\n"
"次の違反コードの例では、JavaScriptを有効にしてWebViewコンポーネントを使用し、"
"検証なしでIntentを介して渡されたURIを処理します。\n"
"\n"
"    public class MyBrowser extends Activity {\n"
"        @override\n"
"        public void onCreate(Bundle savedInstanceState) {\n"
"            super.onCreate(savedInstanceState);\n"
"            setContentView(R.layout.main);\n"
"\n"
"            WebView webView = (WebView) findViewById(R.id.webview);\n"
"\n"
"            // turn on javascript\n"
"            WebSettings settings = webView.getSettings();\n"
"            settings.setJavaScriptEnabled(true);\n"
"\n"
"            String turl = getIntent().getStringExtra(\"URL\");\n"
"            webView.loadUrl(turl);\n"
"        }\n"
"    }\n"
"\n"
"このコードは、この脆弱性がどのように悪用されるかを示しています。\n"
"\n"
"    // Malicious application prepares some crafted HTML file,\n"
"    // places it on a local storage, makes accessible from\n"
"    // other applications. The following code sends an\n"
"    // intent to a target application (jp.vulnerable.android.app)\n"
"    // to make it access and process the malicious HTML file.\n"
"\n"
"    String pkg = \"jp.vulnerable.android.app\";\n"
"    String cls = pkg + \".DummyLauncherActivity\";\n"
"    String uri = \"file:///[crafted HTML file]\";\n"
"    Intent intent = new Intent();\n"
"    intent.setClassName(pkg, cls);\n"
"    intent.putExtra(\"url\", uri);\n"
"    this.startActivity(intent);\n"
"\n"

#: vulnerabilities.py:4574
msgid ""
"\n"
"*   [JVN#59652356](https://jvn.jp/en/jp/JVN59652356/) Cybozu KUNAI for "
"Android vulnerable in the WebView class\n"
"*   [JVN#99813183](https://jvn.jp/en/jp/JVN99813183/) Galapagos Browser "
"vulnerable in the WebView class\n"
"*   [JVN#79301570](https://jvn.jp/en/jp/JVN79301570/) Angel Browser "
"vulnerable in the WebView class\n"
"*   [JVN#77393797](https://jvn.jp/en/jp/JVN77393797/) Cybozu Live for "
"Android vulnerable in the WebView class\n"
"*   [JVN#03015214](https://jvn.jp/en/jp/JVN03015214/) KUNAI Browser for "
"Remote Service beta vulnerable in the WebView class\n"
"*   [JVN#46088915](https://jvn.jp/en/jp/JVN46088915/) Yahoo! Browser "
"vulnerable in the WebView class\n"
msgstr ""
"\n"
"*   [JVN#59652356](https://jvn.jp/en/jp/JVN59652356/) Cybozu KUNAI for "
"Android　WebViewクラスの脆弱性\n"
"*   [JVN#99813183](https://jvn.jp/en/jp/JVN99813183/) Galapagos Browser　"
"WebViewクラスの脆弱性\n"
"*   [JVN#79301570](https://jvn.jp/en/jp/JVN79301570/) Angel Browser　WebView"
"クラスの脆弱性\n"
"*   [JVN#77393797](https://jvn.jp/en/jp/JVN77393797/) Cybozu Live for "
"Android　WebViewクラスの脆弱性\n"
"*   [JVN#03015214](https://jvn.jp/en/jp/JVN03015214/) KUNAI Browser リモート"
"ベータ版　 WebViewクラスの脆弱性\n"
"*   [JVN#46088915](https://jvn.jp/en/jp/JVN46088915/) Yahoo! ブラウザ WebView"
"クラスの脆弱性\n"

#: vulnerabilities.py:4589
msgid "Misconfigured AWS S3 Buckets"
msgstr "設定されていないAWS S3バケット"

#: vulnerabilities.py:4590
msgid "Is the AWS S3 bucket misconfigured?"
msgstr "AWS S3バケットの構成が誤っていますか？"

#: vulnerabilities.py:4591
msgid "No misconfigured AWS S3 buckets were found."
msgstr "誤って構成されたAWS S3バケットは見つかりませんでした。"

#: vulnerabilities.py:4592
msgid ""
"\n"
"Amazon S3 is a web service offered by Amazon Web Services.\n"
"It provides web service interfaces to securely store,\n"
"retrieve any amount of data in the cloud into the buckets in form of "
"objects.\n"
"AWS also gives programmatic way to upload, read, write objects\n"
"in the bucket through the AWS API Key.\n"
"Following are the common misconfigurations leading to security issues.\n"
"\n"
"1.  The access key was unintentionally hardcoded or published\n"
"2.  The bucket permissions were misconfigured.\n"
msgstr ""
"\n"
"Amazon S3は、Amazon Web Servicesが提供するWebサービスです。\n"
"クラウド内の任意の量のデータをオブジェクトの形式でバケットに安全に格納し、取"
"得するWebサービスインターフェイスを提供します。\n"
"また、AWS APIキーを使用してバケット内のオブジェクトをアップロード、読み込み、"
"書き込みするプログラムのような方法も提供します。以下は、セキュリティ上の問題"
"につながる一般的な誤設定です。\n"
"\n"
"1.アクセスキーが意図せずハードコーディングまたは公開されている\n"
"2.バケットのアクセス許可が正しく設定されていない\n"

#: vulnerabilities.py:4603
msgid ""
"\n"
"Since the bucket is misconfigured, any user with an AWS access key will be "
"able to read or write\n"
"to the bucket leading to loss of confidentiality and integrity.\n"
"In case the access keys are leaked, anyone with the keys can gain "
"administrative\n"
"privileges over the bucket and it’s objects leading to compromise of the "
"data.\n"
msgstr ""
"\n"
"バケットが誤って構成されているため、AWSアクセスキーを持つすべてのユーザーがバ"
"ケットに読み書きできることで、機密性と整合性が失われます。\n"
"アクセスキーが漏洩した場合、キーを持っている誰もがバケット上で管理特権を得る"
"ことができ、そのオブジェクトがデータを危険にさらすことにつながります。\n"

#: vulnerabilities.py:4609
msgid ""
"\n"
"Leaving third party cloud storage open or insecure may result in compromise "
"of sensitive\n"
"data pertaining to the organization which leads to loss of confidentiality "
"and integrity.\n"
msgstr ""
"\n"
"サードパーティのクラウドストレージをオープンまたはセキュアにしないと、機密"
"データを危険にさらすことにつながり、機密性と完全性を失うことになる可能性があ"
"ります。\n"

#: vulnerabilities.py:4613
msgid ""
"\n"
"It is also recommended to [set proper access control](http://docs.aws.amazon."
"com/AmazonS3/latest/dev/acl-overview.html)\n"
"to the buckets such that only the owner of the bucket is able to view/modify "
"data in the buckets.\n"
"It is recommended to rotate the access keys, if the keys are leaked. For "
"more information,\n"
"click [here.](http://docs.aws.amazon.com/config/latest/developerguide/s3-"
"bucket-policy.html)\n"
msgstr ""

#: vulnerabilities.py:4619
msgid ""
"\n"
"Buckets with misconfigured access control policies or exposed private keys\n"
msgstr ""

#: vulnerabilities.py:4630
msgid "Insecure Broadcast Receivers registered dynamically"
msgstr "動的に登録された安全でないブロードキャストレシーバ"

#: vulnerabilities.py:4632
msgid "Does the Android Application registers Broadcast Receivers dynamically?"
msgstr ""
"Android アプリケーションはブロードキャストレシーバ を動的に登録しますか？"

#: vulnerabilities.py:4636
msgid "There is no insecure Dynamically registered Broadcast Receiver"
msgstr "動的に登録された安全でないブロードキャストレシーバはありませんでした。"

#: vulnerabilities.py:4637
msgid ""
"\n"
"A BroadcastReceiver represents one main component of an essential\n"
"publish/subscribe messaging platform in Android. It, known as a subscriber,\n"
"can be used to receive and respond to specific messages (or broadcasts) "
"from\n"
"the system or other components in the same application or different\n"
"applications, such as notifying Android users when cellphone power is low "
"as\n"
"a system event-driven. This is generally achieved through the utilization "
"of\n"
"intent filters defined in the app manifest file.\n"
"\n"
"The dynamically Broadcastreceiver is in the java source code to realize the\n"
"broadcast mechanism using onReceive(). This mechanism is managed by the "
"Activity\n"
"Manager Service (AMS) on the second framework layer in the Android "
"architecture.\n"
msgstr ""
"\n"
"ブロードキャストレシーバーは、Androidの重要なパブリッシュ/サブスクライブメッ"
"セージングプラットフォームの主要コンポーネントの1つです。\n"
"これは、サブスクライバーとして知られており、システムイベントドリブンとして携"
"帯電話の電力が低いときに Androidユーザーに通知するなど、同じアプリケーション"
"または異なるアプリケーション内のシステムや他のコンポーネントから特定のメッ"
"セージ（またはブロードキャスト）を受信して応答するために使用されます 。\n"
"これは、一般にアプリケーションのマニフェストファイルで定義されたインテント"
"フィルタの使用によって実現されます。\n"
"\n"
"onReceive（）を使用してブロードキャストのメカニズムを実現するために、動的なブ"
"ロードキャストレシーバーがJavaソースコード内にあります。\n"
"このメカニズムは、Androidアーキテクチャの2番目のフレームワークレイヤーの"
"Activity Managerサービス（AMS）によって管理されます。\n"

#: vulnerabilities.py:4650
msgid ""
"\n"
"Broadcast Receivers which are set Dynamically and are not protected\n"
msgstr ""
"\n"
"動的に設定された安全でないブロードキャストレシーバー\n"

#: vulnerabilities.py:4654
msgid ""
"\n"
"To protect broadcast, it needs to be registered with permissions when it\n"
"is declare.\n"
"\n"
"Secondly never trust the data that is being sent with it.\n"
"It's passing through a trust zone to arrive in the app,\n"
"so it needs to be validated\n"
msgstr ""
"\n"
"ブロードキャストを保護するには、ブロードキャストが宣言されているときにアクセ"
"ス許可で登録する必要があります。\n"
"第二に、それと共に送信されているデータを信頼するべきではありません。それはア"
"プリケーションに到着するためにトラストゾーンを通過しているので、検証する必要"
"があります。\n"

#: vulnerabilities.py:4662
msgid ""
"\n"
"If the broadcast filter is listening for an intent that isn't a restricted\n"
"broadcast then the malicious app can start sending them without needing any\n"
"permissions.\n"
"\n"
"Secondly if the receiver goes on to use the extras sent with the broadcast,\n"
"or to start running other functions, then the malware has a whole new entry\n"
"point to yTheour application.\n"
msgstr ""
"\n"
"制限されたブロードキャストではないインテントを、ブロードキャストフィルタが"
"リッスンしている場合、悪意のあるアプリケーションはアクセス権を必要とせずに送"
"信を開始できます。\n"
"\n"
"第二に、受信者がブロードキャストで送信されたコンテンツを使用し続けている場"
"合、または他の機能の実行を開始する場合、マルウェアは、アプリケーションへの新"
"しいエントリポイントを持ちます。\n"

#: vulnerabilities.py:4679
msgid "Android Component Hijacking via Intent"
msgstr "インテントによるAndroidコンポーネントのハイジャック"

#: vulnerabilities.py:4680
msgid "Is any Android component vulnerable to Intent hijacking?"
msgstr "Androidコンポーネントはインテントのハイジャックに対して脆弱ですか？"

#: vulnerabilities.py:4682
msgid "Application has no vulnerable components for Intent hijacking"
msgstr ""
"アプリケーションにインテントハイジャックに脆弱なコンポーネントはありません。"

#: vulnerabilities.py:4683
msgid ""
"\n"
"Android app can have four types of components:\n"
"- Activity\n"
"- Broadcast Receiver\n"
"- Content Provider\n"
"- Service App\n"
"\n"
"They have their own entry points and can be activated individually.\n"
"These components can be exposed to other apps for flexible code and data\n"
"sharing. Android (mainly) uses Manifest XML file to define component "
"exposure.\n"
"Intents come into play here because they are the main mechanism for\n"
"communication between components. Intents are used to start activities and\n"
"services, bind to services, and convey notifications to broadcast "
"receivers.\n"
"By default, a component can only receive intents from other components\n"
"in the same application, but it can be configured to accept intents from\n"
"outside applications by setting the `android:exported` attribute in the\n"
"manifest.\n"
"\n"
"An intent can be classified as one of two types based on how it is "
"addressed.\n"
"\n"
"- Implicit Intent\n"
"- Explicit Intent\n"
"\n"
"There are two main ways that the security of intents can be compromised:\n"
"\n"
"- **Intent interception** involves a malicious app receiving an\n"
"  intent that was not intended for it. This can cause a leak of sensitive\n"
"  information, but more importantly, it can result in the malicious "
"component\n"
"  being activated instead of the legitimate component. For example, if a\n"
"  malicious activity intercepted an intent then it would appear on the "
"screen\n"
"  instead of the legitimate activity.\n"
"- **Intent spoofing** is an attack where a malicious application\n"
"  induces undesired behavior by forging an intent.\n"
"\n"
msgstr ""
"\n"
"Androidアプリには4種類のコンポーネントがあります。\n"
"\n"
"-アクティビティ\n"
"- ブロードキャスト レシーバ\n"
"- コンテンツプロバイダ\n"
"- サービスアプリケーション\n"
"\n"
"彼らは独自のエントリポイントを持っており、個々に起動することができます。\n"
"これらのコンポーネントは、柔軟なコードとデータ共有のために他のアプリに公開す"
"ることができます。 \n"
"Androidは（主に）マニフェストXMLファイルを使用してコンポーネントの公開を定義"
"します。\n"
"インテントは、コンポーネント間の通信の主なメカニズムであるため、ここで使われ"
"ます。\n"
"インテントは、アクティビティとサービスを開始し、サービスにバインドし、ブロー"
"ドキャスト レシーバに通知を伝えるために使用されます。\n"
"デフォルトでは、コンポーネントは同じアプリケーション内の他のコンポーネントか"
"らのインテントのみを受け取ることができますが、マニフェストに `android："
"exported`属性を設定することで、外部アプリケーションからのインテントを受け入れ"
"るように設定できます。\n"
"\n"
"インテントは、どのように対処されるかに基づいて2つのタイプのうちの1つに分類で"
"きます。\n"
"\n"
"- 暗黙的インテント\n"
"- 明示的なインテント\n"
"\n"
"インテントのセキュリティが侵害される主な2つの方法があります。\n"
"\n"
"- **インテントの傍受**は意図していないインテントを受け取った悪意のあるアプリ"
"を含みます。\n"
"これにより機密情報が漏洩する可能性がありますが、より重要なことは、正当なコン"
"ポーネントの代わりに悪質なコンポーネントがアクティブになる可能性があることで"
"す。たとえば、悪意のあるアクティビティがインテントを傍受した場合、正当なアク"
"ティビティの代わりに画面に表示されることがあります。\n"
"- **インテント スプーフィング*は、悪意のあるアプリケーションがインテントを偽"
"造することによって望ましくない動作を誘発する攻撃です。\n"

#: vulnerabilities.py:4718
msgid ""
"\n"
"An implicit intent is being created. This may leave to an intent hijacking\n"
"attack where a malicious application registers for the same action and\n"
"category and could be able to intercept the intent to compromise data or\n"
"alter behaviour\n"
msgstr ""
"\n"
"静的インテントが作成されています。これは、悪意のあるアプリケーションが同じア"
"クションとカテゴリに登録し、データを侵害したり、動きを変えたりするインテント"
"を横取りする可能性のある、インテントハイジャック攻撃の可能性があります。\n"

#: vulnerabilities.py:4725
msgid ""
"\n"
"Android framework provides \"*PendingIntent*\" mechanism to safely perform "
"the\n"
"actions of an intent given by untrusted apps. In some situations, it can be "
"a\n"
"good measure for this kind of vulnerabilities.\n"
"\n"
"    // Explicit intent to wrap\n"
"    Intent intent = new Intent(this, LoginActivity.class);\n"
"\n"
"    // Create pending intent and wrap our intent\n"
"    PendingIntent pendingIntent = PendingIntent.getActivity(this, 1, intent, "
"PendingIntent.FLAG_CANCEL_CURRENT);\n"
"    try {\n"
"        // Perform the operation associated with our pendingIntent\n"
"        pendingIntent.send();\n"
"    } catch (PendingIntent.CanceledException e) {\n"
"        e.printStackTrace();\n"
"    }\n"
"\n"
msgstr ""
"\n"
"Androidフレームワークは、信頼できないアプリケーションによって与えられたインテ"
"ントのアクションを安全に実行するための \"* PendingIntent *\"メカニズムを提供"
"します。場合によっては、この種の脆弱性に対する適切な対策となります。\n"
"\n"
"    // Explicit intent to wrap\n"
"    Intent intent = new Intent(this, LoginActivity.class);\n"
"\n"
"    // Create pending intent and wrap our intent\n"
"    PendingIntent pendingIntent = PendingIntent.getActivity(this, 1, intent, "
"PendingIntent.FLAG_CANCEL_CURRENT);\n"
"    try {\n"
"        // Perform the operation associated with our pendingIntent\n"
"        pendingIntent.send();\n"
"    } catch (PendingIntent.CanceledException e) {\n"
"        e.printStackTrace();\n"
"    }\n"
"\n"

#: vulnerabilities.py:4743
msgid ""
"\n"
"This application wants to create a user account in several trusted\n"
"applications using one broadcast intent:\n"
"\n"
"    Intent intent = new Intent();\n"
"    intent.setAction(\"com.example.CreateUser\");\n"
"    intent.putExtra(\"Username\", uname_string);\n"
"    intent.putExtra(\"Password\", pw_string);\n"
"    sendBroadcast(intent);\n"
"\n"
"This application assumes only the trusted applications will be listening\n"
"for the action. A malicious application can register for this action and\n"
"intercept the user's login information, as below:\n"
"\n"
"    IntentFilter filter = new IntentFilter(\"com.example.CreateUser\");\n"
"    MyReceiver receiver = new MyReceiver();\n"
"    registerReceiver(receiver, filter);\n"
"\n"
"When a broadcast contains sensitive information, create a whitelist of\n"
"applications that can receive the action using the application's manifest\n"
"file, or programmatically send the intent to each individual intended "
"receiver.\n"
msgstr ""
"\n"
"このアプリケーションは、ひとつのブロードキャストインテントを使用して、複数の"
"信頼できるアプリケーションでユーザーアカウントを作成する必要があります。\n"
"\n"
"    Intent intent = new Intent();\n"
"    intent.setAction(\"com.example.CreateUser\");\n"
"    intent.putExtra(\"Username\", uname_string);\n"
"    intent.putExtra(\"Password\", pw_string);\n"
"    sendBroadcast(intent);\n"
"\n"
"このアプリケーションは、信頼できるアプリケーションだけがアクションをリッスン"
"することを想定しています。悪意のあるアプリケーションはこのアクションに登録"
"し、以下のようにユーザのログイン情報を傍受することができます：\n"
"    IntentFilter filter = new IntentFilter(\"com.example.CreateUser\");\n"
"    MyReceiver receiver = new MyReceiver();\n"
"    registerReceiver(receiver, filter);\n"
"\n"
"ブロードキャストに機密情報が含まれている場合は、アプリケーションのマニフェス"
"トファイルを使用してアクションを受け取ることができます。アプリケーションのホ"
"ワイトリストを作成するか、個々のレシーバーにインテントをプログラムで送信しま"
"す。\n"

#: vulnerabilities.py:4765
msgid ""
"\n"
"This vulnerability is related to:\n"
"\n"
"- [CWE-927](https://cwe.mitre.org/data/definitions/927.html): Use of "
"Implicit Intent for Sensitive Communication\n"
"- [JVN#31860555](https://jvn.jp/en/jp/JVN31860555/)  Twicca fails to "
"restrict access permissions\n"
msgstr ""
"\n"
"脆弱性との関連:\n"
"- [CWE-927](https://cwe.mitre.org/data/definitions/927.html): 機密情報のやり"
"取りのための暗黙的インテントの使用\n"
"- [JVN#31860555](https://jvn.jp/en/jp/JVN31860555/)  Twiccaのアクセス許可制限"
"失敗\n"

#: vulnerabilities.py:4778
msgid "Sensitive information in Sqlite database"
msgstr "Sqlite データベースの機密情報"

#: vulnerabilities.py:4780
msgid "Is the application leaking any sensitive information in SQLITE DB?"
msgstr "アプリケーションがSQLite DBの機密情報を漏洩していませんか？"

#: vulnerabilities.py:4783
msgid "Application is not vulnerable to SQLITE db"
msgstr "アプリケーションはSQLite DBに対して脆弱ではありません。"

#: vulnerabilities.py:4784
msgid ""
"\n"
"Android apps contain a lot of user information which also includes some\n"
"sensitive ones such as username, password, email id, banking details, etc. "
"This\n"
"information is stored by the app in SQLite database in various tables using\n"
"diﬀerent attributes. To keep them secure, an app is expected to keep the\n"
"information in secure and encrypted format.\n"
"\n"
"Whenever an app creates a database, by default it is saved\n"
"in a location: `/data/data/app name/database/`. This location is private to "
"an\n"
"app and not accessible to the user or other apps. To share data stored in "
"SQLite\n"
"database, an app can use Content Provider\n"
"\n"
"However, these databases don't have any built-in support for encryption and\n"
"hence, all the information is stored in plain-text format in these files\n"
msgstr ""
"\n"
"Androidアプリには多くのユーザー情報が含まれています。\n"
"ユーザー名、パスワード、電子メールID、銀行詳細などの機密情報が含まれます。こ"
"の情報は、さまざまなテーブルを使用してSQLiteデータベースにアプリケーションに"
"よって格納されます。\n"
"それらを安全に保つために、アプリは安全かつ暗号化された形式で情報を保持するこ"
"とが求められます。\n"
"\n"
"アプリケーションがデータベースを作成するたびに、デフォルトでは \n"
"`/ data / data / app name / database /`  に保存されます。\n"
"この場所はアプリケーション専用の場所で、ユーザーや他のアプリからはアクセスで"
"きません。 SQLiteデータベースに保存されたデータを共有するために、アプリはコン"
"テンツプロバイダを使用できます。\n"
"\n"
"ただし、これらのデータベースには暗号化のための組み込みサポートはないため、こ"
"れらのファイルにはすべての情報がプレーンテキスト形式で保存されます。\n"

#: vulnerabilities.py:4799
msgid ""
"\n"
"SQLITE databases which are leaking information and their queries are listed\n"
"below:\n"
msgstr ""
"\n"
"情報が漏洩しているSQLiteデータベースとそのクエリを以下に示します。\n"

#: vulnerabilities.py:4807
msgid ""
"\n"
"1. Wherever possible you must avoid storing sensitive data within your app.\n"
"2. Use libraries like SQLcipher to encrypt the information stored\n"
"3. set `\"allow backup=false\"` to avoid exploiting data using ADB\n"
"\n"
"With the library SQLCipher, SQLite databases can be password-encrypted.\n"
"\n"
"    SQLiteDatabase secureDB = SQLiteDatabase.openOrCreateDatabase(database, "
"\"password123\", null);\n"
"    secureDB.execSQL(\"CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,"
"Password VARCHAR);\");\n"
"    secureDB.execSQL(\"INSERT INTO Accounts VALUES('admin','AdminPassEnc');"
"\");\n"
"    secureDB.close();\n"
"\n"
"If encrypted SQLite databases are used, determine whether the password is\n"
"hard-coded in the source, stored in shared preferences, or hidden somewhere\n"
"else in the code or filesystem. Secure ways to retrieve the key include:\n"
"\n"
"- Asking the user to decrypt the database with a PIN or password once\n"
"  the app is opened (weak passwords and PINs are vulnerable to\n"
"  brute force attacks)\n"
"- Storing the key on the server and allowing it to be accessed from\n"
"  a web service only (so that the app can be used only when the device\n"
"  is online)\n"
msgstr ""
"\n"
"1.可能な限り、機密データをアプリに保存しないようにする必要があります。\n"
"2. SQLCipherのようなライブラリを使用して、格納されている情報を暗号化しま"
"す。\n"
"3.「allow backup = false」を設定してADBを使用したデータの悪用を回避します。\n"
"\n"
"ライブラリSQLCipherでは、SQLiteデータベースをパスワードで暗号化できます。\n"
"\n"
"    SQLiteDatabase secureDB = SQLiteDatabase.openOrCreateDatabase(database, "
"\"password123\", null);\n"
"    secureDB.execSQL(\"CREATE TABLE IF NOT EXISTS Accounts(Username VARCHAR,"
"Password VARCHAR);\");\n"
"    secureDB.execSQL(\"INSERT INTO Accounts VALUES('admin','AdminPassEnc');"
"\");\n"
"    secureDB.close();\n"
"\n"
"暗号化されたSQLiteデータベースが使用されている場合は、パスワードがソースで"
"ハードコーディングされているか、共有設定に保存されているか、またはコードや"
"ファイルシステムのどこかに隠れているかどうかを判断します。キーを取得する安全"
"な方法には、次のようなものがあります。\n"
"\n"
" - アプリケーションが開かれた後、PINまたはパスワードを使用してデータベースを"
"復号するようにユーザーに尋ねる（弱いパスワードとPINはブルートフォース攻撃に対"
"して脆弱です。）\n"
"- サーバーにキーを格納し、Webサービスからのみアクセスできるようにする（デバイ"
"スがオンラインのときだけアプリケーションを使用できるようにする）\n"

#: vulnerabilities.py:4830
msgid ""
"\n"
"SQLite is an SQL database engine that stores data in .db files.\n"
"The Android SDK has built-in support for SQLite databases.\n"
"The main package used to manage the databases is android.database.sqlite.\n"
"You may use the following code to store sensitive information within an\n"
"activity:\n"
"\n"
"    SQLiteDatabase notSoSecure = openOrCreateDatabase(\"privateNotSoSecure\","
"MODE_PRIVATE,null);\n"
"    notSoSecure.execSQL(\"CREATE TABLE IF NOT EXISTS Accounts(Username "
"VARCHAR, Password VARCHAR);\");\n"
"    notSoSecure.execSQL(\"INSERT INTO Accounts VALUES('admin','AdminPass');"
"\");\n"
"    notSoSecure.close();\n"
"\n"
"Once the activity has been called, the database file privateNotSoSecure "
"will\n"
"be created with the provided data and stored in the clear text\n"
"file `/data/data/<package-name>/databases/privateNotSoSecure`\n"
msgstr ""
"\n"
"SQLiteは、データを.dbファイルに保存するSQLデータベースエンジンです。Android "
"SDKには、SQLiteデータベースのサポートが組み込まれています。\n"
"データベースの管理に使用される主なパッケージは、android.database.sqliteで"
"す。\n"
"機密情報をアクティビティ内に保存するには、次のコードを使用します。：\n"
"    SQLiteDatabase notSoSecure = openOrCreateDatabase(\"privateNotSoSecure\","
"MODE_PRIVATE,null);\n"
"    notSoSecure.execSQL(\"CREATE TABLE IF NOT EXISTS Accounts(Username "
"VARCHAR, Password VARCHAR);\");\n"
"    notSoSecure.execSQL(\"INSERT INTO Accounts VALUES('admin','AdminPass');"
"\");\n"
"    notSoSecure.close();\n"
"\n"
"アクティビティが呼び出されると、データベースファイル privateNotSoSecure が提"
"供されたデータから作成され、平文ファイルが `/ data / data / <package-name> / "
"databases / privateNotSoSecure`　に保存されます。\n"

#: vulnerabilities.py:4854
msgid "iOS Binary having ASLR Protection"
msgstr "ASLR保護を持つiOSバイナリ"

#: vulnerabilities.py:4855
msgid "Does the application have ASLR Protection?"
msgstr "アプリケーションにASLR保護機能はありますか？"

#: vulnerabilities.py:4856
msgid "The application does seem to have ASLR Protection."
msgstr "アプリケーションにASLR保護があるようです。"

#: vulnerabilities.py:4857
msgid ""
"\n"
"iOS has several mechanisms which prevent the application from being\n"
"compromised at runtime. In order to understand the security issues that\n"
"affect iOS applications, it is important to understand and to known the\n"
"security features of the platform.\n"
"\n"
"- Code signing: ensures that all applications come from a approved source "
"(using\n"
"  Apple-issued certificates)\n"
"- Address Space Layout Randomization (ASLR): Usually compiled using `-fPIE -"
"pie`\n"
msgstr ""
"\n"
"iOSには、実行時にアプリケーションが侵害されるのを防ぐいくつかのメカニズムがあ"
"ります。iOSアプリケーションに影響を与えるセキュリティ問題を理解するためには、"
"プラットフォームのセキュリティ機能を理解し、知っておくことが重要です。 \n"
"\n"
"- コード署名：すべてのアプリケーションがApple発行の証明書を使用して承認された"
"ソースから取得されることを保証する。（Apple発行の証明書を使用）\n"
"- アドレス空間配置のランダム化（ASLR）：通常、-fPIE -pieを使用してコンパイル"
"される\n"

#: vulnerabilities.py:4872
msgid ""
"\n"
" Usually the binary is compiled using the `PIE` flag by using `-fPIE -pie`\n"
" during compilation time\n"
msgstr ""
"\n"
"通常、バイナリは fPIE -pie、PIEフラグを使ってコンパイルされます。\n"

#: vulnerabilities.py:4891
msgid ""
"MediaProjection: Android Service Allows Recording of Audio, Screen Activity"
msgstr ""

#: vulnerabilities.py:4892
msgid ""
"Does the application protect sensitive screens from being displayed in "
"screencasts initiated by third-party Apps?"
msgstr ""

#: vulnerabilities.py:4893
msgid ""
"The application does seem protect sensitive screens from being displayed in "
"screencasts initiated by third-party Apps."
msgstr ""

#: vulnerabilities.py:4894
msgid ""
"\n"
"Starting with Android 5.0, Google introduced the android.media.projection "
"API which allows any third-party App to perform screen capture and screen "
"sharing (fixed in Android 8).\n"
"\n"
"Such an App can capture everything on the device’s screen, including "
"sensitive activity from all other Apps such as password keystrokes, credit "
"card data, etc. The capturing ability remains on even if the user terminates/"
"closes the App, but not after a reboot.\n"
"\n"
msgstr ""

#: vulnerabilities.py:4900
msgid ""
"\n"
"Protect all sensitive windows within the App by enabling the `FLAG_SECURE` "
"flag. This flag will prevent Apps from being able to record the protected "
"windows. Also, the flag will prevent users from taking screenshots of these "
"windows (by pressing the VOLUME_DOWN and POWER buttons). As such screenshots "
"are stored on the SDCard by default, they are accessible to all Apps and "
"sensitive data may be exposed.\n"
msgstr ""

#: vulnerabilities.py:4904
msgid ""
"\n"
"Below is an example of how to use `FLAG_SECURE` inside your activity\n"
"\n"
"    public class SecureActivity extends Activity {\n"
"        @Override\n"
"        protected void onCreate(Bundle savedInstanceState) {\n"
"            super.onCreate(savedInstanceState);\n"
"\n"
"            // Set the Secure flag for this Window\n"
"            getWindow().setFlags(LayoutParams.FLAG_SECURE, LayoutParams."
"FLAG_SECURE);\n"
"        }\n"
"    }\n"
"\n"
msgstr ""

#: vulnerabilities.py:4919
msgid ""
"\n"
"- [Android 5.0 Docs](https://developer.android.com/about/versions/"
"android-5.0.html)\n"
"- [FLAG_SECURE docs](https://developer.android.com/reference/android/view/"
"WindowManager.LayoutParams#FLAG_SECURE)\n"
"\n"
msgstr ""

#: vulnerabilities.py:4931
msgid "External data in raw SQL queries"
msgstr ""

#: vulnerabilities.py:4932
msgid "Does the application uses user-input into raw SQL query?"
msgstr ""

#: vulnerabilities.py:4933
msgid "The application does not seem to use raw SQL query."
msgstr ""

#: vulnerabilities.py:4934
msgid ""
"\n"
"Sql injection is possible because we use quotation marks to delimit strings "
"and also to be parts of strings, making it impossible to interpret them "
"sometimes. If we had delimiters that could not be used in string data, sql "
"injection never would have happened. Solving the delimiter problem "
"eliminates the sql injection problem. Structure queries do that.\n"
"\n"
"Prepared statements are resilient against SQL injection, because parameter "
"values, which are transmitted later using a different protocol, need not be "
"correctly escaped. If the original statement template is not derived from "
"external input, SQL injection cannot occur.\n"
msgstr ""

#: vulnerabilities.py:4939
msgid ""
"\n"
"Inclusion of input into raw SQL queries can potentially lead to a local SQL "
"injection vulnerability in the mobile application.\n"
"\n"
"The correct approach is to use prepared SQL statements beyond user's "
"control.\n"
msgstr ""

#: vulnerabilities.py:4945
msgid ""
"\n"
"Below is an example of how to use Prepeared SQL statement:\n"
"\n"
"    PreparedStatement pstmt = con.prepareStatement(\"UPDATE EMPLOYEES SET "
"SALARY = ? WHERE ID = ?\");\n"
"    pstmt.setBigDecimal(1, 153833.00)\n"
"    pstmt.setInt(2, 110592)\n"
"\n"
msgstr ""

#: vulnerabilities.py:4953
msgid ""
"\n"
"Example of an insecure code:\n"
"\n"
"    db.rawQuery(\"SELECT username FROM users_table WHERE id = '\"+ input_id +"
"\"'\");\n"
"    db.execSQL(\"SELECT username FROM users_table WHERE id = '\"+ input_id +"
"\"'\");\n"
"\n"
msgstr ""

#: vulnerabilities.py:4960
msgid ""
"\n"
"- [Android SQLite Docs](https://developer.android.com/reference/android/"
"database/sqlite/SQLiteDatabase.html)\n"
"- [Android PrepearedStatement docs](https://developer.android.com/reference/"
"java/sql/PreparedStatement.html)\n"
"\n"
msgstr ""

#: vulnerabilities.py:4972
msgid "Enabled Android Application Backup"
msgstr ""

#: vulnerabilities.py:4973
msgid "Is the application backup enabled?"
msgstr ""

#: vulnerabilities.py:4974
msgid "The application backup is not enabled."
msgstr ""

#: vulnerabilities.py:4975
msgid ""
"\n"
"The mobile application uses external backup functionality (default Android "
"backup mechanism) that may store inside sensitive data from the "
"application.\n"
"\n"
"In certain conditions, this may lead to information disclosure (e.g. when a "
"backup server or the Gmail account is compromised).\n"
msgstr ""

#: vulnerabilities.py:4980
msgid ""
"\n"
"Application backup might contain sensitive information private data of the "
"app into their PC\n"
msgstr ""

#: vulnerabilities.py:4984
msgid ""
"\n"
"Below is an example of how to prevent the application from getting backed-up "
"via adb in your AndroidManifest file:\n"
"\n"
"    android:allowBackup=\"false\"\n"
"\n"
msgstr ""

#: vulnerabilities.py:4990
msgid ""
"\n"
"Example of an insecure code in AndroidManifest file:\n"
"\n"
"    android:allowBackup=\"true\"\n"
"\n"
msgstr ""

#: vulnerabilities.py:4996
msgid ""
"\n"
"- [Android Manifest Docs](https://developer.android.com/guide/topics/"
"manifest/application-element.html)\n"
"- [Hacking Android Apps using Backup](http://resources.infosecinstitute.com/"
"android-hacking-security-part-15-hacking-android-apps-using-backup-"
"techniques/)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5008
msgid "Javascript CORS enabled in Webview"
msgstr ""

#: vulnerabilities.py:5009
msgid "Is the application vulnerable to Javascript CORS?"
msgstr "]"

#: vulnerabilities.py:5010
msgid "The application is not vulnerable to Javascript CORS."
msgstr ""

#: vulnerabilities.py:5011
msgid ""
"\n"
"Cross-Origin Resource Sharing (CORS) is enabled in WebView. JavaScript used "
"in mobile application can send and receive data from arbitrary remote hosts. "
"This can be a risk if the remote host is impersonated or compromised.\n"
msgstr ""

#: vulnerabilities.py:5014
msgid ""
"\n"
"Javascript in the Webview having CORS enabled to be loaded from file and any "
"arbitary URL\n"
msgstr ""

#: vulnerabilities.py:5018
msgid ""
"\n"
"Below is an example of how to prevent the application from Javascript CORS "
"issue:\n"
"\n"
"    WebSettings settings = getSettings();\n"
"    settings.setAllowUniversalAccessFromFileURLs(false)\n"
"    settings.setAllowFileAccessFromFileURLs(false)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5026
msgid ""
"\n"
"Example of an insecure code :\n"
"\n"
"    WebSettings settings = getSettings();\n"
"    settings.setAllowUniversalAccessFromFileURLs(true)\n"
"    settings.setAllowFileAccessFromFileURLs(true)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5034
msgid ""
"\n"
"- [Android Webkit Settings Docs](https://developer.android.com/reference/"
"android/webkit/WebSettings.html)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5045
msgid "Java Object Deserialization Vulnerability"
msgstr ""

#: vulnerabilities.py:5046
msgid "Is the application vulnerable to Object deserialization?"
msgstr ""

#: vulnerabilities.py:5047
msgid "The application is not vulnerable to object deserialization."
msgstr ""

#: vulnerabilities.py:5048
msgid ""
"\n"
"It is often convenient to serialize objects for convenient communication or "
"to save them for later use. However, deserialized data or code can often be "
"modified without using the provided accessor functions if it does not use "
"cryptography to protect itself. Furthermore, any cryptography would still be "
"client-side security - which is of course a dangerous security assumption.\n"
"\n"
"An attempt to serialize and then deserialize a class containing transient "
"fields will result in NULLs where the non-transient data should be. This is "
"an excellent way to prevent time, environment-based, or sensitive variables "
"from being carried over and used improperly.\n"
"\n"
msgstr ""

#: vulnerabilities.py:5054
msgid ""
"\n"
"Object deserialization performed on an untrusted resource (e.g. user-"
"supplied input or external storage), can be dangerous if the data for "
"deserialization is tampered by an attacker.\n"
msgstr ""

#: vulnerabilities.py:5058
msgid ""
"\n"
"Use only serialization when you have the control over data. Use the "
"following pointers to figure out if serialization is necessary\n"
"\n"
"- Does the deserialization take place before authentication?\n"
"- Does the deserialization limit which types can be deserialized?\n"
"- Does the deserialization host have types available which can be repurposed "
"towards malicious ends?\n"
"\n"
msgstr ""

#: vulnerabilities.py:5066
msgid ""
"\n"
"Example of an insecure code :\n"
"\n"
"    bundle.putSerializable(\"exampleClass\", exampleOfSerializabledClass);\n"
"    exampleOfSerializabledClass = bundle.getSerializable(\"exampleClass\");\n"
"\n"
msgstr ""

#: vulnerabilities.py:5073
msgid ""
"\n"
"- [CVE-2014-7911](https://androidvulnerabilities.org/vulnerabilities/"
"ObjectInputStream_deserializable)\n"
"- [POC for this vulnerability](https://github.com/retme7/CVE-2014-7911_poc)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5085
msgid "Zipperdown Vulnerability leading to Remote Code Execution Attack"
msgstr ""

#: vulnerabilities.py:5086
msgid "Is the application vulnerable to ZipperDown?"
msgstr ""

#: vulnerabilities.py:5087
msgid "The application is not vulnerable to ZipperDown."
msgstr ""

#: vulnerabilities.py:5088
msgid ""
"\n"
"ZipperDown attack launches a Man-in-the-Middle (MiTM) attack and replace the "
"benign .zip file with malicious .zip file over the unencrypted network.\n"
"\n"
"The app uses the ZipArchive or SSZipArchive library to decompress it. Since "
"the ZipArchive and SSZipArchive libraries allow unzipping files in parent "
"directories, malicious .zip file can be unzipped to overwrite app data or "
"codes. Apps that dynamically load the codes, such as via JavaScript bridges, "
"make it easier for an attacker to overwrite the codes and launch remote code "
"execution attacks.\n"
msgstr ""

#: vulnerabilities.py:5093
msgid ""
"\n"
"The remote code execution occurs inside the affected app allowing a remote "
"attacker to possess the same privileges or permissions as the vulnerable "
"app. For instance, if a vulnerable app has permission to access the user’s "
"address book, the ZipperDown attacker will also have access to the affected "
"user’s address book.\n"
msgstr ""

#: vulnerabilities.py:5097
msgid ""
"\n"
"Use the following pointers to make sure the application is not affected with "
"ZipperDown vulnerability\n"
"\n"
"- Use SSL pinning to download .zip file or any assets\n"
"- Use the latest version of SSArchive or Ziparchive third-party "
"decompression library\n"
"\n"
msgstr ""

#: vulnerabilities.py:5105
msgid ""
"\n"
"- [Zipperdown Web](https://zipperdown.org/)\n"
"- [Zipperdown Issue in ZipArchive](https://github.com/ZipArchive/ZipArchive/"
"issues/453)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5117
msgid "Deprecated setPluginState in WebView"
msgstr ""

#: vulnerabilities.py:5118
msgid "Does the application uses setPluginState in WebView?"
msgstr ""

#: vulnerabilities.py:5119
msgid "The application does not uses setPluginState in WebView."
msgstr ""

#: vulnerabilities.py:5120
msgid ""
"\n"
"The mobile application uses a deprecated setPluginState method in WebView. "
"The \"setPluginState\" method was deprecated in Android’s API level 18 "
"because plugins will not be supported anymore in the future and should not "
"be used. Example of plugins are embedded PDF reader, Flash plugin, etc.\n"
msgstr ""

#: vulnerabilities.py:5123
msgid ""
"\n"
"`setPluginState` has security implication and depricated by Android. It is "
"unsafe to use in production.\n"
msgstr ""

#: vulnerabilities.py:5127
msgid ""
"\n"
"`setPluginState` feature is deprecated, don't enable it.\n"
msgstr ""

#: vulnerabilities.py:5130
msgid ""
"\n"
"Following is an example of insecure implemntation\n"
"\n"
"    WebSettings settings = webView.getSettings();\n"
"    settings.setPluginsEnabled(true);\n"
"    settings.setPluginState(WebSettings.PluginState.ON);\n"
"\n"
msgstr ""

#: vulnerabilities.py:5138
msgid ""
"\n"
"- [Webview docs](https://developer.android.com/reference/android/webkit/"
"WebView)\n"
"- [WebSettings docs](https://developer.android.com/reference/android/webkit/"
"WebSettings)\n"
"\n"
msgstr ""

#: vulnerabilities.py:5150
msgid "Improper Session Management"
msgstr ""

#: vulnerabilities.py:5151
msgid "Does the application uses proper Session Management?"
msgstr ""

#: vulnerabilities.py:5152
msgid "The application does uses proper Session Management"
msgstr ""

#: vulnerabilities.py:5153
msgid ""
"Once the user successfully logs in to the application with credentials, "
"access tokens are generated by the server and assigned to the user. "
"Thereafter, access tokens are used to identify the users and maintain the "
"session until they logout. It is critical to generate, assign, invalidate "
"access tokens securely since they provide a way to authenticate and "
"authorize to the server resources post login. Failing to do so may result in "
"loss of confidentiality and integrity. "
msgstr ""

#: vulnerabilities.py:5156
msgid ""
"If the application does not manage sessions securely, an attacker may be "
"able to remotely compromise accounts, reuse the tokens to make unauthorised "
"API calls on behalf of other users."
msgstr ""

#: vulnerabilities.py:5160
msgid ""
"The application server should generate access tokens which are "
"cryptographically strong, dynamic and expires as soon as the user logs off "
"or is inactive for a particular amount of time"
msgstr ""
